<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>人活着究竟是为了什么</title>
      <link href="2022/03/25/%E4%BA%BA%E6%B4%BB%E7%9D%80%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>2022/03/25/%E4%BA%BA%E6%B4%BB%E7%9D%80%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>1、什么是成功。</p><p>当人到中年的时候，身体健康，略有积蓄，已婚，配偶体贴，孩子听话，有一份比较喜欢的工作，不必成名，也不必发财，不必老要看人眼色行事，做想做的那个自己，这就是成功。</p><blockquote><p>每个人在不同的时间对成功的理解都不相同，我在读书上学的时候，我觉得好好学习，上一个好的学校，找一个好一点的工作，就是成功；后来上了大学我觉得只要工作了，可以自己自食其力，不必再依靠父母，就是成功；再后来工作了，刚开始工资很低，我觉得工资要是能再高一些，可以买车、买房、让父母少一些操劳，就是成功；再再后来，我结婚了，有了孩子，我觉得把孩子教育好了，我走过的弯路，他不要再走，他可以在他想做一些事的时候能够去做，就是成功。</p><p>回首过去，我发现，每一个阶段因为诉求的不同，对成功的理解也不同，在脑海深处，我也在反问自己：我为什么而活？我究竟在追求什么？</p><p>假如我此刻死了，或者突然从这个世界消失了，最先发现的大概是我的妻子，因为本应该按时下班回家吃饭，没有回家，没有电话，她一定会打我的手机，越打不通，越着急，然后是我公司的同事，还有个问题没有处理，怎么找不到人了，也会打我的电话，实在打不通就找其他人来解决这个问题了，然后是我的父母，一个月了也没往家打一个电话，他们会想自己的儿子，他们会打我的电话，看是不是最近太忙了。</p><p>一周以后，还是找不到人，我的妻子和父母报了警，每天期盼着自己的丈夫和儿子能回来，公司也因为一直找不到人，找了另外一个人顶替我的岗位。</p><p>再过很久很久以后，我的妻子也许会另嫁，也许不会，我的父母仍然会期盼着儿子的消息，公司早就忘记了还有我这么一个人了。</p><p>想到这里，会明白：成功、快乐、价值、幸福的终极是血脉相连、荣辱与共的家人。好好活着，尽自己的努力，照顾好家人，就够了。</p></blockquote><p>2、什么是快乐。</p><p>因癌辞世的复旦大学教师于娟，在生前日记写道：在生死临界点的时候，你会发现，任何的加班（长期熬夜等于慢性自杀）， 给自己太多的压力，买房买车的需求，这些都是浮云。如果有时间，好好陪陪你的孩子，把买车的钱给父母亲买双鞋子，不要拼命去换什么大房子，换什么豪车，和相爱的人在一起，蜗居也温暖，自行车也快乐！</p><p>3、你的价值在哪。</p><p>假如你病倒了或者猝死了，你服务的单位会第一时间找到人替代你，一切如常运作，你没想象得那么重要；而你的父母、家人、爱人孩子的天会塌下来，你对于他们才是最重要的。所以再别秉持什么自己有病不去看；适度工作，多陪家人，爱惜自己，过正常的日子。</p><p>4、什么是幸福。</p><p>家里没病人，牢里没亲人，外头没仇人，圈里没小人，身边没坏人；看似好像没情人，办事有熟人，谈笑有哲人，聚会有高人，喝茶有贤人，闲聊有达人，发条微信有一大帮转发的人。生命中，有喜欢做的事，有健康的身体，有爱你的人，有一个乖巧阳光的孩子，有几个一段日子不见就想的朋友，这就是幸福！</p><blockquote><p>作者：佚名，来源网络</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache架构师总结的30条架构原则</title>
      <link href="2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/"/>
      <url>2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者叫 Srinath，是一位科学家，软件架构师，也是一名在分布式系统上工作的程序员。他是 Apache Axis2 项目的联合创始人，也是 Apache Software 基金会的成员。他是 WSO2 流处理器（wso2.com/analytics）的联席架构师。Srinath 撰写了两本关于 MapReduce 和许多技术文章的书。他获得了博士学位。来自美国印第安纳大学。  </p></blockquote><p>Srinath 通过不懈的努力最终总结出了 30 条架构原则，他主张架构师的角色应该由开发团队本身去扮演，而不是专门有个架构师团队或部门。而不是专门有个架构师团队或部门。Srinath 认为架构师应该扮演的角色是一个引导者，讨论发起者，花草修建者，而不是定义者和构建者。Srinath 为了解决团队内部的架构纷争和抉择，制定了以下 30 条原则，这些原则被成员们广泛认可，也成为了新手架构师的学习途径。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>原则 1：KISS(Keep it simple,sutpid) ：保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。  </p><blockquote><p>点评：简单即是复杂！拿你的代码来说，你想要写的简单且容易理解的话，你就需要花更多的时间去思考。  </p></blockquote><p>原则 2：YAGNI(You aren’t gonna need it)：不要去搞一些不需要的东西，需要的时候再搞吧。</p><blockquote><p>点评 : 这一点我被 diss 过好几次，之前的时候，我总是臆想觉得某个功能以后可能会用到，然后就顺手把它实现了，实际到了后面并没用上，反而造成了代码冗余。</p></blockquote><p>原则 3： 爬，走，跑。换句话说就是先保证跑通，然后再优化变得更好，然后继续优化让其变得伟大。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑（最大两周），然后去迭代。</p><p>原则 4：创建稳定、高质量的产品的唯一方法就是<strong>自动化测试</strong>。所有的都可以自动化，当你设计时，不妨想想这一点。</p><blockquote><p>点评：单侧还是很有必要的，但是没有一个恒定的标准说你应该怎么去做。</p></blockquote><p>原则 5： 时刻要想投入产出比（ROI）。就是划得来不。</p><p>原则 6： 了解你的用户，然后基于此来平衡你需要做哪些事情。不要花了几个月时间做了一个 devops 用户界面，最后你发现那些人只喜欢命令行。此原则是原则 5 的一个具体表现。</p><blockquote><p>点评:是否有站在用户的角度思考问题呢？是否是为了用新技术而用新技术？</p></blockquote><p>原则 7：设计和测试一个功能，尽可能的独立。当你做设计时，应该想想这一条。从长远来看这能给你解决很多问题，否则你的功能只能等待系统其他所有的功能都就绪了才能测试，这显然很不好。有了这个原则， 你的版本将会更加的顺畅。</p><p>原则 8： 不要搞花哨的。我们都喜欢高端炫酷的设计。最后我们搞了很多功能和解决方案到我们的架构中，然后这些东西根本不会被用到。<br>点评:简单点！说话的方式简单点！</p><h4 id="功能选择"><a href="#功能选择" class="headerlink" title="功能选择"></a>功能选择</h4><p>原则 9： 不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。这个观点主要思想就是你挑几个很少的使用场景，然后把它搞出来，然后发布上线让用户使用，然后基于体验和用户反馈再决定下一步要做什么。</p><p>原则 10： 尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。</p><p>原则 11： 等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。</p><p>原则 12：<strong>有时候你要有勇气和客户说不</strong>。这时候你需要找到一个更好的解决方案来去解决。记住亨利福特曾经说过的 ：”如果我问人们他们需要什么，他们会说我需要一匹速度更快的马”。记住：你是那个专家，你要去引导和领导。要去做正确的事情，而不是流行的事情。最终用户会感谢你为他们提供了汽车。</p><h4 id="服务端设计和并发"><a href="#服务端设计和并发" class="headerlink" title="服务端设计和并发"></a>服务端设计和并发</h4><p>原则 13：要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。</p><p>原则 14： 要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情。</p><p>原则 15：如果你的设计是一个无阻塞且事件驱动的架构，那么千万不要阻塞线程或者在这些线程中做一些 IO 操作，如果你做了，你的系统会慢的像骡子一样。</p><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>原则 16：无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来，这是起码的。</p><p>原则 17：保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便（使用原则 18）。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的。</p><p>原则 18：实现一个操作尽可能的幂等。这样的话就比较好恢复，而且你还处于至少一次传递（at least once delivery）的状态。</p><p>原则 19： 知道 CAP 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的。</p><p>原则 20： 分布式一致性无法扩展，也无法进行组通信，也无法进行集群范围内的可靠通信。理想情况下最大的节点限制为 8 个节点。</p><p>原则 21： 在分布式系统中，你永远无法避免延迟和失败。</p><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><p>原则 22： 要了解你的用户和清楚他们的目标。他们是新手、专家还是偶然的用户？他们了解计算机科学的程度。极客喜欢扩展点，开发者喜欢示例和脚本，而普通人则喜欢 UI。</p><p>原则 23： 最好的产品是不需要产品手册的。</p><blockquote><p>点评：这个是说产品易用。很多人觉得敏捷开发下不需要文档，实际上，一个系统即是在敏捷开发的情况下，有些必要的文档比如重大更新记录、相关硬件设施等等还是需要的。</p></blockquote><p>原则 24： 当你无法在两个选择中做决定的时候，请不要直接把这个问题通过提供配置选项的方式传递给用户。这样只能让用户更加的发懵。如果连你这个专家都无法选择的情况下，交给一个比你了解的还少的人这样合适吗？最好的做法的是每次都找到一个可行的选项；次好的做法是自动的给出选项，第三好的做法是增加一个配置参数，然后设置一个合理的默认值。</p><p>原则 25： 总是要为配置设置一个合理的默认值。</p><p>原则 26：设计不良的配置会造成一些困扰。应该总是为配置提供一些示例值。</p><p>原则 27： 配置值必须是用户能够理解和直接填写的。比如：不能让用户填写最大缓存条目的数量，而是应该让用户填写可被用于缓存的最大内存。</p><p>原则 28： 如果输入了未知的配置要抛出错误。永远不要悄悄的忽略。悄悄的忽略配置错误往往是找 bug 花了数小时的罪魁祸首。</p><h4 id="艰难的问题"><a href="#艰难的问题" class="headerlink" title="艰难的问题"></a>艰难的问题</h4><p>原则 29： 梦想着新的编程语言就会变得简单和明了，但往往要想真正掌握会很难。不要轻易的去换编程语言。</p><p>原则 30： 复杂的拖拉拽的界面是艰难的，不要去尝试这样的效果，除非你准备好了 10 人年的团队。</p><p>最后，说一个我的感受。在一个理想的世界里，一个平台应该是有多个正交组件组成-每个组件都负责一个方面（比如，security，messaging，registry，mdidation，analytics）。好像一个系统构建成这样才是完美的。</p><p>但不幸的是，现实中我们很难达到这样的状态。因为在项目初始状态时，很多事情是不确定的，你无法做到这样的独立性，现在我更倾向于在开始的时候适当的重复是必要的，当你尝试铲除他们的时候，你会发现引入了新的复杂性，分布本身就意味着复杂。有时候治愈的过程要比疾病本身更加的糟糕。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为一个架构师，应该像园丁一般，更多的是修剪花草，除草而不是去定义和构建，你应该策划而不是指挥，你应该去修剪而不是去定义，应该是讨论而不是贴标签。</p><p>虽然在短期内可能会觉得也没什么，但从长远看，指导团队找到自己的方式会带来好处。如果你稍不留神，就很容易让架构成为一个空洞的词汇。比如设计者会说他的架构是错误的，但不知道为什么是错误的。一个避免这种情况的好办法就是有一个原则列表，这个原则列表是被广泛接受的，这个列表是人们讨论问题的锚点，也是新手架构师学习的路径。</p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好好的写代码吧</title>
      <link href="2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/"/>
      <url>2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>好好的写软件、写代码，不给别人挖坑，这应该是每个程序员对自己最基本的要求。当然我也踩过别人的坑，曾经由于自己的无知，也给别人挖过坑。不管因为什么，烂的代码一旦上线，你就得维护它，这是件很痛苦的事情。就好像你撒了一个谎，为了圆这个谎，你不得不再撒更多的谎，可谎言终究是谎言，终究会被扯破的一天。当某一天实在维护不动了，你走了，来了一个新的程序员来维护他，你失去了一个成为优秀程序员的机会，同时也浪费了更多人的时间和精力。<br>我们的时间应该去写好的代码、做好的事情，然后享受生活，而不是和这些烂代码搏斗。如果不重视这些事情，会制造很多麻烦，会让质量下降，会让一个本来可以快速推进的事情变得缓慢，会让你不得不去做一些无聊的事情、解决一些无聊的问题。也会挫伤想写好的代码的人的积极性。所以，如果你不好好写代码，你乱管理事情，我会认为你在给我制造麻烦，浪费我的时间，那么我就会和你有一些争论。<br>无论在哪个位置，都应该有一些自己的追求，至少不要成为别人的麻烦，而是努力成为一个解决麻烦的人。如果你的心和大脑在解决麻烦的路上，那么你犯的错误，我称之为经验；如果你是一个麻烦制造者，并且浑然不觉，那么我想我会提醒你；当然，我并不想教你做事，我只是想和你一起成为麻烦、问题的终结者，然后下班。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文摘录</title>
      <link href="2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
      <url>2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，则万事可成  <span id="more"></span></p><hr><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p><hr><p>如果此时的你正在经历痛苦<br>那么请记住<br>我们所遭遇的痛苦与磨难<br>其实只是过去行为的一个结果<br>我们没有理由去责怪他人<br>更没有必要自责<br>你若能能积极的心态面对它<br>那么正在经历的痛苦<br>不仅完结了一个旧的因果<br>而且还会成为一个新的善因<br>痛苦并不总是坏事<br>人生的得失起伏<br>都可以是让你觉悟的契机<br>关键是看你以怎样的心态去面对<br>—次第花开  </p><hr><p>初入红尘<br>不知人间疾苦<br>蓦然回首<br>已是苦中之人<br>这杯中酒三分<br>这酒中悲七分<br>关关难过关关过<br>夜夜难熬夜夜熬<br>愿这世间所有爱恨情仇皆溶于酒<br>且将这风尘作酒<br>一饮消愁</p><hr><p>世间万物都是空<br>功名利禄逝如风<br>天也空地也空<br>人生渺茫在其中<br>金也空银也空<br>死后何曾在手中<br>权也空名也空<br>转眼荒郊土一捧<br>情也空义也空<br>大难来时影无踪<br>生如百花逢春好<br>死如黄叶落秋风<br>回首仔细思量起<br>便是南柯一梦中<br>–看破想通，万事皆空  </p><hr><p>君子慎独<br>不欺暗室<br>卑以自牧<br>含章可贞<br>大丈夫立于天地之间<br>当仰天地浩然正气<br>行光明磊落之事<br>克己慎独守心明性  </p><hr><p>子成人父方解油盐非易事<br>女为人母才知酱醋味千般<br>幼年常感父身宽<br>双肩可撼千重山<br>而今转瞬成人父<br>才知年少见识偏<br>流光逝<br>步蹒跚<br>碎银几两汉子难<br>也曾心怀青云志<br>回首只盼老少安  </p><hr><p>自古人生最忌满<br>半贫半富半自安<br>半命半天半机遇<br>半取半舍半行善<br>半聋半哑半糊涂<br>半智半愚半圣贤<br>半人半我半自在<br>半醒半醉半神仙<br>半亲半爱半苦乐<br>半俗半禅半随缘<br>人生一半在于我<br>另外一半听自然  </p><hr><p>对于无能为力的事，当断<br>对于生命中无缘的人，当舍<br>对于心中的烦与杂念，当离<br>目光所及，皆是回忆；<br>心之所想，皆是过往；<br>只有放下执念，心才能回归安宁。</p><hr><p>鱼那么信任水，水却把它煮了<br>树叶那么信任风，风却把它吹落了<br>我那么信任你，你却把我伤害了<br>后来我才发现<br>煮鱼的不是水，而是火<br>吹落树叶的不是风，而是秋天，<br>伤害我的也不是你，而是我的自作多情；  </p><hr><p>聋子说炮不响<br>瞎子说灯不亮<br>瘸子说炮挺响，灯也亮<br>只是这看起来平平坦坦的路走起来有点摇摇晃晃<br>人呐，<br>如果看不到自己的问题和不足，总会认为错的是别人。</p><hr><p>人间非净土<br>各有各的苦<br>同是红尘悲伤客<br>莫笑谁是可怜人<br>杯中倒满无情酒<br>眼中再无意中人</p><hr><p>几时归去<br>做个闲人<br>忙时勤努力<br>闲时赏风月<br>逢人不说人间事<br>便是人间无事人<br>若无闲事挂心头<br>便是人间好时节  </p><hr><p>你我暮年<br>闲坐庭院<br>云卷云舒听雨声<br>星密星稀赏月影<br>花开花落忆江南<br>你话往时我话往事<br>愿有岁月可回首<br>且以深情共白头  </p><hr><p>时光总在静中定<br>流水却穿五孔桥<br>年少应虑道中事<br>莫等红尘催白头  </p><hr><p>半山烟雨半生忧<br>一念心轻万事休<br>山后本是清静地<br>怎奈俗人一身愁  </p><hr><p>我本一身傲骨<br>奈何世事无常<br>悲从心中起<br>百般不如人<br>本以为傲从骨中生<br>万难不屈膝<br>可是傲骨又值几分钱<br>最可叹放下了尊严<br>却换不回柴米油盐  </p><hr><p>三十而立<br>人生将半<br>也曾克己奋发<br>胸怀激荡<br>幻想红衣白马<br>气吐眉扬<br>然终是柴米挫了锐气<br>染了风霜  </p><hr><p>半生风雨半生寒<br>一杯浊酒敬流年<br>回首过往半生路<br>七分酸楚三人甜<br>日出东方催人醒<br>不及晚霞懂我情<br>辞别再无相见日<br>终是一人度春秋  </p><hr><p>世事茫茫，光阴有限，算来何必奔忙。<br>人生碌碌，竟短论长，却不道荣枯有数，得失难量。<br>看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。<br>荣华花上露，富贵草上霜。<br>机关参透，万虑皆忘。<br>夸什么龙楼凤阁，说什么利锁名缰。<br>闲来静处，且将诗酒猖狂。</p><hr><p>法不轻传，<br>道不贱卖，<br>师不顺路，<br>医不叩门，<br>千金不传无义子，<br>万财不渡忘恩人，<br>医逢信者但可救，<br>道遇无明枉费心，<br>甘露不润无根草，<br>妙法只渡有缘人。</p><hr><p>不与君子争名，<br>不与小人夺利，<br>不与天地比巧，<br>将军有剑不斩苍蝇，<br>文臣执笔不负苍生。</p><hr><p>终日奔波只为饥<br>方才一饱便思衣<br>衣食两般皆具足<br>又思娇柔美貌妻<br>娶得美妻生下子<br>恨无田地少根基<br>门前买下田千顷<br>又思出门少马骑<br>槽头拴了骡和马<br>又思无官被人欺<br>一品当朝为宰相<br>还想山河夺帝基<br>心满意足为天子<br>又想长生不老期<br>一旦求得长生药<br>再跟上帝论高低</p><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夜听冰河</title>
      <link href="2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/"/>
      <url>2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<p>给自已取了一个新的网名，“夜听冰河”。<br>取自：《十一月四日风雨大作》作者：陆游 作于公元1192年<br>僵卧孤村不自哀，尚思为国戍轮台。<br>夜阑卧听风吹雨，铁马冰河入梦来。<br>夜深了，年近古稀（陆游生于公元1125年，此诗作于1192年，当时作者67岁）的一老翁直挺挺的躺在孤寂荒凉的小乡村里，一边听着外面的风吹着雨，雨又打着风，一边又在想如今虽身处荒野，但这又算得了什么，哪里有值得感到悲哀的，只要我还能再为国家戍守边疆，再出一份力，听着听着，想着想着，竟迷迷糊糊睡着了，仿佛真的回到了边关，骑着披甲的战马，跨过冰封的河流。。。<br>如实说，这首诗读高中时学习过，也理解诗要表达的感情，但是偶然间，脑子里不自主的闪现出，“夜阑卧听风吹雨，铁马冰河入梦来。”，就再次去品味这首诗，竟别有另一番感触。只能说好的诗人，一定是一个感情充沛，精神世界丰富的人；好的诗，一定是最简单的文字里承载着最真挚的感情。无疑，陆游是一个伟大的诗人，他的这首十一月四日风雨大作也是一首不朽的诗。从放翁先生的诗中，感受到了真挚爱国报国之情，也看到一年近七十的老翁，人生失意，壮志未酬，不是追悔，不是抱怨，亦不是叹时光匆匆，却是年老之躯，少年雄心，做梦都在想着能披甲再战，一颗不屈之心，一副铮铮之骨跃然纸上。也许正是先生这不屈之心，铮铮之骨早已烙入我心，才会在某一刻闪现在我的脑海中。<br>诗解析完了，思考却没有停止，为什么后两句突然会跃现于我的脑海里？对于现代社会的人们，确切说是世俗社会的人们来说，一首写于829年前的诗，还有什么意义？<br>澄清一点我这里之所以说是世俗社会的，是因为当前社会世俗规则大行其道，有人可能不解了，什么又是世俗规则呢？简单说：搞钱第一，有钱就代表成功，没有挣到钱就代表失败，金钱第一，也是实力、地位的象征。而我所理解的现代社会，是物质与精神同等重要的社会，人们除了追求更高的物质生活，也漫游于丰富的精神海洋。因商场失败，跳楼自杀；因家产继承，兄弟反目；因一己贪欲，行贿受贿索贿如登大堂。凡此种种，数不胜数。<br>其实这一切的后果，都是可以避免的，但前提是你的精神世界是丰富的、充沛的，无论得意、失意，都能为你点燃一盏灯火，指引你前行。对于身负巨额债务的人来说，如果你听过“海到尽头天作岸，山登绝顶我为峰。如日东山能再起，大鹏展翅恨天低。”，哪还用以寻死求解脱；如果你明白“打虎亲兄弟，上阵父子兵”、“兄弟阋于墙，外御其侮”，家资丰厚或贫瘠，当兄谦弟恭，戮力同心，何愁家道不兴？身居显位，是实力所至，已得人前之贵，如果你懂得，“为天地立心，为生民立命，为往圣继绝学，为万世开太平。”，又何必以蝇蝇之利污洁白之羽，展天之翅。<br>很喜欢，沈复在《浮生六记》中的一段话，送给自己及所有精神世界还很贫瘠的人：世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。<br>多么的洒脱无碍，来去如风呀，只要过得幸福、轻松、自在，何必为多拿两个铜板而机关算尽？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-基本原理及工作流程</title>
      <link href="2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Node 是一个服务器端 JavaScript 解释器，可以方便地搭建出响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型，非常适合在分布式设备上运行数据密集型的实时应用。</p><p>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台，功能完善，它实现了诸如文件系统、模块、包、操作系统 API、网络通信等功能 。</p><h3 id="v8引擎"><a href="#v8引擎" class="headerlink" title="v8引擎"></a>v8引擎</h3><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎，负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；你可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p><h3 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h3><p>Java，PHP等编程语言是面向对象编程，Node是事件驱动编程的思想。<br>事件驱动编程，即为需要处理的事件编写相应的事件处理程序，代码在事件发生时执行，当事件触发时被操作系统唤醒，这样能更加有效地使用cpu。<br>事件驱动模型如图：</p><p><img src="/images/node/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" alt="事件驱动模型"></p><p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p><ul><li><p>事件源：产生事件的地方(html元素)</p></li><li><p>事件：点击/鼠标操作/键盘操作等等</p></li><li><p>事件对象：当某个事件发生时，可能会产生一个事件对象，该事件对象会封装好该事件的信息，传递给事件处理程序</p></li><li><p>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。</p><p>我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">e</span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.alert(<span class="string">&quot;x=&quot;</span>+e.clientX+<span class="string">&quot;y=&quot;</span>+e.clientY); </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span> <span class="attr">onmousedown</span>=<span class="string">&quot;test1(event)&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h3><p>通常应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，而CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务，所以I/O才是应用程序的瓶颈所在；在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。</p><p>《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</p><p><img src="/images/node/node%E6%94%AF%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="node支行流程图"></p><p>Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。</p><p>Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br>在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/xiangzhihong8/article/details/53954600">https://blog.csdn.net/xiangzhihong8/article/details/53954600</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解kafka</title>
      <link href="2021/06/15/%E5%9B%BE%E8%A7%A3kafka/"/>
      <url>2021/06/15/%E5%9B%BE%E8%A7%A3kafka/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。</p><p><img src="/images/kafka/base.jpg" alt="kafka"></p><p>生产者消费者<br>生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7-kafka-%E6%B6%88%E8%B4%B9.jpg" alt="生产-kafka-消费"></p><p>一个服务可以同时为生产者和消费者。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85-kafka.png" alt="生产消费者-kafka"></p><h3 id="Topics-主题"><a href="#Topics-主题" class="headerlink" title="Topics 主题"></a>Topics 主题</h3><p>Topic 是生产者发送消息的目标地址，是消费者的监听目标。</p><p><img src="/images/kafka/kafka-topic.png" alt="kafka-topic"></p><p>一个服务可以监听、发送多个 Topics。</p><p><img src="/images/kafka/%E5%8D%95%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AATopics.png" alt="单个服务监听多个Topics"></p><p>Kafka 中有一个【consumer-group（消费者组）】的概念。</p><p>这是一组服务，扮演一个消费者。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84.png" alt="消费者组"></p><p>如果是消费者组接收消息，Kafka 会把一条消息路由到组中的某一个服务。</p><p><img src="/images/kafka/%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1.png" alt="路由消息到消费者组中的某一个服务"></p><p>这样有助于消息的负载均衡，也方便扩展消费者。</p><p>Topic 扮演一个消息的队列。</p><p>首先，一条消息发送了。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E5%88%B0topic.png" alt="生产消息到topic"></p><p>然后，这条消息被记录和存储在这个队列中，不允许被修改。</p><p><img src="/images/kafka/topic%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9.png" alt="topic中的消息不允许修改"></p><p>接下来，消息会被发送给此 Topic 的消费者。</p><p>但是，这条消息并不会被删除，会继续保留在队列中。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E5%B9%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BC%9A%E7%BB%A7%E7%BB%AD%E4%BF%9D%E7%95%99%E5%9C%A8%E9%98%9F%E5%88%97.png" alt="消息并不会被删除，会继续保留在队列"></p><p>继续发送消息。</p><p><img src="/images/kafka/%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="继续发送消息"></p><p>像之前一样，这条消息会发送给消费者、不允许被改动、一直呆在队列中。</p><p>（消息在队列中能呆多久，可以修改 Kafka 的配置）</p><p><img src="/images/kafka/a.png" alt="a"></p><p><img src="/images/kafka/b.png" alt="b"></p><h3 id="Partitions-分区"><a href="#Partitions-分区" class="headerlink" title="Partitions 分区"></a>Partitions 分区</h3><p>上面 Topic 的描述中，把 Topic 看做了一个队列，实际上，一个 Topic 是由多个队列组成的，被称为【Partition（分区）】。</p><p>这样可以便于 Topic 的扩展。</p><p><img src="/images/kafka/topic-Partitions.png" alt="topic-Partitions"></p><p>生产者发送消息的时候，这条消息会被路由到此 Topic 中的某一个 Partition。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0Topic%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAPartition.png" alt="生产者发送消息到Topic中的某一个Partition"></p><p>消费者监听的是所有分区。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA.png" alt="消费者监听的是所有分区"></p><p>生产者发送消息时，默认是面向 Topic 的，由 Topic 决定放在哪个 Partition，默认使用轮询策略。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%94%B1Topic%E5%86%B3%E5%AE%9A%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AAPartition.png" alt="产者发送消息由Topic决定放在哪个Partition"></p><p>也可以配置 Topic，让同类型的消息都在同一个 Partition。</p><p>例如，处理用户消息，可以让某一个用户所有消息都在一个 Partition。</p><p>例如，用户1发送了3条消息：A、B、C，默认情况下，这3条消息是在不同的 Partition 中（如 P1、P2、P3）。</p><p>在配置之后，可以确保用户1的所有消息都发到同一个分区中（如 P1）。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="消息有序性"></p><p>这个功能有什么用呢？</p><p>这是为了提供消息的【有序性】。</p><p>消息在不同的 Partition 是不能保证有序的，只有一个 Partition 内的消息是有序的。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A72.png" alt="消息有序性2"></p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A73.png" alt="消息有序性3"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Kafka 是集群架构的，ZooKeeper是重要组件。</p><p><img src="/images/kafka/kafka-zookeeper.png" alt="kafka-zookeeper"></p><p>ZooKeeper 管理者所有的 Topic 和 Partition。</p><p>Topic 和 Partition 存储在 Node 物理节点中，ZooKeeper负责维护这些 Node。</p><p><img src="/images/kafka/kafka-zookeeper-znode.png" alt="kafka-zookeeper-znode"></p><p>例如，有2个 Topic，各自有2个 Partition。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B.png" alt="示例.png"></p><p>这是逻辑上的形式，但在 Kafka 集群中的实际存储可能是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B2.png" alt="示例2"></p><p>Topic A 的 Partition #1 有3份，分布在各个 Node 上。</p><p>这样可以增加 Kafka 的可靠性和系统弹性。</p><p>3个 Partition #1 中，ZooKeeper 会指定一个 Leader，负责接收生产者发来的消息。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B3.png" alt="示例3"></p><p>其他2个 Partition #1 会作为 Follower，Leader 接收到的消息会复制给 Follower。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B4.png" alt="示例4"></p><p>这样，每个 Partition 都含有了全量消息数据。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B5.png" alt="示例5"></p><p>即使某个 Node 节点出现了故障，也不用担心消息的损坏。</p><p>Topic A 和 Topic B 的所有 Partition 分布可能就是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B6.png" alt="示例6"></p><blockquote><p>原文<br>-<a href="https://blog.csdn.net/duysh/article/details/116355977">https://blog.csdn.net/duysh/article/details/116355977</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单生活，努力工作，爱自己爱家人</title>
      <link href="2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/"/>
      <url>2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>静心平想，其实我是一个很幸运的人，我挺知足。</p><p>上学时代，激情满怀，却资质平庸，成绩上并无亮点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。我不想一下就耗尽自己的力气，同时也没有来得及去享受加油和呐喊助威。我希望我拼得不是速度，而是耐力。也许我跑的不是最快，不是第一，但是每坚实的跑出一步，都是我对的人生发于心的热爱，我会记住沿途的每一张笑脸和每一个从身边的奔跑过的人。</p><p>最近躺平、内卷，这两个词挺热的，了解完躺平、内卷，我简直下巴要掉到地上了，虽然现在生活好了，同时压力更大了，竞争更激烈，但是通过这种方式来对表达自己的反抗，太愚蠢了。也许目标看似遥不可及，如果躺下了，真就不可及了。</p><p>聪明的人善于计算，以现在的能力再怎么努力，也买不起房子、谈不起恋爱、结不起婚、生得起养不起孩子、上不起医院看不起病……，我感觉这些计算都是错的，这让我想起一个成语故事：刻舟求剑；社会在发展，经济在发展，人也在发展，发展就是变化，既然一切都是在变化中，为什么要用现在来计算未来，这哪是聪明，简直愚蠢；人类已经登上了月球，以后也许还会上火星，以后的以后还有更多的未知和惊喜</p><p>停止焦虑对你的束缚吧，世界上没有一种精密的模型可以计算未来，计算人的潜力，计算人的决心。<br>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，万事可成<br>拾起这好时光，决心让自己变简单，让生活变简单，努力爱自己、家人和工作。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo-spring-原理</title>
      <link href="2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：</p><ul><li>添加dubbo-spring-boot-starter依赖</li><li>定义@org.apache.dubbo.config.annotation.Service注解</li></ul><p>声明@DubboComponentScan，用于扫描@Service注解，Dubbo中的@Service注解和Spring中提供的@Service注解功能类似，用于实现Dubbo服务的暴露，与它相对应的时@Reference，它的作用类似于Spring中的@Autowired注解。而@DubboComponentScan和Spring中的@ComponentScan作用类似，用于扫描@Service、@Reference等注解。</p><h3 id="DubboComponentScan注解解析"><a href="#DubboComponentScan注解解析" class="headerlink" title="@DubboComponentScan注解解析"></a>@DubboComponentScan注解解析</h3><p><strong>DubboComponentScan</strong>注解的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解主要通过@Import导入一个DubboComponentScanRegistrar类。DubboComponentScanRegistrar实现了ImportBeanDefinitionRegistrar接口，并且重写了registerBeanDefinitions方法。在registerBeanDefinitions方法中主要做了以下几件事：</p><ul><li>获取扫描包的路径，默认扫描当前配置类所在的包</li><li>注册@Service注解的解析类</li><li>注册@Reference注解的解析类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refisterBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportBeanDefinitionRegistrar是Spring提供的一种动态注入Bean的机制，和ImportSelector接口的功能类似，在refisterBeanDefinitions方法中，主要会实例化一些BeanDefinition并且注入到Spring IoC容器中；继续看registerServiceAnnotationBeanPostProcessor()方法，逻辑比较简单，就是把SerficeAnnotationBeanPostProcessor注册到容器；registerReferenceAnnotationBeanPostProcessor()方法是把ReferenceAnnotationBeanPostProcessor注册到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构建BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(<span class="number">2</span>);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 把BeanDefinition注册到IoC容器中</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Service解析"><a href="#Service解析" class="headerlink" title="@Service解析"></a>@Service解析</h3><p>ServiceAnnotationBeanPostProcessor用于解析@Service注解，ReferenceAnnotationBeanPostProcessor用于解析@Reference注解</p><h3 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h3><p>ServiceAnnotationBeanPostProcessor类的定义如下，它的核心逻辑就是解析@Service注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor实现了4个接口，EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware这三个接口比较好理解，重点看一下BeanDefinitionRegistryPostProcessor；BeanDefinitionRegistryPostProcessor接口继承自BeanFactoryPostProcessor，是一种比较特殊的BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor中的postProcessBeanDefinitionRegistry方法可以让我们实现自定义的注册Bean定义的逻辑。该方法主要做了以下几件事：</p><ul><li>调用registerBeans注册DubboBootstrapApplicationListener类</li><li>通过resolvePackagesToScan对packagesToScan参数进行去空格处理，并把配置文件中配置的扫描参数也一起处理。</li><li>调用registerServiceBeans完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, <span class="keyword">new</span> Class[]&#123;DubboBootstrapApplicationListener.class&#125;);</span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = <span class="keyword">this</span>.resolvePackagesToScan(<span class="keyword">this</span>.packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">&quot;packagesToScan is empty , ServiceBean registry will be ignored!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postProcessBeanDefinitionRegistry()方法的核心逻辑都在registerServiceBeans这个方法中，这个方法会查找需要扫描的指定包里面有@Service注解的类并将其注册成Bean。</p><ul><li>定义DubboClassPathBeanDefinitionScanner扫描对象，扫描指定路径下的类，将符合条件的类装配到IoC容器中。</li><li>BeanNameGenerator是Beans体系中比较重要的一个组件，会通过一定的算法计算出需要装配的Bean的name。</li><li>addIncludeFilter设置Scan的过滤条件，只扫描@Service注解修饰的类。</li><li>遍历指定的包，通过findServiceBeanDefinitionHolders查找@Service注解修饰的类。</li><li>通过registerServiceBean完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan The base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">                <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">            scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                    registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(beanDefinitionHolders.size() + <span class="string">&quot; annotated Dubbo&#x27;s @Service Components &#123; &quot;</span> +</span><br><span class="line">                            beanDefinitionHolders +</span><br><span class="line">                            <span class="string">&quot; &#125; were scanned under package[&quot;</span> + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span></span><br><span class="line">                            + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码主要作用就是通过扫描指定路径下添加了@Service注解的类，通过registerServiceBean来注册ServiceBean，整体来看，Dubbo的注解扫描进行服务发布的过程，实际上就是基于Spring的扩展。</p><p>继续分析registerServiceBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">     Service service = findAnnotation(beanClass, Service.class);</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">     String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">     AbstractBeanDefinition serviceBeanDefinition =</span><br><span class="line">             buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ServiceBean Bean name</span></span><br><span class="line">     String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; <span class="comment">// check duplicated candidate bean</span></span><br><span class="line">         registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">&quot;The BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean has been registered with name : &quot;</span> + beanName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">             logger.warn(<span class="string">&quot;The Duplicated BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean[ bean name : &quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;] was be found , Did @DubboComponentScan scan to same package in many times?&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resolveClass获取BeanDefinitionHolder中的Bean</li><li>findServiceAnnotation方法从beanClass类中找到@Service注解</li><li>getAnnotationAttributes方法获得注解中的属性，比如loadBalance、cluster等。</li><li>resolveServiceInterfaceClass方法用于获得beanClass对应的接口定义，其实在@Service(interfaceClass=xxxx.class)注解的声明中也可以声明interfaceClass，注解中声明的优先级最高，如果没有声明该属性，则会从父类中查找。</li><li>annotatedServiceBeanName代表Bean的名称。</li><li>buildServiceBeanDefinition用来构造org.apache.dubbo.config.spring.ServiceBean对象，每个Dubbo服务的发布最终都会出现一个ServiceBean。</li><li>调用registerBeanDefinition将ServiceBean注入Spring IoC容器中。</li></ul><p>从整个方法的分析来看，registerServiceBean方法主要是把一个ServiceBean注入到Spring IoC容器中，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不是像普通的Bean注入一样直接将HelloServiceImpl对象的实例注入容器，而是注入一个ServiceBean对象。对于HelloServiceImpl来说，它并不需要把自己注入Spring IoC容器中，而是需要把自己发布到网络上，提供给网络上的服务消费者来访问。那它是怎么发布到网络上的呢？</p><p>上面在postProcessBeanDefinitionRegistry方法中注册了DubboBootstrapApplicationListener事件监听Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrapApplicationListener</span> <span class="keyword">extends</span> <span class="title">OneTimeExecutionApplicationContextEventListener</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DubboBootstrap dubboBootstrap = DubboBootstrap.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrapApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextRefreshedEvent((ContextRefreshedEvent)event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextClosedEvent((ContextClosedEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的Bean都处理完成之后，Spring IoC会发布一个事件，事件类型为ComtextRefreshedEvent，当触发整个事件时，会调用onContextRefreshedEvent方法。在这个方法中，可以看到Dubbo服务启动的触发机制dubboBootstrap.start()。从这个方法中会进入org.apache.dubbo.config.ServiceConfig类中的export()方法，这个方法会启动一个网络监听，从而实现服务发布。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/yangbaggio/article/details/105913431">https://blog.csdn.net/yangbaggio/article/details/105913431</a></p><p><a href="https://blog.csdn.net/DaySurprise/article/details/114897735">https://blog.csdn.net/DaySurprise/article/details/114897735</a></p><p><a href="https://www.cnblogs.com/jackion5/p/11219707.html">https://www.cnblogs.com/jackion5/p/11219707.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Springboot </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo-原理</title>
      <link href="2021/05/27/dubbo-%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/27/dubbo-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="dubbo基础"><a href="#dubbo基础" class="headerlink" title="dubbo基础"></a>dubbo基础</h2><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。</p><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架Dubbo就出现了</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul><li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li><li>软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><strong>核心组件</strong></h4><ul><li><p>Provider：暴露服务的服务提供方</p></li><li><p>Consumer：调用远程服务消费方</p></li><li><p>Registry：服务注册与发现注册中心</p></li><li><p>Monitor：监控中心和访问调用统计</p></li><li><p>Container：服务运行容器</p><p><strong>注册中心</strong></p><p>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</p></li></ul><p><img src="/images/dubbo/Dubbo%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="Dubbo核心组件"></p><h4 id="服务注册与发现流程"><a href="#服务注册与发现流程" class="headerlink" title="服务注册与发现流程"></a><strong>服务注册与发现流程</strong></h4><ul><li>服务容器Container负责启动，加载，运行服务提供者。</li><li>服务提供者Provider在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</p><ul><li>接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</li><li>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li><li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</li><li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li><li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</li><li>远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li><li>网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li><li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</li></ul><p><img src="/images/dubbo/Dubbo%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="dubbo架构设计图"></p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>服务器端（服务提供者） 在框架启动时， 会初始化服务实例， 通过Proxy组件调<br>用具体协议（Protocol ） ,把服务端要暴露的接口封装成Invoker （真实类型是<br>AbstractProxylnvoker）,然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例<br>到内存中， 最后通过Registry把服务元数据注册到注册中心和本地。   </p><p>Proxy组件： Dubbo框架生成的代理类， 调用的方法其实是Proxy组件生成的代理方法， 会自动发起远程/本地调用， 并返回结果,<br>整个过程对用户完全透明。</p><p> Protocol： 协议就是对数据格式的一种约定。 它可以把我们对接口的配置,<br>根据不同的协议转换成不同的Invoker对象。 例如： 用DubboProtocol可以把XML文<br>件中一个远程接口的配置转换成一个Dubbolnvoker</p><p>Exporter： 用于暴露到注册中心的对象， 它的内部属性持有了 Invoker对象， 我们可以<br>认为它在Invoker上包了 一层。</p><p>Registry： 把Exporter注册到注册中心  </p><h4 id="服务调用过程"><a href="#服务调用过程" class="headerlink" title="服务调用过程"></a>服务调用过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>调用过程也是从一个Proxy开始的， Proxy持有了一个Invoker对象。 然后触发invoke<br>调用。 在invoke调用过程中， 需要使用Cluster, Cluster负责容错， 如调用失败的重试。 Cluster<br>在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表（一个接口可能有多个<br>节点提供服务） 。 由于可以调用的远程服务有很多， 此时如果用户配置了路由规则（如指定某些<br>方法只能调用某个节点） ， 那么还会根据路由规则将Invoker列表过滤一遍。<br>然后， 存活下来的Invoker可能还会有很多，于是会继续通过<br>LoadBalance方法做负载均衡， 最终选出一个可以调用的Invokero这个Invoker在调用之前又会<br>经过一个过滤器链， 这个过滤器链通常是处理上下文、 限流、 计数等。<br>接着， 会使用Client做数据传输， 如我们常见的Netty Client等。 传输之前肯定要做一些私<br>有协议的构造， 此时就会用到Codec接口。 构造完成后， 就对数据包做序列化（Serialization）,<br>然后传输到服务提供者端。 服务提供者收到数据包， 也会使用Codec处理协议头及一些半包、<br>粘包等。 处理完成后再对完整的数据报文做反序列化处理。<br>随后， 这个Request会被分配到线程池（ThreadPool）中进行处理。Server会处理这些Request,<br>根据请求查找对应的Exporter （它内部持有了 Invoker）。 Invoker是被用装饰器模式一层一层套<br>了非常多Filter的， 因此在调用最终的实现类之前， 又会经过一个服务提供者端的过滤器链。<br>最终， 我们得到了具体接口的真实实现并调用， 再原路把结果返回。<br>至此， 一个完整的远程调用过程就结束了。 </p><h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>SPI，Service Provider Interface，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader</p><p> Dubbo 并未使用Java SPI，而是重新实现了一套功能更强的SPI机制。Dubbo SPI的相关逻辑被封装在了ExtensionLoader类中，通过ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI所需的配置文件，需放置在META-INF/dubbo路径下</p><p>与Java SPI实现类配置不同，Dubbo SPI是通过键值对的方式进行配置。这样我们可以按需加载指定的实现类。另外在测试Dubbo SPI时，需要在Robot接口上标注@SPI注解 </p><h4 id="monitor原理"><a href="#monitor原理" class="headerlink" title="monitor原理"></a>monitor原理</h4><ul><li>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。</li></ul><ol><li>MonitorFilter 向 DubboMonitor 发送数据</li><li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference</li><li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大写为 100000）</li><li>SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以死循环的形式来写）</li><li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</li></ol><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>默认：Random LoadBalance:</p><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><h4 id="集群容错机制"><a href="#集群容错机制" class="headerlink" title="集群容错机制"></a>集群容错机制</h4><p>默认：Failover Cluster</p><ul><li>Failover </li></ul><p>当出现失败时， 会重试其他服务器。 用户可以通过retries=”2n设置重试次数。 这是<br>Dubbo的默认容错机制， 会对请求做负载均衡。 通常使用在读操作或幕等的写操作上，<br>但重试会导致接口的延退增大， 在下游机器负载已经达到极限时， 重试容易加重下游<br>服务的负载</p><ul><li>Failfast</li></ul><p> 快速失败， 当请求失败后， 快速返回异常结果， 不做任何重试。 该容错机制会对请求<br>做负载均衡， 通常使用在非幕等接口的调用上。 该机制受网络抖动的影响较大</p><ul><li>Failsafe</li></ul><p> 当出现异常时， 直接忽略异常。 会对请求做负载均衡。 通常使用在“佛系” 调用场景，<br>即不关心调用是否成功， 并且不想抛异常影响外层调用， 如某些不重要的日志同步， 即使出现异常也无所谓</p><ul><li>Fallback</li></ul><p> 请求失败后， 会自动记录在失败队列中， 并由一个定时线程池定时重试， 适用于一些<br>异步或最终一致性的请求。 请求会做负载均衡</p><ul><li>Forking</li></ul><p> 同时调用多个相同的服务， 只要其中一个返回， 则立即返回结果。 用户可以配置forks=“最大并行调用数” 参数来确定最大并行调用的服务数量。 通常使用在对接口<br>实时性要求极高的调用上， 但也会浪费更多的资源</p><ul><li>Broadcast </li></ul><p>广播调用所有可用的服务， 任意一个节点报错则报错。 由于是广播， 因此请求不需要<br>做负载均衡。 通常用于服务状态更新后的广播</p><ul><li>Mock</li></ul><p> 提供调用失败时， 返回伪造的响应结果。 或直接强制返回伪造的结果， 不会发起远程<br>调用</p><ul><li>Available </li></ul><p>最简单的方式， 请求不会做负载均衡， 遍历所有服务列表， 找到第一个可用的节点，<br>直接请求并返回结果。 如果没有可用的节点， 则直接抛出异常</p><ul><li>Mergeable </li></ul><p>Mergeable可以自动把多个节点请求得到的结果进行合并</p><h4 id="调用超时设置"><a href="#调用超时设置" class="headerlink" title="调用超时设置"></a>调用超时设置</h4><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><ul><li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>Dubbo注册中心集群挂掉之后，消费者和生产者之间可以继续通信；因为在Dubbo启动时，消费者会从注册中心Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地，每次调用时，按照本地缓存的地址调用就可以。</p><p>默认使用 Netty 作为通讯框架。</p><p>支持的通信协议：</p><ul><li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</li><li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li><li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li><li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li><li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li><li>Memcache：基于 Memcache实现的 RPC 协议。</li><li>Redis：基于 Redis 实现的RPC协议。</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>为保证在远程调用过程中对象的完整性和可传递性，服务消费者和服务提供者之间传递数据的时候需要进行序列化和反序列化，默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><p>序列化：把对象转换成有序的二进制字节流，以便在网络上传输或者保存在本地文件中</p><p>反序列化：把序列化后的对象的二进制字节流通过反序列化重建对象。</p><h4 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h4><ul><li>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</li><li>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</li></ul><h3 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h3><ul><li><p>工厂模式</p></li><li><p>装饰器模式</p></li><li><p>观察者模式</p></li><li><p>动态代理模式</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="版本兼容性问题"><a href="#版本兼容性问题" class="headerlink" title="版本兼容性问题"></a>版本兼容性问题</h4><p>可以用版本号（version）解决兼容性问题，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用</p><h4 id="与SpringCloud关系"><a href="#与SpringCloud关系" class="headerlink" title="与SpringCloud关系"></a>与SpringCloud关系</h4><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p><h4 id="与SpringCloud区别"><a href="#与SpringCloud区别" class="headerlink" title="与SpringCloud区别"></a>与SpringCloud区别</h4><ul><li><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p></li><li><p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p></li></ul><h4 id="与Dubbox的区别"><a href="#与Dubbox的区别" class="headerlink" title="与Dubbox的区别"></a>与Dubbox的区别</h4><ul><li>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</li></ul><blockquote><p>引用<br><a href="https://juejin.cn/post/6844904127076499463">https://juejin.cn/post/6844904127076499463</a><br><a href="https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA">https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-线程模型</title>
      <link href="2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p> redis是单线程模型，所谓单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块该使用多线程仍会使用了多个线程。redis是基于内存的，那么<code>CPU</code>不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。</p><p><code>Redis</code>基于<code>Reactor</code>模式开发了自己的网络事件处理器，称之为文件事件处理器(<code>File Event Hanlder</code>)。文件事件处理器由<code>Socket</code>、<code>IO</code>多路复用程序、文件事件分派器(<code>dispather</code>)，事件处理器(<code>handler</code>)四部分组成。文件事件处理器的模型如下所示：</p><p><img src="/images/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="redis线程模型图"></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p><code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。<code>IO</code>多路复用程序会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，文件事件分派器接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的事件处理器进行处理。</p><h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><ul><li><p>AE_READABLE</p><p>当客户端连接服务器端时，服务器端会将连接应答处理器与<code>socket</code>的<code>AE_READABLE</code>事件关联起来；</p><p>当客户端向服务端发送命令的时候，服务器端将命令请求处理器与<code>AE_READABLE</code>事件关联起来；</p></li><li><p>AE_WRITABLE</p><p>当服务端有数据需要回传给客户端时，服务端将命令回复处理器与<code>socket</code>的<code>AE_WRITABLE</code>事件关联起来。</p></li></ul><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul><li><strong>连接应答处理器</strong>：用于处理客户端的连接请求；</li><li><strong>命令请求处理器</strong>：用于执行客户端传递过来的命令；</li><li><strong>命令回复处理器</strong>：用于返回客户端命令的执行结果；</li></ul><h3 id="客户端与服务端交互"><a href="#客户端与服务端交互" class="headerlink" title="客户端与服务端交互"></a>客户端与服务端交互</h3><p><img src="/images/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" alt="redis客户端与服务端交互流程"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>I/O多路复用本来就是用来解决对多个I/O监听时，一个I/O阻塞影响其他I/O的问题</p><blockquote><p>引用<br><a href="https://juejin.cn/post/6844903849489235982">https://juejin.cn/post/6844903849489235982</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> redis </tag>
            
            <tag> 线程模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-集群</title>
      <link href="2021/05/26/redis-%E9%9B%86%E7%BE%A4/"/>
      <url>2021/05/26/redis-%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>Redis Cluster是Redis官方提供的Redis集群功能，分布式架构，去中心化，即Redis Cluster中有多个节点，每个节点都负责进行数据读写操作，每个节点之间通过一种特殊的二进制 协议相互交互集群信息进行通信。Redis Cluster 将所有数据划分为 16384 的 slots，，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中， 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信 息。这样当客户端要查找某个 key 时，可以直接定位到目标节点。  另外，RedisCluster 的每个节点会将集群的配置信息持久化到配置文件中，所以 必须确保配置文件是可写的，而且尽量不要依靠人工修改配置文件。</p><p><img src="/images/redis/redis-cluster-%E6%9E%B6%E6%9E%84.png" alt="redis-cluster-架构"></p><p>跳转：当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并 不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点 地址，告诉客户端去连这个节点去获取数据。客户端收到 MOVED 指令后，要立即纠正本地的槽位映射表。后续所有 key 将 使用新的槽位映射表。</p><p>容错：Redis Cluster 可以为每个主节点设置若干个从节点，单主节点故障时，集群会 自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当它发 生故障时，集群将完全处于不可用状态。不过 Redis 也提供了一个参数 cluster-require-full-coverage 可以允许部分节点故障，其它节点还可以继续 提供对外访问。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="哨兵模式"></p><p>More Actions我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用 的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。 它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点 切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来 查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时， 客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户 端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉 后，集群将可能自动调整为下图所示结构。</p><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE%E5%90%8E.png" alt="哨兵模式重新选举后"></p><p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏 的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点 建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经 挂掉了主节点，待它恢复后，原主节点成为新的主节点的从节点；</p><blockquote><p>引用：<br><a href="https://www.jianshu.com/p/813a79ddf932">https://www.jianshu.com/p/813a79ddf932</a><br>《Redis 深度历险：核心原理与应用实践》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-基础理论</title>
      <link href="2021/05/25/redis-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>2021/05/25/redis-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li></ul><ul><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li></ul><ul><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li></ul><ul><li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li></ul><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li></ul><ul><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li></ul><ul><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li></ul><ul><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h4 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a><strong>Redis为什么这么快</strong></h4><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li><li>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路 I/O 复用模型，非阻塞 IO；</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a><strong>Redis有哪些数据类型</strong></h4><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作<br/>对整数和浮点数执行自增或者自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素<br/>对单个或者多个元素进行修剪，<br/>只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素<br/>检查一个元素是否存在于集合中<br/>计算交集、并集、差集<br/>从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对<br/>获取所有键值对<br/>检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素<br/>根据分值范围或者成员来获取元素<br/>计算一个键的排名</td><td>去重但可以排序，如获取排名前几名的用户</td></tr></tbody></table><h4 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h4><p><strong>计数器</strong></p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><p><strong>缓存</strong></p><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p><strong>会话缓存</strong></p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p><strong>全页缓存（FPC）</strong></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>查找表</strong></p><p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><p><strong>消息队列(发布/订阅功能)</strong></p><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><p><strong>分布式锁实现</strong></p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><p><strong>其它</strong></p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p><strong>详情</strong>：<a href="https://gaoxing27.github.io/2021/05/19/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">redis-线程模型</a></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><p>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB（Redis DataBase）是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p><strong>优点：</strong></p><p>1、只有一个文件 dump.rdb，方便持久化。</p><p>2、容灾性好，一个文件可以保存到安全的磁盘。</p><p>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p><p>4.相对于数据集大时，比 AOF 的启动效率更高。</p><p><strong>缺点：</strong></p><p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件，当重启Redis会重新将持久化的日志中文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p><p><strong>优点：</strong></p><p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p><p><strong>缺点：</strong></p><p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>2、数据集大的时候，比 rdb 启动效率低。</p><h4 id="持久化方式选择"><a href="#持久化方式选择" class="headerlink" title="持久化方式选择"></a><strong>持久化方式选择</strong></h4><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p><p>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</p><p>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ul><li><p><strong>定时过期：</strong>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p></li><li><p><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p></li><li><p><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)<br>Redis中同时使用了惰性过期和定期过期两种过期策略。</p></li></ul><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。MySQL里有2000w数据，redis中只存20w的数据，redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，淘汰后的数据就是热点数据。</p><p><strong>全局的键空间选择性移除</strong></p><ul><li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul><ul><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li></ul><ul><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li></ul><p><strong>设置过期时间的键空间选择性移除</strong></p><ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li></ul><ul><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li></ul><ul><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><h3 id="线程模型-1"><a href="#线程模型-1" class="headerlink" title="线程模型"></a>线程模型</h3><p><strong><a href="https://gaoxing27.gitee.io/2021/05/19/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">传送门</a></strong></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务提供了一种将多个命令打包，然后一次性、按顺序地执行的机制，并且事务在执行的期间不会主动中断——服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令 。</p><p><strong>Redis事务的三个阶段</strong></p><ol><li>事务开始 MULTI</li><li>命令入队</li><li>事务执行 EXEC</li></ol><p>注：如果在一个事务中的命令出现错误，那么所有的命令都不会执行；<br>如果在一个事务运行中出现运行错误，那么正确的命令会被执行 ；在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的安全性。<br>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。 </p><h3 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h3><p>详情：<a href="https://gaoxing27.github.io/2021/05/19/redis-%E9%9B%86%E7%BE%A4/">redis-集群</a></p><h4 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h4><p>Redis Cluster是Redis官方提供的Redis集群功能，分布式架构，去中心化，即Redis Cluster中有多个节点，每个节点都负责进行数据读写操作，每个节点之间通过一种特殊的二进制协议相互交互集群信息进行通信。Redis Cluster 将所有数据划分为 16384 的 slots，，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中， 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息。这样当客户端要查找某个 key 时，可以直接定位到目标节点。  另外，RedisCluster 的每个节点会将集群的配置信息持久化到配置文件中，所以必须确保配置文件是可写的，而且尽量不要依靠人工修改配置文件。</p><p><img src="/images/redis/redis-cluster-%E6%9E%B6%E6%9E%84.png" alt="redis-cluster-架构"></p><p>跳转：当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到 MOVED 指令后，要立即纠正本地的槽位映射表。后续所有 key 将 使用新的槽位映射表。</p><p>容错：Redis Cluster 可以为每个主节点设置若干个从节点，单主节点故障时，集群会自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当它发 生故障时，集群将完全处于不可用状态。不过 Redis 也提供了一个参数 cluster-require-full-coverage 可以允许部分节点故障，其它节点还可以继续 提供对外访问。</p><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="哨兵模式"></p><p>可以将 Redis Sentinel集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。 它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点 切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来 查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时， 客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户 端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉 后，集群将可能自动调整为下图所示结构。</p><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE%E5%90%8E.png" alt="哨兵模式重新选举后"></p><p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏 的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点 建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经 挂掉了主节点，待它恢复后，原主节点成为新的主节点的从节点；</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>详情：<a href="https://gaoxing27.github.io/2021/04/05/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">redis-分布式锁</a></strong></p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方案</p><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。<br>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决方案</p><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击<br>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力<br>附加</p><p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap： 典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p><strong>布隆过滤器（推荐）</strong></p><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案</p><p>设置热点数据永远不过期。<br>加互斥锁，互斥锁</p><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决方案</p><p>直接写个缓存刷新页面，上线时手工操作一下；</p><p>数据量不大，可以在项目启动的时候自动进行加载；</p><p>定时刷新缓存；</p><h4 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h4><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p><h4 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h4><p>热点数据，缓存才有价值</p><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p><p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p><p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p><p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p><h4 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h4><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p>解决方案</p><p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p><h4 id="双写不一致"><a href="#双写不一致" class="headerlink" title="双写不一致"></a>双写不一致</h4><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。</p><table><thead><tr><th>问题场景</th><th>描述</th><th>解决</th></tr></thead><tbody><tr><td>先写缓存，再写数据库，缓存写成功，数据库写失败</td><td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td><td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td></tr><tr><td>先写数据库，再写缓存，数据库写成功，缓存写失败</td><td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td><td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td></tr><tr><td>需要缓存异步刷新</td><td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td><td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td></tr></tbody></table><blockquote><p>引用</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/103522351">https://blog.csdn.net/ThinkWon/article/details/103522351</a><br><a href="https://www.jianshu.com/p/813a79ddf932">https://www.jianshu.com/p/813a79ddf932</a></p><p>《Redis 深度历险：核心原理与应用实践》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-分布式锁</title>
      <link href="2021/05/24/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2021/05/24/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>想让同一时刻只有一个线程在执行某段代码，或者说控制资源在同一时刻只能被一个线程持有并操作，这个时候需要锁。以淘宝双11为例，在0点这一刻，如果有几十万甚至上百万的人同时去查看某个商品的详情，这时候会触发商品的查询，如果我们不做控制，全部走到数据库去，那是有可能直接将数据库打垮的。这个时候一个比较常用的做法就是进行加锁，只让1个线程去查询，其他线程待等待这个线程的查询结果后，直接拿结果。在这个例子中，锁用于控制访问数据库的流量，最终起到了保护系统的作用。</p><p>再举个例子，某平台做活动“秒杀茅台”，假如活动只秒杀1瓶，但是同时有10万人在同一时刻去抢，如果底层不做控制，有10000个人抢到了，额外的9999瓶平台就要自己想办法解决了。此时，我们可以在底层通过加锁或者隐式加锁的方式来解决这个问题。此外，锁也经常用来解决并发下的数据安全方面的问题，这里就不一一举例了。</p><p>分布式锁是锁的一种，JVM 锁，如synchronized、Lock，只能作用于单个 JVM，可以简单理解为就是单台服务器（容器），而对于多台服务器之间，JVM 锁则没法解决，这时候就需要引入分布式锁。常见实现分布式锁的方式有：Redis、Zookeeper。</p><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><h4 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h4><p>加锁通常使用 set 命令来实现，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value PX milliseconds NX</span><br></pre></td></tr></table></figure><p>几个参数的意义如下：</p><p>key、value：键值对</p><p>PX milliseconds：设置键的过期时间为 milliseconds 毫秒。</p><p>NX：只在键不存在时，才对键进行设置操作。SET key value NX 效果等同于 SETNX key value。</p><p>PX、expireTime 参数则是用于解决没有解锁导致的死锁问题。因为如果没有过期时间，万一程序员写的代码有 bug 导致没有解锁操作，则就出现了死锁，因此该参数起到了一个“兜底”的作用。</p><p>NX 参数用于保证在多个线程并发 set 下，只会有1个线程成功，起到了锁的“唯一”性。</p><p>解锁需要两步操作：</p><ol><li>查询当前“锁”是否还是我们持有，因为存在过期时间，所以可能等你想解锁的时候，“锁”已经到期，然后被其他线程获取了，所以我们在解锁前需要先判断自己是否还持有“锁”</li><li>如果“锁”还是我们持有，则执行解锁操作，也就是删除该键值对，并返回成功；否则，直接返回失败。</li></ol><p>由于当前 Redis 还没有原子命令直接支持这两步操作，所以当前通常是使用 Lua 脚本来执行解锁操作，Redis 会保证脚本里的内容执行是一个原子操作。</p><p>脚本代码如下，逻辑比较简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>两个参数的意义如下：</p><p>KEYS[1]：我们要解锁的 key</p><p>ARGV[1]：我们加锁时的 value，用于判断当“锁”是否还是我们持有，如果被其他线程持有了，value 就会发生变化。</p><p>上述方法是 Redis 当前实现分布式锁的主流方法，但是有一个问题，<strong>Redis 分布式锁过期了，还没处理完怎么办？</strong></p><p>首先，我们在设置过期时间时要结合业务场景去考虑，尽量设置一个比较合理的值，就是理论上正常处理的话，在这个过期时间内是一定能处理完毕的。之后，我们再来考虑对这个问题进行兜底设计。</p><p>关于这个问题，目前常见的解决方法有两种：</p><p>1、守护线程“续命”：额外起一个线程，定期检查线程是否还持有锁，如果有则延长过期时间。Redisson 里面就实现了这个方案，使用“看门狗”定期检查（每1/3的锁时间检查1次），如果线程还持有锁，则刷新过期时间。</p><p>2、超时回滚：当我们解锁时发现锁已经被其他线程获取了，说明此时我们执行的操作已经是“不安全”的了，此时需要进行回滚，并返回失败。同时，需要进行告警，人为介入验证数据的正确性，然后找出超时原因，是否需要对超时时间进行优化等等。</p><p>Redisson 使用看门狗（守护线程）“续命”的方案在大多数场景下是挺不错的，也被广泛应用于生产环境，但是在极端情况下还是会存在问题。</p><p>问题例子如下：</p><p>1、线程1首先获取锁成功，将键值对写入 redis 的 master 节点</p><p>2、在 redis 将该键值对同步到 slave 节点之前，master 发生了故障</p><p>3、redis 触发故障转移，其中一个 slave 升级为新的 master</p><p>4、此时新的 master 并不包含线程1写入的键值对，因此线程2尝试获取锁也可以成功拿到锁</p><p>5、此时相当于有两个线程获取到了锁，可能会导致各种预期之外的情况发生，例如最常见的脏数据</p><p>解决方法：上述问题的根本原因主要是由于 redis 异步复制带来的数据不一致问题导致的，因此解决的方向就是保证数据的一致。</p><p>当前比较主流的解法和思路有两种：</p><p>1）Redis 作者提出的 RedLock；</p><p>2）Zookeeper 实现的分布式锁。</p><p>接下来介绍下这两种方案。</p><h4 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a><strong>RedLock</strong></h4><p>首先，该方案也是基于文章开头的那个方案（set加锁、lua脚本解锁）进行改良的，所以 antirez 只描述了差异的地方，大致方案如下：假设我们有 N 个 Redis 主节点，例如 N = 5，这些节点是完全独立的，我们不使用复制或任何其他隐式协调系统，为了取到锁，客户端应该执行以下操作:</p><ol><li>获取当前时间，以毫秒为单位</li><li>依次尝试从5个实例，使用相同的 key 和随机值（例如UUID）获取锁。当向Redis 请求获取锁时，客户端应该设置一个超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在 5-50 毫秒之间。这样可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态。如果一个实例不可用，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</li><li>客户端通过当前时间减去步骤1记录的时间来计算获取锁使用的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且获取锁使用的时间小于锁失效时间时，锁才算获取成功。</li><li>如果取到了锁，其有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）</li><li>如果由于某些原因未能获得锁（无法在至少N/2+1个Redis实例获取锁、或获取锁的时间超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li></ol><p>可以看出，该方案为了解决数据不一致的问题，直接舍弃了异步复制，只使用 master 节点，同时由于舍弃了 slave，为了保证可用性，引入了 N 个节点，官方建议是 5。</p><p>该方案看着挺美好的，但是实际上我所了解到的在实际生产上应用的不多，主要有两个原因：</p><ul><li>该方案的成本似乎有点高，需要使用5个实例；</li></ul><ul><li>该方案一样存在问题。</li></ul><p>该方案主要存以下问题：</p><ul><li>严重依赖系统时钟。如果线程1从3个实例获取到了锁，但是这3个实例中的某个实例的系统时间走的稍微快一点，则它持有的锁会提前过期被释放，当他释放后，此时又有3个实例是空闲的，则线程2也可以获取到锁，则可能出现两个线程同时持有锁了。</li></ul><ul><li>如果线程1从3个实例获取到了锁，但是万一其中有1台重启了，则此时又有3个实例是空闲的，则线程2也可以获取到锁，此时又出现两个线程同时持有锁了。</li></ul><h3 id="Zookeeper-实现分布式锁"><a href="#Zookeeper-实现分布式锁" class="headerlink" title="Zookeeper 实现分布式锁"></a><strong>Zookeeper 实现分布式锁</strong></h3><p><strong>zookeeper的特性</strong></p><ul><li>有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“<code>/lock/node-</code>”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为<code>/lock/node-0000000000</code>，下一个节点则为<code>/lock/node-0000000001</code>，依次类推。</li><li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</li><li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：<br>1.节点创建；<br>2.节点删除；<br>3.节点数据修改；<br>4.子节点变更。</li></ul><p>Zookeeper 的分布式锁实现方案如下：</p><p>1、创建一个锁目录 /locks，该节点为持久节点</p><p>2、想要获取锁的线程都在锁目录下创建一个临时顺序节点</p><p>3、获取锁目录下所有子节点，对子节点按节点自增序号从小到大排序</p><p>4、判断本节点是不是第一个子节点，如果是，则成功获取锁，开始执行业务逻辑操作；如果不是，则监听自己的上一个节点的删除事件</p><p>5、持有锁的线程释放锁，只需删除当前节点即可。</p><p>6、当自己监听的节点被删除时，监听事件触发，则回到第3步重新进行判断，直到获取到锁。</p><p>由于 Zookeeper 保证了数据的强一致性，因此不会存在之前 Redis 方案中的问题，整体上来看还是比较不错的。</p><p>Zookeeper 方案的主要问题在于性能不如 Redis 那么好，当申请锁和释放锁的频率较高时，会对集群造成压力，此时集群的稳定性可用性能可能又会遭受挑战。</p><p><strong>分布式锁的选型</strong></p><p>当前主流的方案有两种：</p><ul><li><p>Redis 的 set 加锁+lua 脚本解锁方案，至于是不是用守护线程续命可以结合自己的场景去决定，个人建议还是可以使用的。</p></li><li><p>Zookeeper 方案</p></li></ul><p>通常情况下，对于数据的安全性要求没那么高的，可以采用 Redis 的方案，对数据安全性要求比较高的可以采用 Zookeeper 的方案。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-持久化机制</title>
      <link href="2021/05/23/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
      <url>2021/05/23/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Redis是一个内存数据库，数据可以持久化到磁盘。有了持久化方案，Redis就可以对数据进行备份、恢复、复制。Redis提供了两种持久化方案：RDB和AOF。在Redis 4.0中，提供了一个新特性：两者的混合持久化。</p><p>RDB是一种快照存储持久化方式，具体就是当达到触发条件时，Redis可以将内存中的数据以二进制的形式，保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>开启RDB持久化方式很简单，客户端可以通过向Redis服务器发送save或bgsave命令让服务器生成rdb文件，或者通过服务器配置文件指定触发RDB条件。</p><ol><li><strong>save命令</strong></li></ol><p>save命令是一个同步操作。当客户端向服务器发送save命令请求进行持久化时，服务器会阻塞save命令之后的其他客户端的请求，直到数据同步完成。</p><p>如果数据量太大，同步数据会执行很久，而这期间Redis服务器也无法接收其他请求，所以，最好不要在生产环境使用save命令</p><ol start="2"><li><strong>bgsave</strong></li></ol><p>与save命令不同，bgsave命令是一个异步操作。</p><p>当客户端发服务发出bgsave命令时，Redis服务器主进程会forks一个子进程来数据同步问题，在将数据保存到rdb文件之后，子进程会退出。</p><p>所以，与save命令相比，Redis服务器在处理bgsave采用子线程进行IO写入，而主进程仍然可以接收其他请求，但forks子进程是同步的，所以forks子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave命令仍然有阻塞其他客户的请求的情况发生。</p><ol start="3"><li><strong>服务器配置自动触发</strong></li></ol><p>除了通过客户端发送命令外，还有一种方式，就是在Redis配置文件中的save指定到达触发RDB持久化的条件，比如【多少秒内至少达到多少写操作】就开启RDB数据同步。</p><p>例如我们可以在配置文件redis.conf指定如下的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 900s内至少达到一条写命令</span><br><span class="line">save 900 1</span><br><span class="line"># 300s内至少达至10条写命令</span><br><span class="line">save 300 10</span><br><span class="line"># 60s内至少达到10000条写命令</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>这种通过服务器配置文件触发RDB的方式，与bgsave命令类似，达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</p><p>前面介绍了三种让服务器生成rdb文件的方式，无论是由主进程生成还是子进程来生成，其过程如下：</p><ul><li>生成临时rdb文件，并写入数据。</li><li>完成数据写入，用临时文代替代正式rdb文件。</li><li>删除原来的db文件。</li></ul><p>RDB默认生成的文件名为dump.rdb，当然，我可以通过配置文件进行更加详细配置，比如在单机下启动多个redis服务器进程时，可以通过端口号配置不同的rdb名称，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 是否压缩rdb文件</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># rdb文件的名称</span><br><span class="line">dbfilename redis-6379.rdb</span><br><span class="line"></span><br><span class="line"># rdb文件保存目录</span><br><span class="line">dir ~&#x2F;redis&#x2F;</span><br></pre></td></tr></table></figure><p><strong>RDB的几个优点</strong></p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul><p><strong>RDB的几个缺点</strong></p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>聊完了RDB,来聊聊Redis的另外一个持久化方式：AOF(Append-only file)。</p><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><p><strong>开启AOF持久化方式</strong></p><p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开启aof机制</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># aof文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no</span><br><span class="line">appendfsync always</span><br><span class="line"></span><br><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 保存目录</span><br><span class="line">dir ~&#x2F;redis&#x2F;</span><br></pre></td></tr></table></figure><p><strong>三种写入策略</strong></p><p>在上面的配置文件中，我们可以通过appendfsync选项指定写入策略,有三个选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line"># appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure><ol><li><strong>always</strong></li></ol><p>客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p><ol start="2"><li><strong>everysec</strong></li></ol><p>appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。</p><ol start="3"><li><strong>no</strong></li></ol><p>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</p><p><strong>AOF文件重写</strong></p><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。</p><p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p><p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。</p><p><strong>两种重写方式</strong></p><p>通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认不重写aof文件</span><br><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让服务器异步重写追加aof文件命令</span><br><span class="line">&gt; bgrewriteaof</span><br></pre></td></tr></table></figure><p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理，如下所示：</p><p>重写aof文件的好处</p><ul><li>压缩aof文件，减少磁盘占用量。</li><li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li></ul><p><strong>AOF文件损坏</strong></p><p>在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。</p><p>1、备份现在aof文件，以防万一。</p><p>2、使用redis-check-aof命令修复aof文件，该命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修复aof日志文件</span><br><span class="line">$ redis-check-aof -fix file.aof</span><br></pre></td></tr></table></figure><p>3、重启Redis服务器，加载已经修复的aof文件，恢复数据。</p><p><strong>AOF的优点</strong></p><ul><li>AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li></ul><p><strong>AOF的缺点</strong></p><ul><li>AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。</li><li>恢复数据的速度比RDB慢。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过下面的表示，我们可以从几个方面对比一下RDB与AOF,在应用时，要根本自己的实际需求，选择RDB或者AOF，其实，如果想要数据足够安全，可以两种方式都开启，但两种持久化方式同时进行IO操作，会严重影响服务器性能，因此有时候不得不做出选择。</p><p><img src="/images/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/rdb%E5%92%8Caof%E5%AF%B9%E6%AF%94.png" alt="rdb和aof对比"></p><p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p><blockquote><p>引用<br><a href="https://juejin.cn/post/6844903949527416845">https://juejin.cn/post/6844903949527416845</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-布隆过滤器</title>
      <link href="2021/05/22/redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>2021/05/22/redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、布隆过滤器使用场景"><a href="#1、布隆过滤器使用场景" class="headerlink" title="1、布隆过滤器使用场景"></a>1、布隆过滤器使用场景</h3><p>　　比如有如下几个需求：<br>　　①、原本有10亿个号码，现在又来了10万个号码，要快速准确判断这10万个号码是否在10亿个号码库中？<br>　　解决办法一：将10亿个号码存入数据库中，进行数据库查询，准确性有了，但是速度会比较慢。</p><p>　　解决办法二：将10亿号码放入内存中，比如Redis缓存中，这里我们算一下占用内存大小：10亿*8字节=8GB，通过内存查询，准确性和速度都有了，但是大约8gb的内存空间，挺浪费内存空间的。</p><p>　　②、接触过爬虫的，应该有这么一个需求，需要爬虫的网站千千万万，对于一个新的网站url，我们如何判断这个url我们是否已经爬过了？</p><p>　　解决办法还是上面的两种，很显然，都不太好。</p><p>　　③、同理还有垃圾邮箱的过滤。</p><p>　　那么对于类似这种，大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存，<strong>布隆过滤器</strong>应运而生了。</p><h3 id="2、布隆过滤器简介"><a href="#2、布隆过滤器简介" class="headerlink" title="2、布隆过滤器简介"></a>2、布隆过滤器简介</h3><p>　　带着上面的几个疑问，我们来看看到底什么是布隆过滤器。</p><p>　　布隆过滤器：一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。</p><p>　　如下所示：</p><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="img"></p><p>　　<strong>①、添加数据</strong></p><p>　　介绍概念的时候，我们说可以将布隆过滤器看成一个容器，那么如何向布隆过滤器中添加一个数据呢？</p><p>　　如下图所示：当要向布隆过滤器中添加一个元素key时，我们通过多个hash函数，算出一个值，然后将这个值所在的方格置为1。</p><p>　　比如，下图hash1(key)=1，那么在第2个格子将0变为1（数组是从0开始计数的），hash2(key)=7，那么将第8个格子置位1，依次类推。</p><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A82.png" alt="img"></p><p>　　<strong>②、判断数据是否存在？</strong></p><p>　　知道了如何向布隆过滤器中添加一个数据，那么新来一个数据，我们如何判断其是否存在于这个布隆过滤器中呢？</p><p>　　很简单，我们只需要将这个新的数据通过上面自定义的几个哈希函数，分别算出各个值，然后看其对应的地方是否都是1，如果存在一个不是1的情况，那么我们可以说，该新数据一定不存在于这个布隆过滤器中。</p><p>　　反过来说，如果通过哈希函数算出来的值，对应的地方都是1，那么我们能够肯定的得出：这个数据一定存在于这个布隆过滤器中吗？</p><p>　　答案是否定的，因为多个不同的数据通过hash函数算出来的结果是会有重复的，所以会存在某个位置是别的数据通过hash函数置为的1。</p><p>　　我们可以得到一个结论：<strong>布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在</strong>。</p><p>　　<strong>③、布隆过滤器优缺点</strong></p><p>　　优点：优点很明显，二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。</p><p>　　缺点：随着数据的增加，误判率会增加；还有无法判断数据一定存在；另外还有一个重要缺点，无法删除数据。</p><h3 id="3、Redis实现布隆过滤器"><a href="#3、Redis实现布隆过滤器" class="headerlink" title="3、Redis实现布隆过滤器"></a>3、Redis实现布隆过滤器</h3><h4 id="①、bitmaps"><a href="#①、bitmaps" class="headerlink" title="①、bitmaps"></a>①、bitmaps</h4><p>　　我们知道计算机是以二进制位作为底层存储的基础单位，一个字节等于8位。</p><p>　　比如“big”字符串是由三个字符组成的，这三个字符对应的ASCII码分为是98、105、103，对应的二进制存储如下：</p><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A83.png" alt="img"></p><p>　　在Redis中，Bitmaps 提供了一套命令用来操作类似上面字符串中的每一个位。</p><p>　　<strong>一、设置值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A84.png" alt="img"></p><p> 　我们知道”b”的二进制表示为0110 0010，我们将第7位（从0开始）设置为1，那0110 0011 表示的就是字符“c”，所以最后的字符 “big”变成了“cig”。</p><p>　　<strong>二、获取值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbit key offset</span><br></pre></td></tr></table></figure><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A86.png" alt="img"></p><p> 　<strong>三、获取位图指定范围值为1的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure><p>　　如果不指定，那就是获取全部值为1的个数。</p><p>　　注意：start和end指定的是<strong>字节的个数</strong>，而不是位数组下标。</p><p>　　<img src="/images/untype/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A85.png" alt="img"></p><h4 id="②、Redisson"><a href="#②、Redisson" class="headerlink" title="②、Redisson"></a>②、Redisson</h4><p>　　Redis 实现布隆过滤器的底层就是通过 bitmap 这种数据结构，至于如何实现，这里就不重复造轮子了，介绍业界比较好用的一个客户端工具——Redisson。</p><p>　　Redisson 是用于在 Java 程序中操作 Redis 的库，利用Redisson 我们可以在程序中轻松地使用 Redis。</p><p>　　下面我们就通过 Redisson 来构造布隆过滤器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.ys.rediscluster.bloomfilter.redisson;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import org.redisson.Redisson;</span><br><span class="line"> 4 import org.redisson.api.RBloomFilter;</span><br><span class="line"> 5 import org.redisson.api.RedissonClient;</span><br><span class="line"> 6 import org.redisson.config.Config;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class RedissonBloomFilter &#123;</span><br><span class="line"> 9 </span><br><span class="line">10     public static void main(String[] args) &#123;</span><br><span class="line">11         Config config &#x3D; new Config();</span><br><span class="line">12         config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;192.168.14.104:6379&quot;);</span><br><span class="line">13         config.useSingleServer().setPassword(&quot;123&quot;);</span><br><span class="line">14         &#x2F;&#x2F;构造Redisson</span><br><span class="line">15         RedissonClient redisson &#x3D; Redisson.create(config);</span><br><span class="line">16 </span><br><span class="line">17         RBloomFilter&lt;String&gt; bloomFilter &#x3D; redisson.getBloomFilter(&quot;phoneList&quot;);</span><br><span class="line">18         &#x2F;&#x2F;初始化布隆过滤器：预计元素为100000000L,误差率为3%</span><br><span class="line">19         bloomFilter.tryInit(100000000L,0.03);</span><br><span class="line">20         &#x2F;&#x2F;将号码10086插入到布隆过滤器中</span><br><span class="line">21         bloomFilter.add(&quot;10086&quot;);</span><br><span class="line">22 </span><br><span class="line">23         &#x2F;&#x2F;判断下面号码是否在布隆过滤器中</span><br><span class="line">24         System.out.println(bloomFilter.contains(&quot;123456&quot;));&#x2F;&#x2F;false</span><br><span class="line">25         System.out.println(bloomFilter.contains(&quot;10086&quot;));&#x2F;&#x2F;true</span><br><span class="line">26     &#125;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure><p>　　这是单节点的Redis实现方式，如果数据量比较大，期望的误差率又很低，那单节点所提供的内存是无法满足的，这时候可以使用分布式布隆过滤器，同样也可以用 Redisson 来实现，这里我就不做代码演示了，大家有兴趣可以试试。</p><h3 id="4、guava-工具"><a href="#4、guava-工具" class="headerlink" title="4、guava 工具"></a>4、guava 工具</h3><p>　　最后提一下不用Redis如何来实现布隆过滤器。</p><p>　　guava 工具包相信大家都用过，这是谷歌公司提供的，里面也提供了布隆过滤器的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.ys.rediscluster.bloomfilter;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import com.google.common.base.Charsets;</span><br><span class="line"> 4 import com.google.common.hash.BloomFilter;</span><br><span class="line"> 5 import com.google.common.hash.Funnel;</span><br><span class="line"> 6 import com.google.common.hash.Funnels;</span><br><span class="line"> 7 </span><br><span class="line"> 8 public class GuavaBloomFilter &#123;</span><br><span class="line"> 9     public static void main(String[] args) &#123;</span><br><span class="line">10         BloomFilter&lt;String&gt; bloomFilter &#x3D; BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8),100000,0.01);</span><br><span class="line">11 </span><br><span class="line">12         bloomFilter.put(&quot;10086&quot;);</span><br><span class="line">13 </span><br><span class="line">14         System.out.println(bloomFilter.mightContain(&quot;123456&quot;));</span><br><span class="line">15         System.out.println(bloomFilter.mightContain(&quot;10086&quot;));</span><br><span class="line">16     &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-Innodb-存储结构</title>
      <link href="2021/05/21/Mysql-Innodb-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>2021/05/21/Mysql-Innodb-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间内，称为表空间(tablespace)，而表空间由段（sengment）、区（extent）、页（page）组成。 在一些文档中extend又称块（block）。</p><h3 id="表空间（table-space）"><a href="#表空间（table-space）" class="headerlink" title="表空间（table space）"></a>表空间（table space）</h3><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p><p>在 InnoDB 中存在两种表空间的类型：共享表空间和独立表空间。如果是共享表空间就意味着多张表共用一个表空间。如果是独立表空间，就意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间可以在不同的数据库之间进行迁移。可通过命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#39;innodb_file_per_table&#39;;</span><br></pre></td></tr></table></figure><p>查看当前系统启用的表空间类型。目前最新版本已经默认启用独立表空间。</p><p>InnoDB把数据保存在表空间内，表空间可以看作是InnoDB存储引擎逻辑结构的最高层。本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间并不只是存储表和索引，还保存了回滚段、双写缓冲区等。</p><h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><h3 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h3><p>在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。在任何情况下每个区大小都为1MB，为了保证页的连续性，InnoDB存储引擎每次从磁盘一次申请4-5个区。默认情况下，InnoDB存储引擎的页大小为16KB，即一个区中有64个连续的页。</p><h3 id="页（Page）"><a href="#页（Page）" class="headerlink" title="页（Page）"></a>页（Page）</h3><p>页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB；InnoDB存储引擎从1.2.x版本碍事，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改，除非通过mysqldump导入和导出操作来产生新的库。</p><p>innoDB存储引擎中，常见的页类型有：</p><ol><li><p> 数据页（B-tree Node)</p></li><li><p> undo页（undo Log Page）</p></li><li><p> 系统页 （System Page）</p></li><li><p> 事物数据页 （Transaction System Page）</p></li><li><p> 插入缓冲位图页（Insert Buffer Bitmap）</p></li><li><p> 插入缓冲空闲列表页（Insert Buffer Free List）</p></li><li><p> 未压缩的二进制大对象页（Uncompressed BLOB Page）</p></li><li><p> 压缩的二进制大对象页 （compressed BLOB Page）</p></li></ol><h3 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h3><p>InnoDB存储引擎是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2-200，即7992行记录。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-explain</title>
      <link href="2021/05/20/mysql-explain/"/>
      <url>2021/05/20/mysql-explain/</url>
      
        <content type="html"><![CDATA[<p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>SELECT的查询序列号</p><ol><li><p>id相同时，执行顺序由上至下</p></li><li><p>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p></li></ol><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type:"></a>select_type:</h3><p>表示查询的类型。</p><p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p><p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p><p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p><p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p><p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p><p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p><p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p><p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p><p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>输出结果集的表,显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>表示表的连接类型，对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p><table><thead><tr><th>ALL</th><th>全表扫描</th></tr></thead><tbody><tr><td><strong>index</strong></td><td><strong>索引全扫描</strong></td></tr><tr><td><strong>range</strong></td><td><strong>索引范围扫描</strong></td></tr><tr><td><strong>ref</strong></td><td><strong>非唯一索引扫描</strong></td></tr><tr><td><strong>eq_ref</strong></td><td><strong>唯一索引扫描</strong></td></tr><tr><td><strong>const,system</strong></td><td><strong>单表最多有一个匹配行</strong></td></tr><tr><td><strong>NULL</strong></td><td><strong>不用扫描表或索引</strong></td></tr></tbody></table><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p>index: 索引全扫描，MySQL遍历整个索引来查询匹配行，并不会扫描表</p><p>range:索引范围扫描，常用于&lt;、&lt;=、&gt;、&gt;=、between等操作，注意这种情况下比较的字段是需要加索引的，如果没有索引，则    MySQL会进行全表扫描，</p><p>ref: 使用非唯一索引或唯一索引的前缀扫描，返回匹配某个单独值的记录行*</p><p>eq_ref: 类似ref，区别在于使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配</p><p>const、system:  单表中最多有一条匹配行，查询起来非常迅速，所以这个匹配行的其他列的值可以被优化器在当前查询中当作常量来处理</p><p>NULL: MySQL不用访问表或者索引，直接就能够得到结果</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>表示查询时，可能使用的索引，指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>表示实际使用的索引，key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>索引字段的长度，表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p>不损失精确性的情况下，长度越短越好 </p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>列与索引的比较，列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例(百分比)</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息</p><p>最主要的有一下三种：</p><table><thead><tr><th>Using Index</th><th>表示索引覆盖，不会回表查询</th></tr></thead><tbody><tr><td><strong>Using Where</strong></td><td><strong>表示进行了回表查询</strong></td></tr><tr><td><strong>Using Index Condition</strong></td><td><strong>表示进行了ICP优化</strong></td></tr><tr><td><strong>Using Flesort</strong></td><td><strong>表示MySQL需额外排序操作, 不能通过索引顺序达到排序效果</strong></td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</p><p>• EXPLAIN不考虑各种Cache</p><p>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作</p><p>• 部分统计信息是估算的，并非精确值</p><p>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-Btree索引</title>
      <link href="2021/05/19/Mysql-Btree%E7%B4%A2%E5%BC%95/"/>
      <url>2021/05/19/Mysql-Btree%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。<br>索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到 4 这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。工作开发中最常接触到的 InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><img src="/images/mysql/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.jpg" alt="二叉查找树.jpg"></p><p>从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。</p><p>图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。</p><p>二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。</p><p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p><ul><li>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。</li><li>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</li><li>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</li></ul><p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造：</p><p><img src="/images/mysql/%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.jpg" alt="极端情况下二叉查找树"></p><p>这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。</p><p>我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p><p>为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树。B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树：</p><p><img src="/images/mysql/B-tree.jpg" alt="B-tree"></p><p>图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p><p> 从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p>假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：</p><ul><li>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。</li><li>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。</li><li>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是对 B 树的进一步优化。让我们先来看下 B+ 树的结构图：</p><p><img src="/images/mysql/B+tree.jpg" alt="B+tree"></p><p>根据上图我们来看下 B+ 树和 B 树有什么不同：</p><p>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p><p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p><p>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。</p><p>那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引</p><p>通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>平衡二叉树是由二叉树进化而来，主要是因为在极端情况下，二叉树可能会变成一个一个链表，导致查询效率术低，平衡二叉树通过调节调节使左右子树的高度差不超过1，保持结构的平衡，解决了这个问题</li><li>B-tree索引的数据结果实际上就是一个平衡二叉树结构，只不过单个节点上可以存储多个键值和数据</li><li>B+tree是B-tree的优化，非叶子节点上不存储数据，查询的范围和效率更高</li></ol><blockquote><p>引用<br><a href="http://www.liuzk.com/410.html">http://www.liuzk.com/410.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-优化</title>
      <link href="2021/05/18/Mysql-%E4%BC%98%E5%8C%96/"/>
      <url>2021/05/18/Mysql-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="/images/mysql/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.jpg" alt="mysql逻辑架构"></p><p>MySQL逻辑架构整体分为三层：</p><p>客户端层：最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>核心服务层：<br>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>存储引擎层：最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/images/mysql/mysql%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="mysql工作流程"></p><h4 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h4><p>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><ol><li>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li><li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li></ol><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，</p><h4 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h4><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p><p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p><ul><li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li><li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li><li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li><li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li></ul><h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p><h4 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h4><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足工作流程图中①处所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p><h4 id="工作过程总结"><a href="#工作过程总结" class="headerlink" title="工作过程总结"></a>工作过程总结</h4><ol><li>客户端向MySQL服务器发送一条查询请求</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li><li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li><li>MySQL根据执行计划，调用存储引擎的API来执行查询</li><li>将结果返回给客户端，同时缓存查询结果</li></ol><h3 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h3><ul><li>执行顺序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from &#39;表&#39;   </span><br><span class="line">on &#39;条件&#39;</span><br><span class="line">&#39;join类型&#39; join &#39;表&#39;</span><br><span class="line">where &#39;条件&#39;</span><br><span class="line">group by &#39;字段&#39;</span><br><span class="line">having &#39;条件&#39;</span><br><span class="line">select distinct &#39;字段&#39;</span><br><span class="line">order by &#39;字段&#39;</span><br><span class="line">limit &#39;条件&#39;</span><br></pre></td></tr></table></figure><p>1、FORM: 对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1。</p><p>2、ON: 对虚表VT1进行ON过滤，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</p><p>3、JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3。</p><p>4、WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</p><p>5、GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。</p><p>6、HAVING： 对虚拟表VT5应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT6中。</p><p>7、SELECT： 执行select操作，选择指定的列，插入到虚拟表VT7中。</p><p>8、DISTINCT： 对VT7中的记录进行去重。产生虚拟表VT8.</p><p>9、ORDER BY: 将虚拟表VT8中的记录按照<order_by_list>进行排序操作，产生虚拟表VT9.</p><p>10、LIMIT：取出指定行的记录，产生虚拟表VT10, 并将结果返回。</p><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ul><li><p>最左原则</p><p>对于多列索引，总是从索引的最前面字段开始，接着往后，中间不能跳过。比如创建了多列索引(name,age,sex)，会先匹配name字段，再匹配age字段，再匹配sex字段的，中间不能跳过。mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。因此，在创建多列索引时，where子句中使用最频繁的一列放在最左边。</p></li><li><p>MySQL不会使用索引的情况：非独立的列，“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</p></li><li><p>使用前缀索引，如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p></li><li><p>多列索引和索引顺序：在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，因此当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引，当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高，可以考虑使用UION或UNION ALL，另外索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p></li><li><p>避免多个范围条件，因为实际开发中，如果多个范围条件列都有索引，无法同时使用它们。比如想查询某个时间段内登录过的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> login_time <span class="operator">&gt;</span> <span class="string">&#x27;2017-04-01&#x27;</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p></li><li><p>覆盖索引</p><p>如果一个索引包含要所有需要查询的字段值，那么这样的索引称为覆盖索引，因为索引的叶子节点已经包含了要查询的值，就没有必要再回表查询，因此效率更高。</p></li><li><p>使用索引扫描来排序</p><p>索引设计尽可能满足排序和查找两种任务，这样当order by子句顺序与索引顺序一致时，才能使用索引对查询结果排序，提高查询效率</p></li><li><p>冗余和重复索引</p><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</p><p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p></li></ul><p><strong>总结</strong></p><p>索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，<strong>explain后再提测是一种美德</strong>。</p><h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><strong>优化COUNT()查询</strong><br><strong>COUNT()<strong>可能是被大家误解最多的函数了，它有</strong>两种不同的作用</strong>，其一是<strong>统计某个列值的数量</strong>，其二是<strong>统计行数</strong>。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p><p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。</p><h4 id="select"><a href="#select" class="headerlink" title="select *"></a>select *</h4><p>绝大多数情况，是不需要<code>select *</code>的。一旦使用了这种语句，便会让优化器无法完成索引覆盖扫描这类优化，而且还会增加额外的I/O、内存和CPU的消耗。 当然，使用<code>select *</code>也并不是全是坏处，合理的使用<code>select *</code>可以简化开发，提高相同代码的复用性。</p><h4 id="切分SQL"><a href="#切分SQL" class="headerlink" title="切分SQL"></a>切分SQL</h4><p>传统的互联网系统中，强调网络连接尽量少，数据层尽可能在一次连接中完成尽可能多的工作，防止建立多次链接，但是这种想法对于MySQL并不适用，MySQL从设计上让连接和断开都很轻量，在一般服务器上可以支持每秒超过10万的查询。所以对于有些场景下，可以将一个大的查询“分而治之”，切分成小查询，然后再组合起来。例如以下情况：</p><ul><li>对于全量数据查询变成分页。假如一张表中有数千万条数据，一次select all，肯定是不行的。可以换成一次取一部分，把一次的压力分摊。</li><li>删除大量旧数据的时候，不要一个大的语句一次性清完，推荐<code>一次删一万条</code>。如果用一个大的语句一次性完成的话，可能需要一次锁住大量数据，占满大量日志事务，让Mysql停在那儿了，为避免这种情况发生，最好一次性删除一万条左右的数据，然后每次删完暂停一会儿再操作，将服务器上的一次性压力分散。</li></ul><p>注意：虽然Mysql建立连接十分轻量，但是这不意味着可以逐条循环中查询然后再拼接，这样效率依然是非常慢，而且通常是工作中sql优化的点。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>确保在on子句的列上有索引，另外在创建索引的时候可考虑到表的关联顺序，如果表A、表B，用c列作为关联列的时候，如果优化器的顺序是B、A，那么就不需要在B表的对应列上建立索引，因为没有用到的索引会带来额外的负担，除非有必要的理由。</p><h4 id="超大分页"><a href="#超大分页" class="headerlink" title="超大分页"></a>超大分页</h4><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>like ‘%关键字%’ 全表扫描，like ‘关键字%’，才会走索引</p><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><ul><li>禁止在where条件上进行函数转换或表达式计算，否则索引不会生效</li><li>where 子句中用到or，用union all代替</li></ul><blockquote><p>引用<br><a href="https://www.cnblogs.com/yungyu16/p/12956251.html">https://www.cnblogs.com/yungyu16/p/12956251.html</a><br><a href="https://juejin.cn/post/6844903777820999694">https://juejin.cn/post/6844903777820999694</a><br><a href="https://juejin.cn/post/6844903894334586888">https://juejin.cn/post/6844903894334586888</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-聚集索引和非聚集索引</title>
      <link href="2021/05/17/Mysql-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
      <url>2021/05/17/Mysql-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引：</p><p>①聚集索引（聚簇索引）：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p><p>②非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的 B+ 树索引，我们称之为非聚集索引。</p><p>非聚集索引与聚集索引的区别在于，非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p><p>下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下 B+ 树索引查找数据方法。</p><h3 id="利用聚集索引查找数据"><a href="#利用聚集索引查找数据" class="headerlink" title="利用聚集索引查找数据"></a>利用聚集索引查找数据</h3><p><img src="/images/mysql/B+%E6%A0%91-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE.jpg" alt="B+树-聚集索引查找数据"></p><p>还是这张 B+ 树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。</p><p>现在假设我们要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">18</span>  <span class="keyword">and</span> id <span class="operator">&lt;</span><span class="number">40</span></span><br></pre></td></tr></table></figure><p>其中 id 为主键，具体的查找过程如下：</p><ol><li>一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</li><li>要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</li><li>同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</li><li>因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</li></ol><p>最终我们找到满足条件的所有数据，总共 12 条记录：</p><p>(18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。</p><p>下面看下具体的查找流程图</p><p><img src="/images/mysql/B+%E6%A0%91%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B.jpg" alt="B+树聚集索引查找数据过程"></p><h3 id="利用非聚集索引查找数据"><a href="#利用非聚集索引查找数据" class="headerlink" title="利用非聚集索引查找数据"></a>利用非聚集索引查找数据</h3><p><img src="/images/mysql/B+%E6%A0%91%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.jpg" alt="B+树非聚集索引"></p><p>测试数据表结构是这样的：</p><p><img src="/images/mysql/%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" alt="测试数据表结构"></p><p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p><p>如果我们要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>  luckNum<span class="operator">=</span><span class="number">33</span></span><br></pre></td></tr></table></figure><p>查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值 47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p><p>下面看下具体的查找流程图：</p><p><img src="/images/mysql/B+%E6%A0%91%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B.jpg" alt="B+树非聚集索引查询数据过程"></p><p>在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据即索引，索引即数据。</p><blockquote><p>引用<br><a href="http://www.liuzk.com/410.html">http://www.liuzk.com/410.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-基础理论</title>
      <link href="2021/05/16/mysql-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>2021/05/16/mysql-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>SQL</strong></p><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><p><strong>MySQL</strong><br>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><p><strong>数据库三大范式</strong></p><ul><li><p>每个列都不可以再拆分。</p></li><li><p>在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p></li></ul><ul><li>在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><p><strong>mysql有关权限的表</strong></p><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li><p>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p></li><li><p>db权限表：记录各个帐号在各个数据库上的操作权限。</p></li><li><p>table_priv权限表：记录数据表级的操作权限。</p></li><li><p>columns_priv权限表：记录数据列级的操作权限。</p></li><li><p>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p></li></ul><p><strong>MySQL的binlog录入格式</strong></p><p>有三种格式，statement，row和mixed。</p><ul><li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。<br>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</li></ul><p><strong>数据类型</strong></p><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td></td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td></td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td></td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td></td><td>double</td><td>双精度浮点数</td></tr><tr><td></td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td></td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td></td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td></td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td></td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td><strong>文本、二进制类型</strong></td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td></td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td></td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td></td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td></td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td></td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table><p>1、<strong>整数类型</strong>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p><p>2、<strong>实数类型</strong>，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p><p>3、<strong>字符串类型</strong>，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>使用策略：<br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p><p>4、<strong>枚举类型</strong>（ENUM），把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p><p>5、<strong>日期和时间类型</strong>，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p><strong>MySQL存储引擎</strong></p><p>MyISAM与InnoDB</p><ul><li><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p></li><li><p><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p></li></ul><p>MyISAM与InnoDB区别</p><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td></td></tr><tr><td>INSERT、UPDATE、DELETE</td><td></td><td>InnoDB更优</td></tr><tr><td>select count(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam 是堆表</td><td>B+树索引，Innodb 是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>MyISAM索引与InnoDB索引的区别</strong></p><p>InnoDB索引是聚簇索引，InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p><p>MyISAM索引是非聚簇索引。<br>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针；索引是一种数据结构，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><p><strong>索引的优点</strong></p><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p><strong>索引的缺点</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><p><strong>索引使用场景</strong></p><p><strong>where</strong></p><p>根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="type">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p><p><strong>order by</strong></p><p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p><p><strong>join</strong></p><p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p><p><strong>索引覆盖</strong></p><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p><p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><p><strong>索引类型</strong></p><p>主键索引:</p><p>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (<span class="keyword">column</span>); </span><br></pre></td></tr></table></figure><p>唯一索引: </p><p>数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><p>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</p><p>普通索引: </p><p>基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</p><p>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</p><p>全文索引：</p><p> 是目前搜索引擎使用的一种关键技术。</p><p>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</p><p><strong>索引的数据结构</strong></p><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p><strong>1）B树索引</strong></p><p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><img src="/images/mysql/Btree%E7%B4%A2%E5%BC%95.png" alt="Btree索引"></p><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><p><strong>2）哈希索引</strong></p><p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p><p><img src="/images/mysql/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt="哈希索引"></p><p><strong>索引的基本原理</strong></p><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><p><strong>索引算法有哪些</strong></p><p>索引算法有 BTree算法和Hash算法</p><p><strong>BTree算法</strong></p><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &#39;jack%&#39;; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &#39;%jack&#39;; </span><br></pre></td></tr></table></figure><p><strong>Hash算法</strong></p><p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><p><strong>索引设计的原则？</strong></p><ul><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ul><p><strong>创建索引的原则</strong></p><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><p><strong>创建索引的三种方式，删除索引</strong></p><p>第一种方式：在执行CREATE TABLE时创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">id INT auto_increment PRIMARY KEY,</span><br><span class="line">first_name VARCHAR (16),</span><br><span class="line">last_name VARCHAR (16),</span><br><span class="line">id_card VARCHAR (18),</span><br><span class="line">information text,</span><br><span class="line">KEY name (first_name, last_name),</span><br><span class="line">FULLTEXT KEY (information),</span><br><span class="line">UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第二种方式：使用ALTER TABLE命令去增加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>第三种方式：使用CREATE INDEX命令创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure><p>删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p>需要取消自增长再行删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line">MODIFY id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY</span><br></pre></td></tr></table></figure><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><p><strong>创建索引时需要注意什么</strong></p><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p><p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p><p>索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多一次IO操作获取的数据越大效率越高。</p><p><strong>使用索引查询一定能提高查询的性能吗</strong></p><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:<br>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%<br>；基于非唯一性索引的检索</p><p><strong>百万级别或以上的数据如何删除</strong></p><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><p><strong>前缀索引</strong></p><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>实操的难度：在于前缀截取的长度。</p><p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p><p><strong>最左前缀原则&amp;最左匹配原则</strong></p><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><p><strong>B树和B+树的区别</strong></p><ul><li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值</li><li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li></ul><p><img src="/images/mysql/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="B树和B+树的区别.png"></p><p><strong>使用B树的好处</strong></p><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><p><strong>使用B+树的好处</strong></p><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><p><strong>Hash索引和B+树区别?</strong></p><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</p><p>B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同：</p><ul><li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p></li><li><p>hash索引不支持使用索引进行排序，原理同上。</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p></li><li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p></li><li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p></li></ul><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p><p><strong>数据库为什么使用B+树而不是B树</strong></p><ul><li><p>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p></li><li><p>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</p></li><li><p>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</p></li><li><p>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</p></li><li><p>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。<br>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，<br>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p></li></ul><p><strong>聚簇索引与非聚簇索引</strong></p><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p><strong>何时使用聚簇索引与非聚簇索引</strong></p><p>!<img src="/images/mysql/%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="何时使用聚簇索引与非聚簇索引.png"></p><p><strong>非聚簇索引一定会回表查询吗</strong></p><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><p><strong>联合索引是</strong></p><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><p><strong>事务的四大特性(ACID)</strong></p><ol><li><strong>原子性</strong>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性</strong>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p><strong>脏读-幻读-不可重复读</strong></p><ul><li><strong>脏读(Drity Read)</strong> ：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li><strong>不可重复读(Non-repeatable read)</strong>:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li><strong>幻读(Phantom Read)</strong>:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><p><strong>事务的隔离级别</strong></p><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是<strong>MVVC（多版本并发控制）</strong>，通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><p><strong>隔离级别与锁的关系</strong></p><ul><li><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p></li><li><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p></li><li><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p></li><li><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p></li></ul><p><strong>按照锁的粒度分数据库锁有哪些</strong></p><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p><strong>MyISAM和InnoDB存储引擎使用的锁</strong></p><p>MyISAM采用表级锁(table-level locking)。<br>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p><p><strong>行级锁，表级锁和页级锁对比</strong></p><p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><p><strong>从锁的类别上分MySQL都有哪些锁呢？</strong></p><p>从锁的类别上来讲，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><p><strong>MySQL中InnoDB引擎的行锁是怎么实现的？</strong></p><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><p><strong>InnoDB存储引擎的锁的算法有三种</strong></p><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p>相关知识点：</p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><p><strong>死锁？怎么解决？</strong></p><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><p><strong>数据库的乐观锁和悲观锁</strong></p><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用<strong>版本号机制或CAS算法实现</strong>。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h1 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h1><p><strong>SQL语句分类</strong></p><p><strong>数据定义语言DDL</strong>（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p><strong>数据查询语言DQL</strong>（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p><strong>数据操纵语言DML</strong>（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p><strong>数据控制功能DCL</strong>（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><p><strong>超键、候选键、主键、外键</strong></p><ul><li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p></li><li><p>候选键：是最小超键，即没有冗余元素的超键。</p></li><li><p>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p></li><li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p></li></ul><p><strong>SQL 约束</strong></p><ul><li><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</p></li><li><p>UNIQUE: 控件字段内容不能重复，一个表允许有多个 </p></li><li><p>Unique 约束。</p></li><li><p>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</p></li><li><p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p></li><li><p>CHECK: 用于控制字段的值范围。</p></li></ul><p><strong>六种关联查询</strong></p><ul><li><p>交叉连接（CROSS JOIN）</p></li><li><p>内连接（INNER JOIN）</p></li><li><p>外连接（LEFT JOIN/RIGHT JOIN）</p></li><li><p>联合查询（UNION与UNION ALL）</p></li><li><p>全连接（FULL JOIN）</p></li><li><p>交叉连接（CROSS JOIN）</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（<span class="keyword">INNER</span> <span class="keyword">JOIN</span>）<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id<span class="operator">=</span>B.id或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id多表中同时符合某种条件的数据记录的集合，<span class="keyword">INNER</span> <span class="keyword">JOIN</span>可以缩写为<span class="keyword">JOIN</span></span><br></pre></td></tr></table></figure><p><strong>内连接分为三类</strong></p><ul><li><p>等值连接：ON A.id=B.id</p></li><li><p>不等值连接：ON A.id &gt; B.id</p></li><li><p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</p></li></ul><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><ul><li><p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</p></li><li><p>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p></li></ul><p><strong>联合查询（UNION与UNION ALL）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure><ul><li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 低于 UNION ALL</li></ul><p><strong>全连接（FULL JOIN）</strong></p><ul><li>MySQL不支持全连接</li><li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用<br>SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id<br>1<br>表连接面试题</li></ul><p><strong>子查询</strong></p><ul><li><p>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</p></li><li><p>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</p></li></ul><p><strong>子查询的三种情况</strong></p><ul><li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);   </span><br></pre></td></tr></table></figure><ul><li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);    </span><br></pre></td></tr></table></figure><ul><li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1) 查询出2011年以后入职的员工信息</span></span><br><span class="line"><span class="comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d,  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-1-1&#x27;</span>) e <span class="keyword">where</span> e.dept_id <span class="operator">=</span>  d.id;    </span><br><span class="line"><span class="comment">-- 使用表连接：</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span> <span class="keyword">from</span>  dept d <span class="keyword">inner</span> <span class="keyword">join</span> employee e <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id <span class="keyword">where</span> e.join_date <span class="operator">&gt;</span>  <span class="string">&#x27;2011-1-1&#x27;</span> </span><br></pre></td></tr></table></figure><p><strong>mysql中 in 和 exists 区别</strong></p><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><ol><li>如果查询的两个表大小相当，那么用in和exists差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol><p><strong>varchar与char的区别</strong></p><p>char的特点</p><ul><li><p>char表示定长字符串，长度是固定的；</p></li><li><p>如果插入数据的长度小于char的固定长度时，则用空格填充；</p></li><li><p>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p></li><li><p>对于char来说，最多能存放的字符个数为255，和编码无关</p></li></ul><p><strong>varchar的特点</strong></p><ul><li><p>varchar表示可变长字符串，长度是可变的；</p></li><li><p>插入的数据是多长，就按照多长来存储；</p></li><li><p>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p></li><li><p>对于varchar来说，最多能存放的字符个数为65532</p></li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><p><strong>varchar(50)中50的涵义</strong></p><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p><p><strong>int(20)中20的涵义</strong></p><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p><p><strong>mysql为什么这么设计</strong></p><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p><p><strong>mysql中int(10)和char(10)以及varchar(10)的区别</strong></p><ul><li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p><p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位</p><p>char(10) 10位固定字符串，不足补空格 最多10个字符</p><p>varchar(10) 10位可变字符串，不足补空格 最多10个字符</p></li><li><p>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p></li><li><p>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p></li></ul><p><strong>FLOAT和DOUBLE的区别</strong></p><ul><li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul><p><strong>drop、delete与truncate的区别</strong></p><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th></th><th>Delete</th><th>Truncate</th><th>Drop</th></tr></thead><tbody><tr><td>类型</td><td>属于DML</td><td>属于DDL</td><td>属于DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><p><strong>UNION与UNION ALL的区别</strong></p><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 低于 UNION ALL</li></ul><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p><p><strong>explain</strong></p><ul><li><p>执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><p>id相同执行顺序由上至下。</p><p>id不同，id值越大优先级越高，越先被执行。</p><p>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</p></li><li><p>select_type 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th>id</th><th>select_type</th><th>description</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>不包含任何子查询或union等查询</td></tr><tr><td>2</td><td>PRIMARY</td><td>包含子查询最外层查询就显示为 PRIMARY</td></tr><tr><td>3</td><td>SUBQUERY</td><td>在select或 where字句中包含的查询</td></tr><tr><td>4</td><td>DERIVED</td><td>from字句中包含的查询</td></tr><tr><td>5</td><td>UNION</td><td>出现在union后的查询语句中</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION中获取结果集，例如上文的第三个例子</td></tr></tbody></table></li><li><p>table 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id </p></li><li><p>partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p></li><li><p>type(非常重要，可以看到有没有走索引) 访问类型</p><p>ALL 扫描全表数据</p><p>index 遍历索引</p><p>range 索引范围查找</p><p>index_subquery 在子查询中使用 </p><p>ref<br>unique_subquery 在子查询中使用 </p><p>eq_ref<br>ref_or_null 对Null进行索引的优化的 </p><p>ref<br>fulltext 使用全文索引<br>ref 使用非唯一索引查找数据</p><p>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</p></li><li><p>possible_keys 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p></li><li><p>key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p><p>TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p></li><li><p>key_length 索引长度</p></li></ul><ul><li>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li></ul><ul><li>rows 返回估算的结果集数目，并不是一个准确的值。</li></ul><ul><li><p>extra 的信息非常丰富，常见的有：</p><p>Using index 使用覆盖索引</p><p>Using where 使用了用where子句来过滤结果集</p><p>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</p><p>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</p><p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </p><p>说明：<br>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </p><p>2） ref 指的是使用普通的索引（normal index）。 </p><p>3） range 对索引进行范围检索。 </p><p>反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p></li></ul><p><strong>SQL的生命周期</strong></p><ol><li>应用服务器与数据库服务器建立一个连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ol><p><img src="/images/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="sql执行过程"></p><p><strong>大表数据查询优化</strong></p><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><p><strong>超大分页处理</strong></p><p>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</p><p>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.<br>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 【推荐】利用延迟关联或者子查询优化超多分页场景。 </span></span><br><span class="line"><span class="comment">-- 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常-- 的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 </span></span><br><span class="line"><span class="comment">-- 正例：先快速定位需要获取的id段，然后再关联： </span></span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> a, (<span class="keyword">select</span> id <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 LIMIT <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure><p>mysql 分页<br>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">5</span>,<span class="number">10</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 检索记录行 <span class="number">6</span><span class="number">-15</span> </span><br></pre></td></tr></table></figure><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. </span><br></pre></td></tr></table></figure><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 </span><br></pre></td></tr></table></figure><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p><p><strong>慢查询日志</strong></p><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p><p><strong>开启慢查询日志</strong></p><p>配置项：slow_query_log</p><p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p><p><strong>设置临界时间</strong></p><p>配置项：long_query_time</p><p>查看：show VARIABLES like ‘long_query_time’，单位秒</p><p>设置：set long_query_time=0.5</p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p><p><strong>你们的业务系统是怎么处理慢查询的</strong></p><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p><p><strong>慢查询的优化</strong></p><ul><li><p>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p></li><li><p>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p></li><li><p>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p></li></ul><p><strong>为什么要尽量设定一个主键</strong></p><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><p><strong>主键使用自增ID还是UUID</strong></p><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><p><strong>字段为什么要求定义为not null</strong></p><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><p><strong>如果要存储用户的密码散列，应该使用什么字段进行存储？</strong></p><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><p><strong>优化查询过程中的数据访问</strong></p><ul><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行<br>避免犯如下SQL语句错误</li><li>查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：<ul><li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul></li></ul><p><strong>优化长难的查询语句</strong></p><ul><li>一个复杂查询还是多个简单查询</li><li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>切分查询<br>将一个大的查询分为多个小的相同的查询</li><li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>分解关联查询，让缓存的效率更高。</li><li>执行单个查询可以减少锁的竞争。</li><li>在应用层做关联更容易对数据库进行拆分。</li><li>查询效率会有大幅提升。</li><li>较少冗余记录的查询</li></ul><p><strong>优化关联查询</strong></p><ul><li>确定ON子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><p><strong>优化子查询</strong></p><ul><li>用关联查询替代</li><li>优化GROUP BY和DISTINCT</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li></ul><p><strong>优化LIMIT分页</strong></p><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><p><strong>优化UNION查询</strong></p><ul><li>UNION ALL的效率高于UNION</li></ul><p><strong>优化WHERE子句</strong></p><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span></span><br></pre></td></tr></table></figure><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br></pre></td></tr></table></figure><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span><span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3)=’abc’</span><br><span class="line">-- name以abc开头的id应改为:</span><br><span class="line">select id from t where name like ‘abc%’</span><br></pre></td></tr></table></figure><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><p><strong>数据库结构优化</strong></p><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ul><li><p>将字段很多的表分解成多个表</p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p></li><li><p>增加中间表</p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p></li><li><p>增加冗余字段</p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p>注意：</p><p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p></li></ul><p><strong>MySQL数据库cpu飙升到500%的话他怎么处理</strong></p><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><p><strong>大表怎么优化</strong></p><p>某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</p><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><p>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</p></li><li><p>读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p>缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</p></li><li><p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p><p>垂直分区：</p><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p></li></ol><p><img src="/images/mysql/%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA.png" alt="垂直分区"></p><p>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><p>垂直分表</p><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p><img src="/images/mysql/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.png" alt="垂直分表"></p><p>适用场景</p><ol><li>如果一个表中某些列常用，另外一些列不常用</li><li>可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li></ol><p>缺点</p><ol><li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li><li>对于应用层来说，逻辑算法增加开发成本</li><li>管理冗余列，查询所有数据需要join操作</li></ol><p>水平分区：</p><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p><img src="/images/mysql/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA.png" alt="水平分区"></p><p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p><p>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。</p><p>《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><p>水平分表：</p><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p><p><img src="/images/mysql/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.png" alt="水平分表"></p><p>适用场景</p><p>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p><p>2、需要把数据存放在多个介质上。</p><p>水平切分的缺点</p><p>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p><p>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p><p>下面补充一下数据库分片的两种常见方案：</p><ol><li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ol><p>分库分表后面临的问题</p><ul><li><p>事务支持 </p><p>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p>跨库join</p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。</p><p>解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p>跨节点的count,order by,group by以及聚合函数问题 这些是一类问题</p><p>因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。</p><p>解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p>数据迁移，容量规划，扩容等问题 </p><p>来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p>ID问题</p><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由.</p><p> 一些常见的主键生成策略</p><p>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p></li><li><p>跨分片的排序分页</p><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p></li></ul><p>!<img src="/images/mysql/%E8%B7%A8%E5%88%86%E7%89%87%E7%9A%84%E6%8E%92%E5%BA%8F%E5%88%86%E9%A1%B5.png" alt="跨分片的排序分页"></p><p><strong>MySQL的复制原理以及流程</strong></p><p>主从复制</p><p>将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p>主从复制的作用</p><p>主数据库出现问题，可以切换到从数据库。<br>可以进行数据库层面的读写分离。<br>可以在从数据库上进行日常备份。<br>MySQL主从复制解决的问题</p><p>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份<br>负载均衡：降低单个服务器的压力<br>高可用和故障切换：帮助应用程序避免单点失败<br>升级测试：可以用更高版本的MySQL作为从库<br>MySQL主从复制工作原理</p><p>在主库上把数据更高记录到二进制日志<br>从库将主库的日志复制到自己的中继日志<br>从库读取中继日志的事件，将其重放到从库数据中<br>基本原理流程，3个线程以及之间的关联</p><p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p><p>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p>从：sql执行线程——执行relay log中的语句；</p><p>复制过程</p><p><img src="/images/mysql/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt="主从复制过程"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><p>读写分离有哪些解决方案？<br>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。</p><p>方案一</p><p>使用mysql-proxy代理</p><p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p><p>缺点：降低性能， 不支持事务</p><p>方案二</p><p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p><p>方案三</p><p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p><p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p><p>备份计划，mysqldump以及xtranbackup的实现原理<br>(1)备份计划</p><p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p><p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p><p>(2)备份恢复时间</p><p>物理备份恢复快，逻辑备份恢复慢</p><p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><p>20G的2分钟（mysqldump）</p><p>80G的30分钟(mysqldump)</p><p>111G的30分钟（mysqldump)</p><p>288G的3小时（xtra)</p><p>3T的4小时（xtra)</p><p>逻辑导入时间一般是备份时间的5倍以上</p><p>(3)备份恢复失败如何处理</p><p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p><p>(4)mysqldump和xtrabackup实现原理</p><p>mysqldump</p><p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p><p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p><p>数据表损坏的修复方式有哪些？</p><p>使用 myisamchk 来修复，具体步骤：</p><p>1）修复前将mysql服务停止。<br>2）打开命令行方式，然后进入到mysql的/bin目录。<br>3）执行myisamchk –recover 数据库所在路径/*.MYI<br>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p><blockquote><p>引用<br><a href="https://blog.csdn.net/ThinkWon/article/details/104778621">https://blog.csdn.net/ThinkWon/article/details/104778621</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-基础理论一</title>
      <link href="2021/05/15/SpringCloud-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E4%B8%80/"/>
      <url>2021/05/15/SpringCloud-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</p><ul><li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；</li><li>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；</li><li>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。</li></ul><p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><ul><li>设计目标：协调各个微服务，简化分布式系统开发。</li></ul><ul><li><p>优点：</p><p>1、产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善</p><p>2、组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；</p><p>3、Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案</p><p>4、服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率</p><p>5、可以更精准的制定优化服务方案，提高系统的可维护性</p><p>6、减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发</p><p>7、微服务可以是跨平台的，可以用任何一种语言开发</p><p>8、适于互联网时代，产品迭代周期更短</p></li><li><p>缺点：</p><p>1、微服务过多，治理成本高，不利于维护系统</p><p>2、分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</p></li></ul><p>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/spring/SpringCloud%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="img"></p><h1 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p><ul><li><p>Spring Cloud Config</p><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p></li><li><p>Spring Cloud Netflix</p><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><ul><li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li><li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li><li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li><li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li><li>Zuul：API网关组件，对请求提供路由及过滤功能。</li></ul></li><li><p>Spring Cloud Bus</p><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p></li><li><p>Spring Cloud Consul</p><p>基于Hashicorp Consul的服务治理组件。</p></li><li><p>Spring Cloud Security</p><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p></li><li><p>Spring Cloud Sleuth</p><p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p></li><li><p>Spring Cloud Stream</p><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p></li><li><p>Spring Cloud Task</p><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p></li><li><p>Spring Cloud Zookeeper</p><p>基于Apache Zookeeper的服务治理组件。</p></li><li><p>Spring Cloud Gateway</p><p>API网关组件，对请求提供路由及过滤功能。</p></li><li><p>Spring Cloud OpenFeign</p><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p></li></ul><h1 id="Spring-Cloud的版本关系"><a href="#Spring-Cloud的版本关系" class="headerlink" title="Spring Cloud的版本关系"></a>Spring Cloud的版本关系</h1><p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个”service releases”版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p><p><strong>Spring Cloud和SpringBoot版本对应关系</strong></p><table><thead><tr><th>Spring Cloud Version</th><th>SpringBoot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><p><strong>Spring Cloud和各子项目版本对应关系</strong></p><table><thead><tr><th>Component</th><th>Edgware.SR6</th><th>Greenwich.SR2</th></tr></thead><tbody><tr><td>spring-cloud-bus</td><td>1.3.4.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-commons</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-config</td><td>1.4.7.RELEASE</td><td>2.1.3.RELEASE</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.7.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-security</td><td>1.2.4.RELEASE</td><td>2.1.3.RELEASE</td></tr><tr><td>spring-cloud-consul</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.6.RELEASE</td><td>2.1.1.RELEASE</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR5</td><td>Fishtown.SR3</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.3.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-boot</td><td>1.5.21.RELEASE</td><td>2.1.5.RELEASE</td></tr><tr><td>spring-cloud-task</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.3.RELEASE</td><td>2.1.2.RELEASE</td></tr><tr><td>spring-cloud-openfeign</td><td>暂无</td><td>2.1.2.RELEASE</td></tr></tbody></table><p>注意：Hoxton版本是基于SpringBoot 2.2.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。</p><h1 id="SpringBoot和SpringCloud"><a href="#SpringBoot和SpringCloud" class="headerlink" title="SpringBoot和SpringCloud"></a>SpringBoot和SpringCloud</h1><p>SpringBoot专注于快速方便的开发单个个体微服务。</p><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</p><p>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p><p>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</p><p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p><h1 id="分布式微服务的问题"><a href="#分布式微服务的问题" class="headerlink" title="分布式微服务的问题"></a>分布式微服务的问题</h1><ol><li>与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li><li>服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li><li>冗余-分布式系统中的冗余问题。</li><li>负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</li><li>性能-问题 由于各种运营开销导致的性能问题。</li><li>部署复杂性-Devops 技能的要求。</li></ol><blockquote><p>原文：</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104397367">https://blog.csdn.net/ThinkWon/article/details/104397367</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot-jwt-实战</title>
      <link href="2021/05/14/Springboot-jwt-%E5%AE%9E%E6%88%98/"/>
      <url>2021/05/14/Springboot-jwt-%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准（(RFC 7519)。它定义了一种简洁的、自包含的方法用于通信双方之间，以<code>JSON</code>对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用<code>HMAC</code>算法或者是<code>RSA</code>的公私秘钥对进行签名。</p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p><img src="/images/JWT%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png" alt="JWT请求流程"></p><ol><li><p>用户使用账号和面发出post请求；</p></li><li><p>服务器使用私钥创建一个jwt；</p></li><li><p>服务器返回这个jwt给浏览器；</p></li><li><p>浏览器将该jwt串在请求头中像服务器发送请求；</p></li><li><p>服务器验证该jwt；</p></li><li><p>返回响应的资源给浏览器。</p></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。 信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。</p><p><strong>优点</strong></p><p>1.简洁(Compact): 可以通过<code>URL</code>，<code>POST</code>参数或者在<code>HTTP header</code>发送，因为数据量小，传输速度也很快</p><p>2.自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p>3.因为<code>Token</code>是以<code>JSON</code>加密的形式保存在客户端的，所以<code>JWT</code>是跨语言的，原则上任何web形式都支持。</p><p>4.不需要在服务端保存会话信息，特别适用于分布式微服务。</p><p><strong>结构</strong></p><p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>连接一起就构成了JWT字符串。<br>就像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJnYW94aW5nIn0.u_OhwyFRN0eM3hFeuWrzrIXC5MWfRDJPtEXb9zquHW4</span><br></pre></td></tr></table></figure><p>JWT包含了三部分：<br>Header 头部(标题包含了令牌的元数据，并且包含签名和/或加密算法的类型)<br>Payload 负载 (类似于飞机上承载的物品)<br>Signature 签名/签证</p><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a><strong>Header</strong></h4><p><strong>JWT的头部承载两部分信息：token类型和采用的加密算法。</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>声明类型:这里是jwt<br>声明加密的算法:通常直接使用 HMAC SHA256</strong></p><p>加密算法是单向函数散列算法，常见的有MD5、SHA、HAMC。<br>MD5(message-digest algorithm 5) （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值<br>SHA (Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，安全性高于MD5<br>HMAC (Hash Message Authentication Code)，散列消息鉴别码，基于密钥的Hash算法的认证协议。用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。常用于接口签名验证</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a><strong>Payload</strong></h4><p>载荷就是存放有效信息的地方。<br>有效信息包含三个部分</p><p>1.标准中注册的声明</p><p><code>iss</code>: jwt签发者</p><p><code>sub</code>: 面向的用户(jwt所面向的用户)</p><p><code>aud</code>: 接收jwt的一方</p><p><code>exp</code>: 过期时间戳(jwt的过期时间，这个过期时间必须要大于签发时间)</p><p><code>nbf</code>: 定义在什么时间之前，该jwt都是不可用的.</p><p><code>iat</code>: jwt的签发时间</p><p><code>jti</code>: jwt的唯一身份标识，主要用来作为一次性<code>token</code>,从而回避重放攻击。</p><p>2.公共的声明</p><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p>3.私有的声明</p><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为<code>base64</code>是对称解密的，意味着该部分信息可以归类为明文信息。</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a><strong>Signature</strong></h4><p>jwt的第三部分是一个签证信息<br>这个部分需要<code>base64</code>加密后的<code>header</code>和<code>base64</code>加密后的<code>payload</code>使用<code>.</code>连接组成的字符串，然后通过<code>header</code>中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了<code>jwt</code>的第三部分。<br>密钥<code>secret</code>是保存在服务端的，服务端会根据这个密钥进行生成<code>token</code>和进行验证，所以需要保护好。</p><h3 id="与SpringBoot集成"><a href="#与SpringBoot集成" class="headerlink" title="与SpringBoot集成"></a>与SpringBoot集成</h3><p><strong>引入<code>JWT</code>依赖,由于是基于<code>Java</code>，所以需要的是<code>java-jwt</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecretUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String loginNo;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoginNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginNo</span><span class="params">(String loginNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loginNo = loginNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建token</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">(SecretUser secretUser)</span></span>&#123;</span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withAudience(secretUser.getLoginNo())</span><br><span class="line">                .sign(Algorithm.HMAC256(secretUser.getPwd()));</span><br><span class="line">        <span class="keyword">return</span>  token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Algorithm.HMAC256()</code>:使用<code>HS256</code>生成<code>token</code>,密钥则是用户的密码，唯一密钥的话可以保存在服务端。<br><code>withAudience()</code>存入需要保存在<code>token</code>的信息，这里我把用户<code>loginNo</code>存入<code>token</code>中</strong></p><p><strong>实现一个拦截器去获取<code>token</code>并验证<code>token</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请重新登陆&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DecodedJWT decodedJWT = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decodedJWT = JWT.decode(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;jwt解析失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String loginNo = decodedJWT.getAudience().get(<span class="number">0</span>);</span><br><span class="line">        SecretUser secretUser = userService.getUserSecret(loginNo);</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(secretUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户不存在，请重新登陆&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(secretUser.getPwd())).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwtVerifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;token验证失败，请重新登陆&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要流程:</strong></p><ol><li>从header中获取token，如果获取不到，抛出异常，要求重新登陆；反之，继续 向下</li><li>解析token信息，与数据库中信息对比，如果登陆用户不存在，抛出异常，要求重新登陆</li><li>如果token过期或对数据库中信息对比验证失败，抛出异常，要求重新登陆</li></ol><p><strong>配置拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtInterceptor jwtInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(jwtInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/example/login&quot;</span>)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">login</span><span class="params">(SecretUser secretUserParam)</span></span>&#123;</span><br><span class="line">        SecretUser secretUser = userService.getUserSecret(secretUserParam.getLoginNo());</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(secretUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!secretUser.getPwd().equals(secretUserParam.getPwd())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名和密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secretUser.getPwd().equals(secretUserParam.getPwd())) &#123;</span><br><span class="line">            String token = tokenService.createToken(secretUser);</span><br><span class="line">            Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;token&quot;</span>,token );</span><br><span class="line">            <span class="keyword">return</span>  map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/getUsers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BaseUser&gt; <span class="title">getUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;BaseUser&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            BaseUser baseUser = <span class="keyword">new</span> BaseUser();</span><br><span class="line">            baseUser.setAge(<span class="number">18</span>+i);</span><br><span class="line">            baseUser.setRealName(<span class="string">&quot;张三&quot;</span>+i);</span><br><span class="line">            list.add(baseUser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Springboot </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot-自动配置原理</title>
      <link href="2021/05/13/Springboot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/13/Springboot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="关键注键"><a href="#关键注键" class="headerlink" title="关键注键"></a>关键注键</h3><h4 id="SpringbootApplication"><a href="#SpringbootApplication" class="headerlink" title="@SpringbootApplication"></a>@SpringbootApplication</h4><p>组合注解</p><p>@SpringbootConfiguration</p><p>标记当前类为配置类</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>扫描主类所在的同级包以及下级包的Bean</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>开启自动配置</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>@EnableAutoConfiguration上的注解，在这个注解里的@Import(AutoConfigurationPackage.Registrar.class)，可以将被主配置注解（@SpringBootConfiguration）标注的类所在的包以及其所有下级包中被标记的组件扫描到IOC容器中去</p><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>@EnableAutoConfiguration上的注解，@Import(AutoConfigurationImportSelector.class)</p><p>通过@Import导入AutoConfigurationImportSelector类，在这个类里的selectImports()方法，可以通过SpringFactoriesLoader类得到class-path下META-INF目录下的所有spring.factories配置文件中，以EnableAutoConfiguration为key的配置类，将这些配置类注册到Sring的容器中去</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>mybatis-spring-boot-autoconfigure:2.1.4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sprigboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Mvc</title>
      <link href="2021/05/12/Spring-Mvc/"/>
      <url>2021/05/12/Spring-Mvc/</url>
      
        <content type="html"><![CDATA[<p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把<strong>模型-视图-控制器</strong>分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ol><li>前端控制器 DispatcherServlet，作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</li><li>处理器映射器 HandlerMapping，作用：根据请求的URL来查找Handler</li><li>处理器适配器HandlerAdapter</li><li>处理器Handler </li><li>视图解析器 ViewResolver，作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</li><li>视图View，View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>用户发送请求至前端控制器DispatcherServlet；</li><li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler（根据请求url找到具体的处理器，生成处理器对象及处理器拦截器一并返回给DispatcherServlet；）；</li><li>DispatcherServlet 调用 HandlerAdapter处理器适配器；</li><li>HandlerAdapter 经过适配调用具体处理器(Handler，也叫后端控制器)，Handler执行完成返回ModelAndView；</li><li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li><li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>ViewResolver解析后返回具体View；</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet将结果响应给用户。</li></ol><p><img src="/images/spring/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt="Spring-Mvc工作原理"></p><h3 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h3><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p><p><strong>mvc设计模式的好处</strong></p><p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p><p>2.有利于系统的并行开发，提升开发效率。</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping注解有六个属性:</p><ul><li><p>value， method</p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p></li><li><p>consumes，produces</p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p></li><li><p>params，headers</p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p></li></ul><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>注解实现接收http请求的json数据，将json转换为java对象。</p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><p>@ResponseBody用于controller的方法上，通过适当的HttpMessageConverter转换为指定格式后，将conreoller方法返回对象转化为json对象等格式响应给客户。</p><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p><h4 id="PathVariable和-RequestParam"><a href="#PathVariable和-RequestParam" class="headerlink" title="@PathVariable和@RequestParam"></a>@PathVariable和@RequestParam</h4><p>@PathVariable用于获取路径参数，@RequestParam用于获取查询参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/stu/list/&#123;userId&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">list</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span>Long userId,<span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果我们请求的 url 是：/stu/list/20?type=tea</p><p>那么我们服务获取到的数据就是：userId=20,type=tea。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC</title>
      <link href="2021/05/11/Spring-IOC/"/>
      <url>2021/05/11/Spring-IOC/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-IOC-理解"><a href="#Spring-IOC-理解" class="headerlink" title="Spring IOC 理解"></a>Spring IOC 理解</h3><p>IOC (Inversion of Control)就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。<br>而 DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖 IOC 容器来动态注入对象需要的外部资源；<br>最直观的表达就是，IOC 让对象的创建不用去 new，可以由 Spring 自动生产，使用 Java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的；<br>Spring IOC 有三种注入方式 ：构造器注入、Setter 方法注入、注解注入；<br>IOC 让相互协作的组件保持松散的耦合，而 AOP 编程允许把遍布于应用各层的功能分离出来形成可重用的功能组件；</p><h3 id="IOC-的实现机制"><a href="#IOC-的实现机制" class="headerlink" title="IOC 的实现机制"></a>IOC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式+反射机制</strong></p><p>Spring 容器在启动的时候，先会保存所有注册进来的 Bean 的定义信息， 注册到 BeanFactory 中；注册也只是将这些信息都保存到了注册中心（说到底核心是一个 BeanName-&gt; BeanDefinition 的 Map）；<br>设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 Bean，如 Environment、SystemProperties；<br>如果有 Bean 实现了 BeanFactoryPostProcessor 接口，Spring 会负责调用里面的 postProcessBeanFactory 方法，这是一个扩展方法；<br>注册 BeanPostProcessor 的实现类，这是在 Bean 初始化前后执行的方法；<br>初始化国际化，事件广播器的模块，注册事件监听器；<br>然后 Spring 容器就会创建这些单例 Bean<br>用到这个 Bean 的时候；利用 getBean 创建 Bean,创建好以后保存在容器中；<br>统一创建剩下所有的 Bean 的时候；调用 finishBeanFactoryInitialization() 初始化所有剩下的单例 Bean；<br>最后广播事件，ApplicationContext 初始化 / 刷新完成；</p><p><strong>Spring 的 IoC 设计支持以下功能</strong></p><ul><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ul><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。</p><p><img src="/images/spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Spring中Bean的生命周期"></p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><ol><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了<u>BeanNameAware</u>接口，Spring将bean的ID传递给<u>setBean-Name()</u>方法；</li><li>如果bean实现了<u>BeanFactoryAware</u>接口，Spring将调用<u>setBeanFactory()</u>方法，将BeanFactory容器实例传入；</li><li>如果bean实现了<u>ApplicationContextAware</u>接口，Spring将调用<u>setApplicationContext()</u>方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了<u>BeanPostProcessor</u>接口，Spring将调用它们的<u>post-ProcessBeforeInitialization()</u>方法；</li><li>如果bean实现了<u>InitializingBean</u>接口，Spring将调用它们的<u>after-PropertiesSet()</u>方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了<u>BeanPostProcessor</u>接口，Spring将调用它们的<u>post-ProcessAfterInitialization()</u>方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ol><h3 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h3><p>Bean A 依赖于另一个 Bean B 时，Bean B 依赖于 Bean A：当 Spring 上下文加载所有 Bean 时，它会尝试按照它们完全工作所需的顺序创建 Bean ，例如，如果我们没有循环依赖：Bean A→Bean B→Bean C：Spring 将创建 bean C，然后创建 bean B（并将 bean 注入其中），然后创建 bean A（并将 bean B 注入其中）；但具有循环依赖时，Spring 无法决定应该首先创建哪个 bean，因为它们彼此依赖；<br>以 Setter 方式构成的循环依赖，Spring 可以自动解决，以构造器方式构成的循环依赖，Spring 无法自动解决：Setter 注入和构造器注入的区别就在于创建 Bean 的过程中，Setter 注入可以先用无参数构造方法返回 Bean 实例，再注入依赖的属性，使用到了 Spring 的三级缓存，而 constructor 方式无法先返回 Bean 的实例，必须先实例化它所依赖的属性，这样一来就会造成死循环所以会失败；<br>解决方案：我们使用比较多的在属性上 @Autowired 的方式，在 Spring 内部的处理中，与 Setter 方法不太一样，但用此种方式循环依赖也可以自动解决，原理同上，只要能先实例化出来，提前暴露出来，就可以解决循环依赖的问题；</p><h4 id="Spring-解决循环依赖"><a href="#Spring-解决循环依赖" class="headerlink" title="Spring 解决循环依赖"></a>Spring 解决循环依赖</h4><p>Spring 使用了三级缓存解决了循环依赖的问题：在 populateBean() 给属性赋值阶段里面 Spring 会解析属性，并且赋值，当发现，A 对象里面依赖了 B，此时又会走 getBean 方法，但这个时候，你去缓存中是可以拿的到的；因为在对 createBeanInstance 对象创建完成以后已经放入了缓存当中，所以创建 B 的时候发现依赖 A，直接就从缓存中去拿，此时 B 创建完，A 也创建完；至此 Bean 的创建完成，最后将创建好的 Bean 放入单例缓存池中；</p><h4 id="Bean-创建的核心三个方法"><a href="#Bean-创建的核心三个方法" class="headerlink" title="Bean 创建的核心三个方法"></a>Bean 创建的核心三个方法</h4><p>createBeanInstance：实例化，调用对象的构造方法实例化对象；<br>populateBean：填充属性，主要是对 Bean 的依赖属性进行注入（@Autowired）；<br>initializeBean：回到一些形如 initMethod、InitializingBean 等方法；<br>从对单例 Bean 的初始化可以看出，循环依赖主要发生在 populateBean，也就是 field 属性注入的处理；</p><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p>singletonObjects：第一级单例缓存池，用于存放完全初始化好的 Bean，从该缓存中取出的 Bean 可以直接使用；<br>earlySingletonObjects：第二级，提前曝光的单例对象的 Cache，存放原始的 Bean 对象（尚未填充属性的 Bean）；<br>singletonFactories：第三级单例对象工厂缓存 ，单例对象工厂的 Cache，存放 Bean 工厂对象；</p><h4 id="单例-Bean-的创建过程"><a href="#单例-Bean-的创建过程" class="headerlink" title="单例 Bean 的创建过程"></a>单例 Bean 的创建过程</h4><p>先从一级缓存 singletonObjects 中去获取（如果获取到就直接 return）；<br>如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存 earlySingletonObjects 中获取（如果获取到就直接 return）；<br>如果还是获取不到，且允许 singletonFactories（allowEarlyReference=true）通过 getObject() 获取，就从三级缓存singletonFactory.getObject() 获取（如果获取到了就把这个 Bean 从 singletonFactories 中移除，并且放进 earlySingletonObjects，其实也就是从三级缓存移动（剪切）到了二级缓存）；</p><h4 id="Spring-解决-A、B-循环依赖流程"><a href="#Spring-解决-A、B-循环依赖流程" class="headerlink" title="Spring 解决 A、B 循环依赖流程"></a>Spring 解决 A、B 循环依赖流程</h4><p>使用 context.getBean（A.class），为了获取容器内的单例 A，若 A 不存在，就走 A 这个 Bean 的创建流程，显然初次获取 A 是不存在的，所以开始创建 A；<br>开始实例化 A（createBeanInstance，注意此处仅仅是实例化），并将它放进缓存（此时 A 已经实例化完成，已经可以被引用了）；<br>开始准备初始化 A（populateBean）：解析 A 的依赖发现依赖注入了 B（此时需要去容器内获取 B）；<br>此时开始实例化 B，到了依赖注入 B 时，会通过 getBean(B) 去容器内找 B；<br>实例化 B，并将其放入缓存（此时 B 也能够被引用了）；<br>开始准备初始化 B，发现依赖注入 A（此时需要去容器内获取 A）；<br>初始化 B 时会调用 getBean(A) 去容器内找到 A，此时候因为 A 已经实例化完成了并且放进了缓存里，所以此时去缓存里看是已经存在 A 的引用，所以 getBean(A) 能够正常返回；<br>B初始化成功，return（此处 return 相当于是返回最上面的 getBean(B) ，回到了初始化 A 的流程中）；<br>因为 B 实例已经成功返回，因此最终 A 也初始化成功；<br>B 持有的已经是初始化完成的 A，A 持有的也是初始化完成的 B；</p><p>Spring IOC 容器</p><h3 id="Spring-支持的-Bean-作用域"><a href="#Spring-支持的-Bean-作用域" class="headerlink" title="Spring 支持的 Bean 作用域"></a>Spring 支持的 Bean 作用域</h3><p>singleton：默认，每个容器中只有一个 Bean 的实例，单例的模式由 BeanFactory 自身来维护；<br>prototype：为每一个 Bean 请求提供一个实例；<br>request：为每一个网络请求创建一个实例，在请求完成以后，Bean 会失效并被垃圾回收器回收；<br>session：与 request 范围类似，确保每个 session 中有一个 Bean 实例，在 session 过期后，Bean 会随之失效；<br>global-session：全局作用域，global-session 和 Portlet 应用相关；当你的应用部署在 Portlet 容器中工作时，它包含很多 Portlet；如果你想要声明让所有的 Portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session中；全局作用域与 Servlet 中的 session 作用域效果相同；</p><h3 id="Spring-中的单例-Beans-是否线程安全"><a href="#Spring-中的单例-Beans-是否线程安全" class="headerlink" title="Spring 中的单例 Beans 是否线程安全"></a>Spring 中的单例 Beans 是否线程安全</h3><p>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理，关于单例 Bean 的线程安全和并发问题需要开发者自行去搞定，但实际上，大部分的 Spring Bean 并没有可变的状态（比如 Service 类和 DAO 类），所以在某种程度上说 Spring 的单例 Bean 是线程安全的；如果你的 Bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全，最浅显的解决办法就是将多态 Bean 作用域由 “singleton” 变更为 “prototype”；</p><h3 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a><strong>Spring的依赖注入</strong></h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：<em>依赖注入和依赖查找</em></p><p><strong>依赖注入</strong>：依赖注入（Dependency Injection），即<u>组件之间的依赖关系由容器在应用系统运行期来决定</u>，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><p><strong>依赖注入的基本原则</strong></p><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><p><strong>有哪些不同类型的依赖注入实现方式？</strong></p><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p><p>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><p>构造器依赖注入和 Setter方法注入的区别</p><table><thead><tr><th>构造函数注入</th><th>setter 注入</th></tr></thead><tbody><tr><td>没有部分注入</td><td>有部分注入</td></tr><tr><td>不会覆盖 setter 属性</td><td>会覆盖 setter 属性</td></tr><tr><td>任意修改都会创建一个新实例</td><td>任意修改不会创建一个新实例</td></tr><tr><td>适用于设置很多属性</td><td>适用于设置少量属性</td></tr></tbody></table><p>​    两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h3 id="Spring-自动装配-Bean-的方式"><a href="#Spring-自动装配-Bean-的方式" class="headerlink" title="Spring 自动装配 Bean 的方式"></a>Spring 自动装配 Bean 的方式</h3><p>Spring 容器负责创建应用程序中的 Bean，同时通过 ID 来协调这些对象之间的关系，只需要告诉 Spring 要创建哪些 Bean 并且如何将其装配到一起；<br>Spring 中 Bean 装配有两种方式：<br>属性注解；<br>属性自动装配（XML 配置）：<br>no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 Bean；<br>byName：通过 Bean 的名称进行自动装配，如果一个 Bean 的 Property 与另一 Bean Name 相同，就进行自动装配；<br>byType：通过参数的数据类型进行自动装配；<br>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配；<br>autodetect：自动探测，如果有构造方法，通过 construct 方式自动装配，否则使用 byType 的方式自动装配；</p><h4 id="Autowired-和-Resource-区别"><a href="#Autowired-和-Resource-区别" class="headerlink" title="@Autowired 和 @Resource 区别"></a>@Autowired 和 @Resource 区别</h4><p>使用@Autowired注解来自动装配指定的bean之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p><p>@Resource：默认是按照名称来装配注入的，只有当找不到与名称匹配的 Bean 才会按照类型来装配注入；</p><h3 id="ApplicationContext-和-BeanFactory-区别"><a href="#ApplicationContext-和-BeanFactory-区别" class="headerlink" title="ApplicationContext 和 BeanFactory 区别"></a>ApplicationContext 和 BeanFactory 区别</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><ul><li><input disabled="" type="checkbox"> <em>依赖关系</em></li></ul><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li><p>继承MessageSource，因此支持国际化。</p></li><li><p>统一的资源文件访问方式。</p></li><li><p>提供在监听器中注册bean的事件。</p></li><li><p>同时加载多个配置文件。</p></li></ul><ul><li><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p></li><li><p><em>加载方式</em></p></li></ul><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><ul><li><input disabled="" type="checkbox"> <em>创建方式</em></li></ul><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><ul><li><input disabled="" type="checkbox"> <em>注册方式</em></li></ul><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><p><strong>Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解</strong></p><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><p><strong>BeanFactory和ApplicationContext的关系</strong></p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。</p><p><img src="/images/spring/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="BeanFactory和ApplicationContext的关系"></p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承(实现接口)哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p>小结</p><p>说了这么多，小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><ol><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ol><p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><p><strong>ApplicationContext通常的实现</strong></p><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h3 id="Spring-框架的设计模式"><a href="#Spring-框架的设计模式" class="headerlink" title="Spring 框架的设计模式"></a>Spring 框架的设计模式</h3><p>工厂模式：Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 Bean 对象；<br>代理模式：Spring AOP 功能的实现；<br>单例模式：Spring 中的 Bean 默认都是单例的；<br>模板模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；<br>包装器模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库，这种模式让我们可以根据客户的需求能够动态切换不同的数据源；<br>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；<br>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller；</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMvc </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-cache实战</title>
      <link href="2021/05/10/Spring-cache%E5%AE%9E%E6%88%98/"/>
      <url>2021/05/10/Spring-cache%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>缓存是实际工作中常使用的一种提高性能的方法, 会在很多场景下来使用缓存。Spring 的缓存技术还具备相当的灵活性。不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存暂时存储方案，也支持和主流的专业缓存比如 EHCache 集成。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="主要注解"><a href="#主要注解" class="headerlink" title="主要注解"></a>主要注解</h3><ul><li><p>@EnableCaching</p><p>开启缓存</p></li><li><p>@Cacheable</p><p>@Cacheable注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。</p></li><li><p>@CachePut</p><p>配置于函数上，能够根据参数定义条件进行缓存，与@Cacheable不同的是，每次回真实调用函数，所以主要用于数据新增和修改操作上。</p></li><li><p>@CacheEvict</p><p>配置于函数上，通常用在删除方法上，用来从缓存中移除对应数据</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootMybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootMybatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置缓存类型"><a href="#设置缓存类型" class="headerlink" title="设置缓存类型"></a>设置缓存类型</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">simple</span></span><br><span class="line"><span class="comment">  #Generic</span></span><br><span class="line"><span class="comment">  #JCache (JSR-107)</span></span><br><span class="line"><span class="comment">  #EhCache 2.x</span></span><br><span class="line"><span class="comment">  #Hazelcast</span></span><br><span class="line"><span class="comment">  #Infinispan</span></span><br><span class="line"><span class="comment">  ##Redis</span></span><br><span class="line"><span class="comment">  #Guava</span></span><br><span class="line"><span class="comment">  #Simple</span></span><br></pre></td></tr></table></figure><h4 id="标注注解"><a href="#标注注解" class="headerlink" title="标注注解"></a>标注注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut(value = &quot;employee&quot;,key = &quot;#employeeBean.id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmployeeBean <span class="title">add</span><span class="params">(EmployeeBean employeeBean)</span> </span>&#123;</span><br><span class="line">    employeeDao.insertWithSingle(employeeBean);</span><br><span class="line">    <span class="keyword">return</span> employeeBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;employee&quot;,key = &quot;#employeeBean.id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmployeeBean <span class="title">get</span><span class="params">(EmployeeBean employeeBean)</span> </span>&#123;</span><br><span class="line">    EmployeeBean result=employeeDao.selectWithSingle(employeeBean);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;employee&quot;,key = &quot;#employeeBean.id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmployeeBean <span class="title">del</span><span class="params">(EmployeeBean employeeBean)</span> </span>&#123;</span><br><span class="line">    employeeDao.delete(employeeBean);</span><br><span class="line"><span class="keyword">return</span>  employeeBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Bean的生命周期</title>
      <link href="2021/05/09/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/05/09/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring中Bean的一生从总体上来说可以分为两个阶段：</p><ol><li>容器启动阶段</li><li>Bean实例化阶段</li></ol><h3 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h3><p><img src="/images/spring/Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5.png" alt="Spring容器启动阶段"></p><ol><li>元数据信息：创建对象所需要的必要信息称为配置元信息，如xml、注解</li><li>BeanDefination：元数据信息被加载到内存之后是以BeanDefination的形存在的</li><li>BeanDefinationReader：加载并解析Bean的元数据信息，并将其转化为内存形式的BeanDefination，不同类型的元数据配置信息有不同的BeanDefinationReader，如XmlBeanDefinationReader、PropertiesBeanDefinitionReader、AnnotatedBeanDefinitionReader</li><li>BeanDefinationRegistry：Spring通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination之后，就将其注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination。</li><li>BeanFactoryPostProcessor：BeanFactoryPostProcessor是容器启动阶段Spring提供的一个扩展点，主要负责对注册到BeanDefinationRegistry中的的BeanDefination进行一定程度上的修改与替换。例如我们的配置元信息中有些可能会修改的配置信息散落到各处，不够灵活，修改相应配置的时候比较麻烦，这时我们可以使用占位符的方式来配。BeanFactoryPostProcessor就会对注册到BeanDefinationRegistry中的BeanDefination做最后的修改，替换$占位符为配置文件中的真实的数据。</li></ol><h3 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h3><ol><li>实例化：Spring管理的Bean默认是单例模式， 不支持懒加载，如果要开启懒加载模式工可以使用@Lazy；如果选择懒加载的方式，那么在通过Spring使用该对象实例之前，其都是以BeanDefination的形式存在于BeanDefinationRegistry中，只有在通过Spring使用该对象的时候才开启相应对象的实例化阶段；如果我们不是选择懒加载的方式，容器启动阶段完成之后，将立即启动Bean实例化阶段，通过隐式的调用所有依赖对象的getBean方法来实例化所有配置的Bean并保存起来。</li><li>填充属性：为了统一对不同类型对象的访问，简化使用反射完成相关业务的逻辑，如获取某个对象的属性，调用某个对象的方法，Spring为创建的Bean上封装了BeanWrapper；然后为BeanWrapper对象中的Bean填充属性和设置依赖，对于基本类型的属性，如果配置元信息中有配置，那么将直接使用配置元信息中的设置值赋值即可，即使基本类型的属性没有设置值，那么得益于JVM对象实例化过程，属性依然可以被赋予默认的初始化零值；对于引用类型的属性，Spring会将所有已经创建好的对象放入一个Map结构中，此时Spring会检查所依赖的对象是否已经被纳入容器的管理范围之内，也就是Map中是否已经有对应对象的实例了。如果有，那么直接注入，如果没有,那么Spring会暂时放下该对象的实例化过程，转而先去实例化依赖对象，再回过头来完成该对象的实例化过程。</li><li>检查相关的Aware接口：比较有代表性的Aware接口有BeanNameAware/BeanFactoryAware/ApplicationContextAware接口，如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；<br>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；<br>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>BeanPostProcessor.postProcessBeforeInitialization()：BeanPostProcessor前置处理就是在要生产的Bean实例放到容器之前，允许我们程序员对Bean实例进行一定程度的修改，替换等操作。</li><li>InitializingBean.afterPropertiesSet()方法被调用</li><li>BeanPostPorcessor.postProcessAfterInitialization()被调用</li><li>Bean创建完成，可以使用</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li></ol><p><img src="/images/spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="SpringBean的生命周期"></p><p>对于如上这些方法，我们可以分成如下几类</p><ol><li>Bean自身的方法：比如构造函数、getter/setter以及init-method和destory-method所指定的方法等</li><li>Bean级生命周期方法：可以理解为Bean类直接实现接口的方法，比如BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean等方法，这些方法只对当前Bean生效</li><li>容器级的方法(BeanPostProcessor一系列接口)：主要是后处理器方法，比如上图的InstantiationAwareBeanPostProcessor、BeanPostProcessor接口方法。这些接口的实现类是独立于bean的，并且会注册到Spring容器中。在Spring容器创建任何Bean的时候，这些后处理器都会发生作用。</li><li>工厂后处理器方法（BeanFactoryProcessor一系列接口）：包括AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor等。这些都是Spring框架中已经实现好的BeanFactoryPostProcessor，用来实现某些特定的功能。</li></ol><p>Bean自身的方法和Bean级生命周期方法都只对当前Bean起作用，但是容器级生命周期方法和工厂后处理器方法是对所有的bean都起作用；BeanPostProcessor和BeanFactoryPostProcessor就是Spring创建的扩展点，用户可以创建自己的实现类来修改Bean或者BeanFactory</p><p>注意对于ApplicatonContext来说，容器可以自动检测并加载BeanPostProcessor和BeanFactoryPostProcessor，但是BeanFactory不行，需要自己调用方法手动注册。BeanPostProcessor和BeanFactoryPostProcessor都可以有多个。ApplicationContext也可以根据org.springframework.core.PriorityOrdered和org.springframework.core.Ordered来进行自定义排序，但是BeanFactory不可以，默认顺序就是注册顺序。</p><p>这里说明下面两个容易混淆的单词：</p><p>Instantiation:实例化，指的是调用构造函数进行实例化</p><p>Initialization:初始化，在Bean的声明周期中指的是init-method所指定的方法或者是InitializingBean.afterPropertiesSet()方法</p><p>常用的接口进行说明:</p><ul><li>BeanNameAware该接口只有一个方法setBeanName(String name)，用来获取bean的id或者name</li><li>BeanFactoryAware该接口只有一个方法setBeanFactory(BeanFactory beanFactory)，用来获取当前环境中的BeanFactory</li><li>ApplicationContextAware该接口只有一个方法setApplicationContext(ApplicationContext applicationContext)，用来获取当前环境中的ApplicationContext 获取到IOC容器之后，可以对beans进行修改等操作</li><li>InitializingBean该接口只有一个方法afterPropertiesSet()，在属性注入完成后调用</li><li>DisposableBean该接口只有一个方法destroy()，在容器销毁的时候调用，在用户指定的destroy-method之前调用</li><li>BeanPostProcessor该接口有两个方法：<br>postProcessBeforeInitialization(Object bean, String beanName)：在初始化之前调用此方法<br>； postProcessAfterInitialization(Object bean, String beanName)：在初始化之后调用此方法<br>通过方法签名我们可以知道，我们可以通过beanName来筛选出我们需要进行个性化定制的bean</li><li>InstantiationAwareBeanPostProcessor<br>该类是BeanPostProcessor的子接口，常用的有如下三个方法<br>postProcessBeforeInstantiation(Class beanClass, String beanName)：在bean实例化之前调用<br>postProcessProperties(PropertyValues pvs, Object bean, String beanName)：在bean实例化之后、设置属性前调用<br>postProcessAfterInstantiation(Class beanClass, String beanName)：在Bean实例化之后调用</li></ul><blockquote><p>引用</p><p><a href="https://blog.csdn.net/kxkxyzyz/article/details/105817176">https://blog.csdn.net/kxkxyzyz/article/details/105817176</a></p><p><a href="https://juejin.cn/post/6929672218322731022">https://juejin.cn/post/6929672218322731022</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP</title>
      <link href="2021/05/08/Spring-AOP/"/>
      <url>2021/05/08/Spring-AOP/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，是代理模式的典型应用，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><ol><li><p>切面（Aspect）：分布在应用程序中多个位置的标准代码/功能</p></li><li><p>连接点（Join point）：这是程序执行中的特定点，如方法执行，构调用造函数或字段赋值等</p></li><li><p>通知（Advice）：切面采取的行动</p></li><li><p>切入点（Pointcut）：通知的执行点，或者说是执行点的集合，定义的切点会匹配通知到所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p></li><li><p>目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p></li><li><p>织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。</p><p>在目标对象的生命周期里有多个点可以进行织入：</p><ol><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ol></li></ol><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>同一个aspect，不同advice的执行顺序：</li></ul><h3 id="AOP实现方式"><a href="#AOP实现方式" class="headerlink" title="AOP实现方式"></a>AOP实现方式</h3><p>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ AOP；动态代理则以Spring AOP为代表。</p><ol><li>AspectJ是静态代理的增强，AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</li><li>Spring AOP使用的动态代理，AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li></ol><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a><strong>Spring AOP</strong></h4><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</li></ul><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><ul><li>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMvc </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-循环依赖</title>
      <link href="2021/05/07/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>2021/05/07/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p><p>Spring中循环依赖场景有：</p><ol><li>构造器的循环依赖</li><li>field属性的循环依赖。</li></ol><p>结论：</p><ul><li>构造方法中相互依赖的情况Spring无法解决</li><li>field属性的循环依赖Spring可以解决</li></ul><h3 id="检测循环依赖"><a href="#检测循环依赖" class="headerlink" title="检测循环依赖"></a>检测循环依赖</h3><p>Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p><h3 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h3><p>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p><p>Spring的单例对象的初始化主要分为三步：</p><p><img src="/images/spring/bean%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="bean初始化"></p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</li><li>initializeBean：调用spring xml中的init 方法。</li></ol><p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。</p><p>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>这三级缓存分别指：</p><ul><li>singletonFactories ： 单例对象工厂的cache</li><li>earlySingletonObjects ：提前暴光的单例对象的Cache</li><li>singletonObjects：单例对象的cache</li></ul><p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码需要解释两个参数：</p><ul><li>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)</li><li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li></ul><p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br></pre></td></tr></table></figure><p>从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p><p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口在下面被引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/u010853261/article/details/77940767">https://blog.csdn.net/u010853261/article/details/77940767</a></p><p><a href="https://www.jianshu.com/p/6c359768b1dc">https://www.jianshu.com/p/6c359768b1dc</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-事务管理</title>
      <link href="2021/05/06/Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>2021/05/06/Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><h3 id="事物的特性（ACID）"><a href="#事物的特性（ACID）" class="headerlink" title="事物的特性（ACID）"></a>事物的特性（ACID）</h3><p><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致；</p><p><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</p><p><strong>持久性（Durability）:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h3 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h3><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h3 id="Spring事务的实现方式"><a href="#Spring事务的实现方式" class="headerlink" title="Spring事务的实现方式"></a>Spring事务的实现方式</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h3 id="Spring的事务传播行为"><a href="#Spring的事务传播行为" class="headerlink" title="Spring的事务传播行为"></a>Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当事务方法被另一个事务方法调用时，即多个事务同时存在的时候，spring如何处理这些事务的行为。</p><ol><li> PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li> PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li> PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li> PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li> PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</li></ol><h3 id="spring的事务隔离级别"><a href="#spring的事务隔离级别" class="headerlink" title="spring的事务隔离级别"></a>spring的事务隔离级别</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ol><li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p></li><li><p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p></li><li><p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p></li><li><p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p></li><li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p></li></ol><ul><li>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li>不可重复读 ：是指在一个事务内，多次读同一数据。</li><li>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li></ul><h3 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h3><ul><li>PlatformTransactionManager：（平台）事务管理器，Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给提供持久化机制的相关平台的事务来实现。 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager ，由各个平台自己实现这个接口</li><li>TransactionDefinition： 这个类就定义了一些基本的事务属性，可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上，具体包含了5个方面。事务隔离级别、传播行为、超时、只读、回滚规则</li><li>TransactionStatus：事务运行状态</li></ul><p><strong>PlatformTransactionManager</strong> </p><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给提供持久化机制的相关平台的事务来实现。 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager ，由各个平台自己实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </span><br><span class="line">   <span class="comment">// 提交</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">   <span class="comment">// 回滚</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br></pre></td></tr></table></figure><p><strong>TransactionDefinition</strong></p><p>这个类就定义了一些基本的事务属性，事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TransactionStatus</strong></p><p>TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="事务处理流程"><a href="#事务处理流程" class="headerlink" title="事务处理流程"></a>事务处理流程</h3><p>Spring事务采用AOP的方式实现，我们从TransactionAspectSupport这个类开始f分析。</p><ol><li><p>获取事务的属性（@Transactional注解中的配置）</p></li><li><p>加载配置中的TransactionManager.</p></li><li><p>获取收集事务信息TransactionInfo</p></li><li><p>执行目标方法</p></li><li><p>出现异常，尝试处理。</p></li><li><p>清理事务相关信息</p></li><li><p>提交事务</p></li></ol><blockquote><p>引用<br><a href="https://blog.csdn.net/weixin_44366439/article/details/89030080">https://blog.csdn.net/weixin_44366439/article/details/89030080</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-设计模式</title>
      <link href="2021/05/05/Spring-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/05/Spring-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式也称为静态工厂模式，工厂类一般采用静态方法，根据接收的参数不同来确定返回对象实例，但简单工厂模式违反了开闭原则，要增加一个新的类别必须要修改代码。注意，简单工厂模式针对一个项目或者一个独立模块只有一个工厂类，而工厂方法模式是有一组实现了相同接口的工厂类（虽然符合开闭原则，但是会增加新的类来扩展，看情况而定，实际上在项目开发中通常还是用简单工厂比较多）</p><p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，另外是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>可以看做是简单工厂模式的升级版；工厂方法模式就是一个工厂接口和多个工厂实现类，要增加一个新的产品，增加一个新的工厂实现类即可，针对之前的老的工厂实现类也不需要修改；工厂方法模式相当于在简单工厂模式的基础上，增加了对于不同的产品进行多个不同工厂的实现类的添加，不同的工厂用于Get不同的产品，用于进行不同产品的具体生产；在Spring中的实现就是FactoryBean</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在Spring中，bean可以被定义为两种模式：prototype（多例）和singleton（单例）</p><ul><li><p>singleton（单例）：只有一个共享的实例存在，所有对这个bean的请求都会返回这个唯一的实例；Spring bean 默认是单例模式。</p></li><li><p>prototype（多例）：对这个bean的每次请求都会创建一个新的bean实例，类似于new。</p></li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式的作用主要是将一个类的转接口转换成客户希望的另外一个接口，使得原来由于接口不兼容的而不能的工作的那些类可以工作；Spring AOP 的实现是基于代理模式的，但是 Spring AOP 的增强和通知 ( Advice ) 使用到了适配器模式来增强被代理类的功能；</p><p>Advice的类型有：BeforeAdvice、AfterReturningAdvice、ThreowSadvice；</p><p>每种Advice都有对应的拦截器：MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor；</p><p>与之相关的接口是 AdvisorAdapter，Spring 预定义的通知要通过对应的适配器，适配成 MethodInterceptor 接口 ( 方法拦截器 ) 类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。</p><p>另外在Spring MVC 中也使用了适配器模式，DispatcherServlet通过HandlerMapping找到相应的Controllert  处理器后,再通过HandlerAdapter适配器去调用处理器的方法完成请求的处理</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>spring中用到的装饰器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 </p><p>在 Spring 中，TransactionAwareCacheDecorator 类相当于装饰器模式中的抽象装饰角色，主要用来处理事务缓存，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Create a new TransactionAwareCache for the given target Cache.</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> targetCache the target Cache to decorate</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransactionAwareCacheDecorator</span><span class="params">(Cache targetCache)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(targetCache, <span class="string">&quot;Target Cache must not be null&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.targetCache = targetCache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Return the target Cache that this Cache should delegate to.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getTargetCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.targetCache;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来看一个 MVC 中的装饰器模式：HttpHeadResponseDecorator 类，相当于装饰器模式中的具体装饰角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHeadResponseDecorator</span> <span class="keyword">extends</span> <span class="title">ServerHttpResponseDecorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpHeadResponseDecorator</span><span class="params">(ServerHttpResponse delegate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理以控制对这个对象的访问。 从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。<br>spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 </p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 </p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>spring中在实例化对象的时候用到Strategy模式<br>在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： </p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-核心注解</title>
      <link href="2021/05/04/Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/"/>
      <url>2021/05/04/Spring-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>@Controller：标注一个控制器组件类。标识一个该类是Spring MVC controller处理器，用来创建处理http请求的对象。组合注解（组合了@Component注解），应用在MVC层（控制层）</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p><code>Spring4</code>之后加入的注解，原来在<code>@Controller</code>中返回<code>json</code>需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式。</p><h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>@Service 把类当做容器中的一个组件来使用。 当使用@Autowired注解则是实例化构造器。因为在自动注入时，是一个接口类型，所以要在容器中找到相应的实现类注入。故@Service加到类上。组合注解（组合了@Component注解），应用在service层（业务逻辑）。</p><h3 id="Reponsitory"><a href="#Reponsitory" class="headerlink" title="@Reponsitory"></a>@Reponsitory</h3><p>@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。为什么 @Repository 只能标注在 DAO 类上呢？这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。组合注解（组合了@Component注解），应用在DAO层（数据访问层）。</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>把普通pojo实例化到spring容器中，相当于配置文件中的，表示一个带注释的类的一个”组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>@Configuration作用在类上，声明一个class需要被spring解析以扩充beanDefinition。 @Configration注解同时被@Component注解修饰，因此具有被自动加载的特点，被@Configuration修饰的类本身也会作为definition注册。value属性是Configuration bean名称。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>这个注解属于J2EE的。<code>@Resource</code>的作用相当于<code>@Autowired</code>，只不过<code>@Autowired</code>按<code>byType</code>自动注入，而<code>@Resource</code>默认按 <code>byName</code>自动注入罢了。<code>@Resource</code>有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>@Resource装配顺序</p><ol><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</li><li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li></ol><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。 SpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>值的注入。经常与Spring EL表达式语言一起使用，注入普通字符，系统属性，表达式运算结果，其他Bean的属性，文件内容，网址请求内容，配置文件属性值等等。 主要两种使用方法：</p><ul><li>@Value(“#{configProperties[‘key’]}”) 用于获取配置对象属性的值</li><li>@Value(“${key}”) 用于获取配置文件中的值</li></ul><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><p>指定文件地址。提供一种方便的、声明性的机制，用于向Spring环境添加PropertySource。与@Configuration类一起使用。在app项目中，我们通过@PropertySource注解到JavaConfig类上，设置.properties配置文件的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;demo.msg&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>用于读取 Request 请求的 body 部分并且Content-Type 为 application/json格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody注解表示该方法的返回的结果直接写入HTTP响应正文中（ResponseBody），一般在异步获取数据时使用，通常是在使用@RequestMapping后。返回值通常解析为跳转路径，加上@ResponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP响应正文中。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>使用 @RequestMapping 来映射 Request请求与处理器，通过这个注解可以定义不同的处理器映射规则，即为控制器指定可以处理哪些URL请求。</p><p>用@RequestMapping来映射URL 到控制器类，或者是到Controller控制器的处理方法上。 当@RequestMapping标记在Controller类上的时候，里面使用@RequestMapping标记的方法的请求地址都是相对于类上的@RequestMapping 而言的； 当Controller 类上没有标记@RequestMapping注解时，方法上的@RequestMapping都是绝对路径。这种绝对路径和相对路径所组合成的最终路径都是相对于根路径“/ ”而言的。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>@SpringBootApplication是一个组合注解 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">  excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;),    </span></span><br><span class="line"><span class="meta">@Filter( type = FilterType.CUSTOM,classes = &#123;AutoConfigurationExcludeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，主要包含三个注解@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><ul><li>@ComponentScan（包扫描）component是组件，scan是扫描，所以这个注解的含义就是用来扫描组件的</li><li>ComponentScan就是扫描所标注的类所在包下的所有需要注入的组件，将其注入，这里他是在@SpringBootApplication 中体现的，所以这个注解会自动注入所有在主程序所在包下的组件</li><li>以前在ssm项目中我们需要去配置我们的包扫描,相对应的XML配置就是context:component-scan/， 将符合条件的组件加入到IOC容器中。</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@EnableAutoConfiguration表示开启自动装配，注解主要作用从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中的org.spring-framework.boot.autoconfigure.EnableAutoConfiguration对应的配置项通过反射实例化为对应的标注了@Configuration的javaConfig形式的IOC容器配置类，然后汇总为一整个并加载到IOC容器。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">  String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个比较重要的注解@AutoConfigurationPackage与@Import({AutoConfigurationImportSelector.class})</p><ul><li>@AutoConfigurationPackage表示获取我们注解所在包下的组件去进行注册</li><li>@Import({AutoConfigurationImportSelector.class})表示自动配置导入选择器，从META-INF/spring.factories获取我们的自动配置信息的</li></ul><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>将properties属性与一个Bean及其属性相关联，从而实现类型安全的配置。例如：@ConfigurationProperties(prefix=”connection”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span><span class="comment">// lombok注解，相关知识可以自行查阅</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;connection&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String remoteAddress;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnBean与-ConditionalOnMissingBean"><a href="#ConditionalOnBean与-ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnBean与@ConditionalOnMissingBean"></a>@ConditionalOnBean与@ConditionalOnMissingBean</h3><p>@ConditionalOnBean与@ConditionalOnMissingBean两个注解都是条件注解,作用相反。</p><ul><li>@ConditionalOnBean表示存当给定的在bean存在时,则实例化当前Bean。</li><li>@ConditionalOnMissingBean表示当给定的在bean不存在时,则实例化当前Bean。</li></ul><h3 id="ConditionalOnClass与-ConditionalOnMissingClass"><a href="#ConditionalOnClass与-ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnClass与@ConditionalOnMissingClass"></a>@ConditionalOnClass与@ConditionalOnMissingClass</h3><p>@ConditionalOnClass与@ConditionalOnMissingClass这两个注解与@ConditionalOnBean与@ConditionalOnMissingBean两个注解相似。</p><ul><li>@ConditionalOnClass 表示当给定的类名在类路径上存在，则实例化当前Bean</li><li>@ConditionalOnMissingClass 表示当给定的类名在类路径上不存在，则实例化当前Bean</li></ul><h3 id="PathVariable-和-RequestParam"><a href="#PathVariable-和-RequestParam" class="headerlink" title="@PathVariable 和 @RequestParam"></a>@PathVariable 和 @RequestParam</h3><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/stu/list/&#123;userId&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">list</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span>Long userId,<span class="meta">@RequestParam(value = &quot;type&quot;,required = false)</span> String type)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果我们请求的 url 是：/stu/list/20?type=tea</p><p>那么我们服务获取到的数据就是：userId=20,type=tea。</p><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><ol><li><p>全局异常处理（ @ExceptionHandler）</p><p>使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">customException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;myerror&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来</p></li><li><p>全局数据绑定（ @ModelAttribute）</p><p>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。</p><p>默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.name=<span class="string">&quot;小喵&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>  cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = model.asMap();</span><br><span class="line">        Object cat = map.get(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>全局数据预处理（@InitBinder）</p><p>作用：对HTTP请求参数进行预处理，再绑定到对应的接口。这里我们就可以对参数做一些额外的处理，比如时间格式的转换等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBindeer</span><span class="params">(WebDataBinder webDataBinder)</span> </span>&#123;</span><br><span class="line">        webDataBinder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>), <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>@ExceptionHandler :注解声明异常处理方法</p><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</p><p>我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。@Transactional注解一般用在可以作用在类或者方法上。</p><ul><li>作用于类：当把@Transactional 注解放在类上时，表示所有该类的public 方法都配置相同的事务属性信息。</li><li>作用于方法：当类配置了@Transactional，</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-核心类</title>
      <link href="2021/05/03/Spring-%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
      <url>2021/05/03/Spring-%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h3><p>BeanNameAware的setBeanName() 会被调用设置该 bean 在 Bean Factory 中的名称</p><h3 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h3><p>BeanFactoryAware的setBeanFactory() 会被调用为 bean 实例提供其所拥有的 factory</p><span id="more"></span><h3 id="ApplicationContextAware"><a href="#ApplicationContextAware" class="headerlink" title="ApplicationContextAware"></a>ApplicationContextAware</h3><p>实现ApplicationContextAware接口后，Spring容器会自动把上下文环境对象通过调用ApplicationContextAware接口中的setApplicationContext方法，自动的将ApplicationContext注入到ApplicationContextAware的实现类中，然后通过实现类就可以通过这个上下文环境对象得到Spring容器中的Bean。</p><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>Spring bean的后处理器，允许自定义修改Spring 容器创建的新bean实例，如果你想在Spring容器完成实例化、配置和初始化bean之后实现一些定制逻辑，我们可以插入一个或多个BeanPostProcessor实现。如果有多个BeanPostProcessor实例，我们可以通过设置order属性或实现Ordered接口来控制执行顺序。BeanPostProcessor接口由两个回调方法组成，即postprocessbeforeinitialize()和postprocessafterinitialize()。</p><p>对于由容器创建的每个bean实例，BeanPostProcessor都会在调用当前Bean初始化方法之前以及初始化之后,调用postProcessorBeforeInitialize()和postProcessorAfterInitialize();</p><h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><p>InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。</p><p>在SpringMVC中AbstractHandlerMethodMapping就实现了InitializingBean接口，当一个RequestMappingHandlerMapping的实例创建完成后会接着调用afterPropertiesSet方法，扫描所有的controller完成所有的handler method的注册。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory是Spring容器中的一个基本类也是很重要的一个类，在BeanFactory中可以创建和管理Spring容器中的Bean，它对于Bean的创建有一个统一的流程。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean是一个接口，实现这个接口的Bean是工厂的Bean，方法getObject()返回的对象，不是FactoryBean本身,而是自定义实现的Bean，这个Bean同时也纳入到了Spring容器的管理中，如果要获取FactoryBean对象本身，请在id前面加一个&amp;符号来获取。因此，FactoryBean作用就是可以让我们自定义Bean的创建过程，创建一些比较复杂的Bean<br>很多开源项目在集成Spring 时都使用到FactoryBean，比如 MyBatis3 提供 mybatis-spring项目中的 org.mybatis.spring.SqlSessionFactoryBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回的对象实例</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//Bean的类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="comment">//true是单例，false是非单例  在Spring5.0中此方法利用了JDK1.8的新特性变成了default方法，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanFactoryPostProcessor接口中只有一个方法postProcessBeanFactory，该方法在spring容器初始化后,bean实例化之前，BeanDefinition读取完之后，并且只执行一次，这里可以获取到BeanDefinition，在Bean实例化之前可以修改BeanDefinition</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-过滤器-拦截器-AOP</title>
      <link href="2021/05/02/Spring-%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%8B%A6%E6%88%AA%E5%99%A8-AOP/"/>
      <url>2021/05/02/Spring-%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%8B%A6%E6%88%AA%E5%99%A8-AOP/</url>
      
        <content type="html"><![CDATA[<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>过滤器&gt;拦截器&gt;aop&gt;aop&gt;拦截器&gt;过滤器</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>实现Filter接口，重写doFilter方法</p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>实现HandlerInterceptor接口，重写preHandle、postHandle、afterCompletion方法，在配置文件中添加拦截器配置</p><p>preHandle：在请求处理之前进行调用</p><p>postHandle：在请示处理完之后，视图渲染之前调用</p><p>afterCompletion：整个请求结束之后被调用</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.example.springboot_aop.*.*.index(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroud</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud前&quot;</span>);</span><br><span class="line">        Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud后&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>  proceed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h4><p>依赖于Servlet容器，利用Java的回调机制进行实现</p><h4 id="拦截器-1"><a href="#拦截器-1" class="headerlink" title="拦截器"></a>拦截器</h4><p>基于Java的反射机制实现，不依赖Servlet容器。</p><h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><p>基于代理模式，可以在任何方法之前和之后做一些其他事</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-单例Bean的线程安全问题</title>
      <link href="2021/05/01/Spring-%E5%8D%95%E4%BE%8BBean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>2021/05/01/Spring-%E5%8D%95%E4%BE%8BBean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Spring的bean默认都是单例的，某些情况下，单例是并发不安全的，以Controller举例，问题根源在于，我们可能会在Controller中定义成员变量，如此一来，多个请求来临，进入的都是同一个单例的Controller对象，并对此成员变量的值进行修改操作，因此会互相影响，无法达到并发安全。<br>首先来举个例子，证明单例的并发不安全性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="单例变原型"><a href="#单例变原型" class="headerlink" title="单例变原型"></a>单例变原型</h4><p>对web项目，可以Controller类上加注解<code>@Scope(&quot;prototype&quot;)</code>或<code>@Scope(&quot;request&quot;)</code>，对非web项目，在Component类上添加注解<code>@Scope(&quot;prototype&quot;)</code>。</p><p>优点：实现简单；</p><p>缺点：很大程度上增大了bean创建实例化销毁的服务器资源开销。</p><h4 id="线程隔离类ThreadLocal"><a href="#线程隔离类ThreadLocal" class="headerlink" title="线程隔离类ThreadLocal"></a>线程隔离类ThreadLocal</h4><p>将成员变量包装为ThreadLocal，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; i = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="meta">@GetMapping(&quot;testsingleton1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            i.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i.set(i.get().intValue() + <span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>, Thread.currentThread().getName(), i.get());</span><br><span class="line">        <span class="keyword">return</span> i.get().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试后发现，ThreadLocalg还是无法达到线程安全，这是因为web服务器用到了线程池技术，而线程池中的核心线程是可以重复利用的</p><h4 id="使用并发安全的类"><a href="#使用并发安全的类" class="headerlink" title="使用并发安全的类"></a>使用并发安全的类</h4><p>使用并发安全的容器，如ConcurrentHashMap、ConcurrentHashSet及Atomic开头的原子类，将我们的成员变量包装到这些并发安全的容器中进行管理即可。</p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>spring bean作用域有以下5个：</p><ul><li><code>singleton</code>：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；</li><li><code>prototype</code>：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；</li></ul><p>（下面是在web项目下才用到的）</p><ul><li><code>request</code>：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；</li><li><code>session</code>：每次会话，同上；</li><li><code>global session</code>：全局的web域，类似于servlet中的application。</li></ul><blockquote><p>来源</p><p><a href="https://blog.csdn.net/songzehao/article/details/103365494">https://blog.csdn.net/songzehao/article/details/103365494</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper-基础理论</title>
      <link href="2021/04/28/zookeeper-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>2021/04/28/zookeeper-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>ZooKeeper 是一个开源的分布式协调服务，一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><p>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。</p><p>ZooKeeper 是高性能的，因为ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟；</p><p>ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上</p><h4 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h4><p>Session 指的是 ZooKeeper  服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的<code>sessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在```sessionTimeout`规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p><h4 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h4><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</p><p>Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><p>在Zookeeper中，node可以分为持久节点和临时节点两类。</p><p><strong>四种类型的数据节点 Znode</strong></p><ul><li><p>PERSISTENT-持久节点</p><p>除非手动删除，否则节点一直存在于 Zookeeper 上</p></li><li><p>EPHEMERAL-临时节点</p><p>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p></li><li><p>PERSISTENT_SEQUENTIAL-持久顺序节点</p><p>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p></li><li><p>EPHEMERAL_SEQUENTIAL-临时顺序节点</p><p>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p></li></ul><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个ZNode，Zookeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat中记录了这个 ZNode 的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和 cversion（当前ZNode的ACL版本）。</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p><p>工作机制：</p><ul><li>客户端注册 watcher</li><li>服务端处理 watcher</li><li>客户端回调 watcher</li></ul><p>Watcher 特性总结：</p><ul><li><p>一次性：无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p></li><li><p>客户端串行执行：客户端 Watcher 回调的过程是一个串行同步的过程。</p></li><li><p>轻量</p><ul><li><p>Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</p></li><li><p>客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</p></li></ul></li><li><p>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</p></li></ul><ul><li>注册 watcher getData、exists、getChildren</li></ul><ul><li>触发 watcher create、delete、setData</li></ul><ul><li>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</li></ul><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限。</p><p><img src="/images/zookeeper/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.png" alt="权限控制"></p><p>其中尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>集群角色：Leader （领导）Follower （追随者）Observer （观察员）</p><p>一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer。Leader服务器为客户端提供读和写服务。Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于， Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因 此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty-基础理论</title>
      <link href="2021/04/28/netty-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>2021/04/28/netty-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h4><ul><li>同步，一个任务的完成之前不能做其他操作，必须等待（等于在打电话）</li><li>异步，一个任务的完成之前，可以进行其他操作（等于在聊QQ）</li><li>阻塞，是相对于CPU来说的， 挂起当前线程，不能做其他操作只能等待</li><li>非阻塞,，无须挂起当前线程，可以去执行其他操作  </li></ul><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步并阻塞，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一<br>个线程进行处理，没处理完之前此线程不能做其他操作（如果是单线程的情况下，我传输的文件很<br>大呢？），当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方<br>式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理<br>解。  </p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>同步非阻塞，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用<br>器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多<br>且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4<br>之后开始支持</p><h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><p>Channel是一个对象，可以通过它读取和写入数据。 通常我们都是将数据写入包含一个或者多个字节的缓冲区，然后再将缓存区的数据写入到通道中，将数据从通道读入缓冲区，再从缓冲区获取<br>数据。<br>Channel 类似于原I/O中的流（Stream），但有所区别：<br>流是单向的，通道是双向的，可读可写。<br>流读写是阻塞的，通道可以异步读写</p><h5 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h5><p>Selector可以称他为通道的集合，每次客户端来了之后我们会把Channel注册到Selector中并且我<br>们给他一个状态，在用死循环来判断( 判断是否做完某个操作，完成某个操作后改变不一样的状态 )状<br>态是否发生变化，知道IO操作完成后在退出死循环  </p><h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p>Buffer 是一个缓冲数据的对象， 它包含一些要写入或者刚读出的数据。<br>在普通的面向流的 I/O 中，一般将数据直接写入或直接读到 Stream 对象中。当是有了Buffer（缓<br>冲区）后，数据第一步到达的是Buffer（缓冲区）中<br>；缓冲区实质上是一个数组。通常它是一个字节数组，<br>内部维护几个状态变量，可以实现在同一块缓冲区上反复读写（不用清空数据再写）。</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由操作系统<br>先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操<br>作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK1.7之后开<br>始支持。.<br>AIO属于NIO包中的类实现，其实IO主要分为BIO和NIO，AIO只是附加品，解决IO不能异步的实现<br>在以前很少有Linux系统支持AIO，Windows的IOCP就是该AIO模型。但是现在的服务器一般都是<br>支持AIO操作  </p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>BIO是阻塞的，NIO是非阻塞的.</li><li>BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写</li><li>使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影<br>响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线<br>程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，<br>使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接</li><li>AIO是非阻塞 以异步方式发起 I/O 操作。当 I/O 操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成</li></ul><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>Netty是由JBOSS提供的一个Java开源，用于创建高性能网络应用程序的高级框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、 UDP 和文件传输的支持</li><li>使用更高效的 socket 底层，对 epoll 空轮询引起的 cpu 占用飙升在内部进行了处理，避免了<br>直接使用 NIO 的陷阱，简化了 NIO 的处理方式。</li><li>采用多种 decoder/encoder 支持，对 TCP 粘包/分包进行自动化处理</li><li>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持</li><li>可配置 IO 线程数、 TCP 参数， TCP 接收和发送缓冲区使用直接内存代替堆内存，通过内存<br>池的方式循环利用 ByteBuf</li><li>通过引用计数器及时申请释放不再引用的对象，降低了 GC 频率</li><li>使用单线程串行化的方式，高效的 Reactor 线程模型</li><li>大量使用了 volitale、使用了 CAS 和原子类、线程安全类的使用、读写锁的使用</li></ul><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化。</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</li></ul><h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池， boss<br>线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept<br>事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其<br>中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。  </p><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>所有 I/O 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求<br>或应答/响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若<br>线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请<br>求； NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送； 1 个 NIO 线程可<br>以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作<br>问题。但在并发百万客户端连接或需要安全认证时， 一个 Acceptor 线程可能会存在性能不<br>足问题  </p><h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><p>Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从<br>主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处<br>理 I/O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作；  </p><h3 id="TCP粘包-拆包"><a href="#TCP粘包-拆包" class="headerlink" title="TCP粘包/拆包"></a>TCP粘包/拆包</h3><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能<br>把小的封装成一个大的数据包发送。  </p><ol><li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li><li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li><li>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li></ol><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><img src="/images/netty/NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B.png" alt="NIO零拷贝过程"></p><p><strong>使用NIO零拷贝，流程简化为两步：</strong></p><ol><li>transferTo方法调用触发DMA引擎将文件上下文信息拷贝到内核读缓冲区，接着内核将数据从内核缓冲区拷贝到与套接字相关联的缓冲区。</li><li>DMA引擎将数据从内核套接字缓冲区传输到协议引擎（第三次数据拷贝）。</li></ol><p><strong>传统IO读取数据并通过网络发送的流程，如下图</strong></p><p><img src="/images/netty/%E4%BC%A0%E7%BB%9FIO%E8%BF%87%E7%A8%8B.png" alt="传统IO过程"></p><ol><li>read()调用导致上下文从用户态切换到内核态。内核通过sys_read()（或等价的方法）从文件读取数据。DMA引擎执行第一次拷贝：从文件读取数据并存储到内核空间的缓冲区。</li><li>请求的数据从内核的读缓冲区拷贝到用户缓冲区，然后read()方法返回。read()方法返回导致上下文从内核态切换到用户态。现在待读取的数据已经存储在用户空间内的缓冲区。至此，完成了一次IO的读取过程。</li><li>send()调用导致上下文从用户态切换到内核态。第三次拷贝数据从用户空间重新拷贝到内核空间缓冲区。但是，这一次，数据被写入一个不同的缓冲区，一个与目标套接字相关联的缓冲区。</li><li>send()系统调用返回导致第四次上下文切换。当DMA引擎将数据从内核缓冲区传输到协议引擎缓冲区时，第四次拷贝是独立且异步的。</li></ol><blockquote><p>DMA拷贝即直接内存存取，原理是外部设备不通过CPU而直接与系统内存交换数据；磁盘到内核空间属于DMA拷贝，用户空间与内核空间之间的数据传输并没有类似DMA这种可以不需要CPU参与的传输方式，因此用户空间与内核空间之间的数据传输是需要CPU全程参与的</p><p>NIC：网络接口控制器，即网卡</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-原理</title>
      <link href="2021/04/24/mybatis-%E5%8E%9F%E7%90%86/"/>
      <url>2021/04/24/mybatis-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 对象为数据库中的记录。</p><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h3 id="核心关键类"><a href="#核心关键类" class="headerlink" title="核心关键类"></a>核心关键类</h3><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>根据配置文件,通过SqlSessionFactory可以构建了SqlSessionFactory</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>Mybatis的配置文件与映射文件通过解析后会封装成一个Configuration对象</p><h4 id="MappedStatement"><a href="#MappedStatement" class="headerlink" title="MappedStatement"></a>MappedStatement</h4><p>在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，MappedStatement与Mapper映射文件中的一个select/update/insert/delete节点相对应，每一个sql会在初始化配置文件的过程中解析封装成一个MappedStatement对象，存储在Configuration对象的mappedStatements属性中，mappedStatements是一个HashMap，存储是key为全限定名+类名+方法名，value为对应的MappedStatement对象    </p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>通过SqlSessionFactory可以构建出SqlSession</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>通过开启一个SqlSession，可以在这个传话里，通过处理器Executor来执行各种sql</p><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>MyBatis 底层定义了一个 Executor 接口来操作数据库，内置的Executor有3种，默认为simple。它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p><ul><li><p>BatchExecutor</p><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p></li><li><p>ReuseExecutor</p></li></ul><p>​        执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭                Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用                           </p><p>​        Statement对象。</p><ul><li>SimpleExecutor</li></ul><p>​        每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>主要过程：</strong></p><ol><li><p>解析mybatis-config配置文件和映射文件封装成一个configuration对象</p></li><li><p>通过SqlsessionFactoryBuilder，加载解析环境配置信息，构建出SqlSessionFactory</p></li><li><p>通过SqlSessionFactory创建SqlSession，sqlsession对象包含了执行sql语句的方法</p></li><li><p> 通过sqlsession执行数据库操作:</p></li></ol><p>   Mybatis默认情况下，将对所有的 SQL 进行预编译，即数据库驱动在发送 SQL 语句和参数给 数据库之前对 SQL 语句进行编译，这样数据库在执行SQL时，不需要重新编译，通过预编译可以优化SQL执行，预编译语句对象PreparedStatement可以缓存下来重复利用</p><ol start="5"><li><p>执行完sql语句，调用session.commit()提交事务</p></li><li><p>最后调用session.close()关闭会话</p></li></ol><p><img src="/images/mybatis/mybatis%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="MyBatis工作原理"></p><h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src="/images/mybatis/mybatis%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Mybatis功能框架"></p><p>我们把Mybatis的功能架构分为三层：</p><p>API接口层：提供给外部使用的接口API，开发人员可以通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p><p>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p><p>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。<br>MyBatis的框架架构设计是怎么样的</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>#{}和${}的区别</strong></p><p>#{}是占位符，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值，#{} 对应的变量也会自动加上单引号 ， 可以有效的防止SQL注入</p><p>${}是拼接符，字符串替换，就是把{}替换成变量的值，没有预编译处理，相当于JDBC中的Statement编译，${} 对应的变量不会加上单引号，有SQL 注入风险</p><p><strong>mapper接口里的方法是否可以重载</strong></p><p>不可以。因为mapper接口里的方法，与映射文件里的id同名的sql是一对一对应关系，在mybatis初始化的时候，映射文件里的sql会被解析封装成一个MappedStatement对象存储到一个Map里，这个Map的key是mapper接口的全限定名+方法名，value是封装后的MappedStatement对象，在sql被执行的前，会通过JDK的动态代理，根据mapper接口生成代理对象，拦截接口的方法，从根据key从map中取出MappedStatemen对象执行sql，所以mapper接口的方法不可以重载。</p><p><strong>Mybatis是如何进行分页的</strong></p><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p><strong>分页插件的原理是什么</strong></p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><p>简述Mybatis的插件运行原理，以及如何编写一个插件。<br>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p></li><li><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p></li><li><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></li></ul><blockquote><p>引用<br><a href="https://blog.csdn.net/ThinkWon/article/details/101292950">https://blog.csdn.net/ThinkWon/article/details/101292950</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Get与Post</title>
      <link href="2021/04/21/Get%E4%B8%8EPost/"/>
      <url>2021/04/21/Get%E4%B8%8EPost/</url>
      
        <content type="html"><![CDATA[<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>GET 用于从指定资源请求数据，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的。</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据（不修改）</li></ul><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><p>POST 用于将数据发送到服务器来创建/更新资源，通过 POST 发送到服务器的数据存储在 HTTP 请求的请求主体中。</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><p>GET和POST是HTTP协议中的两种发送请求的方法；HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议；HTTP的底层是TCP/IP；所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接；对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此有人推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎：</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> get </tag>
            
            <tag> post </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菩萨畏因-凡夫畏果</title>
      <link href="2021/04/20/%E8%8F%A9%E8%90%A8%E7%95%8F%E5%9B%A0-%E5%87%A1%E5%A4%AB%E7%95%8F%E6%9E%9C/"/>
      <url>2021/04/20/%E8%8F%A9%E8%90%A8%E7%95%8F%E5%9B%A0-%E5%87%A1%E5%A4%AB%E7%95%8F%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>人们都喜欢探讨命运，什么是命运呢？命运就是因果，要谈命运就要谈佛教的因果律。</p><p>佛教认为，世间一切事物的生灭，都由因果律支配着。所谓有因必有果，我们能看到“种瓜得瓜，种豆得豆”这种司空见惯的现象，却永远不会看到“种瓜得豆，种豆得瓜”这种违背因果律的事情。因果律乃是佛教的基石理论之一。</p><p>因果律告诉我们，现在出现的结果，必然是以前所造之因导致的。现在所造的种种因，又必然影响到未来的结果。古德有云“欲知前世因，今生受者是；欲知来世果，今生作者是”，说的就是这个道理。因此，对于人的命运，我们并不需要去开种种神通（天眼、天耳等神通）去获知。命好福深之人，必然是之前造了善因，此生得以感善果。而命运不济之人，必然是之前造了恶业，此生感得恶果所致。</p><p>对于凡夫而言，往往只是注重结果。当困难到来之时，只是忧愁这种结果。当严重的疾病到来之时，则是对于疾病这种结果产生恐惧。总之，对于种种不如意的结果，凡夫往往只是看到“结果”这个层面。而对于已经成事实的结果，又无力改变，只能产生忧愁、痛苦、恐惧等负面情绪。因此，凡夫往往只是“畏果”的。对于菩萨而言，则首先不会去考虑结果，而是去考虑原因。</p><p>与凡夫不同，菩萨是“畏因”的。菩萨对于因果律了然于心，知道“因”是根本，“果”只是后续的自然现象而已。因此菩萨行事，着眼之处，无非是防止造诸恶因。凡夫则不然，在造诸因的过程之中，没有注重诸因；只是等到不良的结果出现之后，才开始恐惧结果。有的人会抱着侥幸的心理：在无数的“因”之中，可能会有一两个“因”在特殊情况之下不产生“果”。其实这是不可能的，这是违背因果律的。</p><p>《涅槃经》中有如是记载：“善恶之报，如影随形；三世因果，循环不失。”就是说因果的关系，犹如形和影的关系，一方出现，必然会出现另一方。</p><p>古德云：“假使百千劫，所作业不亡。因缘会遇时，果报还自受。只要“因”种下了，纵然经过百千万劫没有感果，这个“因”还是在的。等到因缘到来之时，这个“因”最终会感果。因此造了恶业之后，切不可有“恶业可能不感果”的侥幸心理。</p><p>菩萨就是深知“因”的厉害，因此处处在“因”上下功夫，这是我们必须要学习的。</p><blockquote><p>引用</p><p><a href="https://baijiahao.baidu.com/s?id=1636581325062523626">https://baijiahao.baidu.com/s?id=1636581325062523626</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-AQS</title>
      <link href="2021/04/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
      <url>2021/04/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/</url>
      
        <content type="html"><![CDATA[<p>AQS:AbstractQueueSyschronizer，抽象的队列式同步器，一套多线程访问共享资源的同步器框架，很多同步类的实现都依赖于他，如：ReentrantLock、CountDownLatch，AQS维护了一个volatile修饰的int state，代表共享资源，和一个FIFO的队列，多个线程竞争锁的时候，未得到锁的线程会阻塞进入队列；</p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E5%8E%9F%E7%90%86.png" alt="AQS原理"></p><p>AQS定义了两种资源共享方式：</p><ul><li>独占：同一时刻只有一个线程可以执行，如ReentrantLock</li><li>共享：多个线程可以同时执行，如CountDownLatch</li></ul><p>自定义的同步器在实现时，只需要实现共享资源的state的获取与释放即可，等待线程队列的维护，如获取资源失败入队列或唤醒出队列在顶层抽象类中已经实现；自定义的同步器在实现时需要实现的方法下：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><blockquote><p>引用：</p><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-CAS</title>
      <link href="2021/04/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/"/>
      <url>2021/04/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CAS/</url>
      
        <content type="html"><![CDATA[<p>CAS，compare and swap的缩写，即 比较和交换，包含三个操作数，内存位置值V，预期原值A和新值B；通常情况下，CAS用于同步的方式是，先从内存中读取到内存中值A，执行多步操作后得到一个结果B，如果此时内存位置值V与读取到的值A相等，用新值替换掉内存位置值，修改成功；如果不一致，不做操作；</p><p>CAS存在问题：</p><p> ABA问题，因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>解决思路：使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-CountDownLatch和CyclicBarrier</title>
      <link href="2021/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch%E5%92%8CCyclicBarrier/"/>
      <url>2021/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch%E5%92%8CCyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>CountDownLatch(倒计时器)： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行; CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(n); </span><br><span class="line"><span class="comment">//当程序多次执行countDownLatch.countDown();导致计数器n=0时，阻塞的线程都将同时被唤醒</span></span><br></pre></td></tr></table></figure><p>CountDownLatch 的主要方法：</p><ol><li>await() throws InterruptedException：调用该方法的线程等到构造方法传入的 N 减到 0 的时候，才能继续往下执行；</li><li>await(long timeout, TimeUnit unit)：与上面的 await 方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的 timeout 时间后，不管 N 是否减至为 0，都会继续往下执行；</li><li>countDown()：使 CountDownLatch 初始值 N 减 1；</li><li>long getCount()：获取当前 CountDownLatch 维护的值；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StuTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StuTask</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;countDownLatch:&quot;</span> + countDownLatch.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> StuTask(countDownLatch)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier 构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">// parties 是参与线程的个数</span></span></span><br><span class="line"><span class="function"><span class="comment">//第二个构造方法有一个 Runnable 参数，这个参数的意思是最后一个到达线程要做的任务</span></span></span><br></pre></td></tr></table></figure><p>CyclicBarrier 的主要方法：</p><ol><li><p>await() :等到所有的线程都到达指定的临界点</p></li><li><p>await(long timeout, TimeUnit unit) :与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止</p></li><li><p>getNumberWaiting():获取当前有多少个线程阻塞等待在临界点上</p></li><li><p>boolean isBroken():用于查询阻塞等待的线程是否被中断</p></li><li><p>void reset():将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StuTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StuTask</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name  );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> StuTask(cyclicBarrier )).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p><ol><li>CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进。</li><li>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</li><li>CountDownLatch 方法比较少，操作比较简单，而 CyclicBarrier 提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且 CyclicBarrier 的构造方法可以传入 barrierAction，指定当所有线程都到达时执行的业务功能；</li><li>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池-禁止使用Executors的原因</title>
      <link href="2021/04/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8Executors%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>2021/04/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8Executors%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="关于Executors"><a href="#关于Executors" class="headerlink" title="关于Executors"></a>关于Executors</h3><p>Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><ol><li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</li><li><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ol><h3 id="Executors创建线程池的弊端"><a href="#Executors创建线程池的弊端" class="headerlink" title="Executors创建线程池的弊端"></a>Executors创建线程池的弊端</h3><ol><li><p><strong>newFixedThreadPool和newSingleThreadExecutor:</strong></p><p>主要问题是池中的阻塞队列LinkedBlockingQueue的默认长度是Integer.MAX_VALUE，所以堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p></li><li><p><strong>newCachedThreadPool和newScheduledThreadPool:</strong></p><p>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p></li></ol><p>总结：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h3 id="线程池推荐用法"><a href="#线程池推荐用法" class="headerlink" title="线程池推荐用法"></a>线程池推荐用法</h3><p><strong>通过ThreadPoolExecutor创建线程池</strong></p><h4 id="核心参数："><a href="#核心参数：" class="headerlink" title="核心参数："></a><strong>核心参数：</strong></h4><ul><li>corePoolSize ：核心线程数（corePoolSize），当一个新任务被提交到池中，如果当前运行线程小于核心线程数（corePoolSize），即使当前有空闲线程，也会新建一个线程来处理新提交的任务；如果当前运行线程数大于核心线程数（corePoolSize）并小于最大线程数（maximumPoolSize），只有当等待队列已满的情况下才会新建线程；如果队列已满，并且运行线程数小于<code>maximumPoolSize</code>，也将会新建一个线程来运行；如果线程数大于<code>maximumPoolSize</code>，新提交的任务将会根据<strong>拒绝策略</strong>来处理。</li><li>maximumPoolSize：最大线程数（maximumPoolSize）</li><li>keepAliveTime ：超过 corePoolSize 线程数量的线程最大空闲时间</li><li> unit：时间单位</li><li>workQueue:工作队列，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li></ul><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>当线程池已经关闭或达到饱和（最大线程和队列都已满）状态时，新提交的任务将会被拒绝。ThreadPoolExecutor 定义了四种拒绝策略：</p><ol><li><strong>AbortPolicy</strong>：默认策略，在需要拒绝任务时抛出RejectedExecutionException；</li><li><strong>CallerRunsPolicy</strong>：直接在 execute 方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃；</li><li><strong>DiscardPolicy</strong>：直接丢弃任务；</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃。</li></ol><p>我们也可以自定义拒绝策略，只需要实现 RejectedExecutionHandler；需要注意的是，拒绝策略的运行需要指定线程池和队列的容量。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>通过下面的demo来了解ThreadPoolExecutor创建线程的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 测试ThreadPoolExecutor对线程的执行顺序  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolSerialTest</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//核心线程数  </span></span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">3</span>;  </span><br><span class="line">        <span class="comment">//最大线程数  </span></span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">6</span>;  </span><br><span class="line">        <span class="comment">//超过 corePoolSize 线程数量的线程最大空闲时间  </span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">2</span>;  </span><br><span class="line">        <span class="comment">//以秒为时间单位  </span></span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;  </span><br><span class="line">        <span class="comment">//创建工作队列，用于存放提交的等待执行任务  </span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>);  </span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//创建线程池  </span></span><br><span class="line">            threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,  </span><br><span class="line">                    maximumPoolSize,  </span><br><span class="line">                    keepAliveTime,  </span><br><span class="line">                    unit,  </span><br><span class="line">                    workQueue,  </span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//循环提交任务  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;  </span><br><span class="line">                <span class="comment">//提交任务的索引  </span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = (i + <span class="number">1</span>);  </span><br><span class="line">                threadPoolExecutor.submit(() -&gt; &#123;  </span><br><span class="line">                    <span class="comment">//线程打印输出  </span></span><br><span class="line">                    System.out.println(<span class="string">&quot;大家好，我是线程：&quot;</span> + index);  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="comment">//模拟线程执行时间，10s  </span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                        e.printStackTrace();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">                <span class="comment">//每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序  </span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            threadPoolExecutor.shutdown();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A4%BA%E4%BE%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="图片"></p><p>这里描述一下执行的流程：</p><ul><li>首先通过 ThreadPoolExecutor 构造函数创建线程池；</li><li>执行 for 循环，提交 8 个任务（恰好等于maximumPoolSize[最大线程数] + capacity[队列大小]）；</li><li>通过 threadPoolExecutor.submit 提交 Runnable 接口实现的执行任务；</li><li>提交第1个任务时，由于当前线程池中正在执行的任务为 0 ，小于 3（corePoolSize 指定），所以会创建一个线程用来执行提交的任务1；</li><li>提交第 2， 3 个任务的时候，由于当前线程池中正在执行的任务数量小于等于 3 （corePoolSize 指定），所以会为每一个提交的任务创建一个线程来执行任务；</li><li>当提交第4个任务的时候，由于当前正在执行的任务数量为 3 （因为每个线程任务执行时间为10s，所以提交第4个任务的时候，前面3个线程都还在执行中），此时会将第4个任务存放到 workQueue 队列中等待执行；</li><li>由于 workQueue 队列的大小为 2 ，所以该队列中也就只能保存 2 个等待执行的任务，所以第5个任务也会保存到任务队列中；</li><li>当提交第6个任务的时候，因为当前线程池正在执行的任务数量为3，workQueue 队列中存储的任务数量也满了，这时会判断当前线程池中正在执行的任务的数量是否小于6（maximumPoolSize指定）；</li><li>如果小于 6 ，那么就会新创建一个线程来执行提交的任务 6；</li><li>执行第7，8个任务的时候，也要判断当前线程池中正在执行的任务数是否小于6（maximumPoolSize指定），如果小于6，那么也会立即新建线程来执行这些提交的任务；</li><li>此时，6个任务都已经提交完毕，那 workQueue 队列中的等待 任务4 和 任务5 什么时候执行呢？</li><li>当任务1执行完毕后（10s后），执行任务1的线程并没有被销毁掉，而是获取 workQueue 中的任务4来执行；</li><li>当任务2执行完毕后，执行任务2的线程也没有被销毁，而是获取 workQueue 中的任务5来执行；</li></ul><p>通过上面流程的分析，也就知道了之前案例的输出结果的原因。其实，线程池中会线程执行完毕后，并不会被立刻销毁，线程池中会保留 corePoolSize 数量的线程，当 workQueue 队列中存在任务或者有新提交任务时，那么会通过线程池中已有的线程来执行任务，避免了频繁的线程创建与销毁，而大于 corePoolSize 小于等于 maximumPoolSize 创建的线程，则会在空闲指定时间（keepAliveTime）后进行回收。</p><p>在上面的测试中，我设置的执行线程总数恰好等于maximumPoolSize[最大线程数] + capacity[队列大小]，因此没有出现需要执行拒绝策略的情况，因此在这里，我再增加一个线程，提交9个任务，来演示不同的拒绝策略。</p><p><strong>AbortPolicy</strong></p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A51.png" alt="图片"></p><p><strong>CallerRunsPolicy</strong></p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A52.png" alt="图片"></p><p><strong>DiscardPolicy</strong></p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A53.png" alt="图片"></p><p><strong>DiscardOldestPolicy</strong></p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A54.png" alt="图片"></p><blockquote><p>引用：</p><p><a href="https://cnblogs.com/zjfjava/p/11227456.html">https://cnblogs.com/zjfjava/p/11227456.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-Executors</title>
      <link href="2021/04/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Executors/"/>
      <url>2021/04/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Executors/</url>
      
        <content type="html"><![CDATA[<h5 id="1-Executors有四种线程池的实现方式："><a href="#1-Executors有四种线程池的实现方式：" class="headerlink" title="1. Executors有四种线程池的实现方式："></a>1. Executors有四种线程池的实现方式：</h5><ul><li><strong>newSingleThreadExecutor</strong></li></ul><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><ul><li><strong>newFixedThreadPool</strong></li></ul><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><ul><li><strong>newScheduledThreadPool</strong></li></ul><p>创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行。</p><ul><li><strong>newCachedThreadPoo</strong></li></ul><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><h5 id="2-四种线程池的应用场景："><a href="#2-四种线程池的应用场景：" class="headerlink" title="2. 四种线程池的应用场景："></a>2. 四种线程池的应用场景：</h5><p>newCachedThreadPool：</p><ul><li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li><li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</li><li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li></ul><p>newFixedThreadPool：</p><ul><li>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue() 无界阻塞队列</li><li>通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</li><li>适用：执行长期的任务，性能好很多</li></ul><p>newSingleThreadExecutor:</p><ul><li>底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无解阻塞队列</li><li>通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</li><li>适用：一个任务一个任务执行的场景</li></ul><p>newScheduledThreadPool:</p><ul><li>底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</li><li>通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</li><li>适用：周期性执行任务的场景</li></ul><h5 id="3-线程池任务的执行流程："><a href="#3-线程池任务的执行流程：" class="headerlink" title="3. 线程池任务的执行流程："></a>3. 线程池任务的执行流程：</h5><ol><li>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</li><li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</li><li>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</li><li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li><li>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</li></ol><blockquote><p>引用<br><a href="https://blog.csdn.net/qq_28326489/article/details/106007065">https://blog.csdn.net/qq_28326489/article/details/106007065</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-java队列</title>
      <link href="2021/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java%E9%98%9F%E5%88%97/"/>
      <url>2021/04/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>java的阻塞队列和非阻塞队列</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。<br>1）支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：当队列为空时，获取元素的线程会等待队列变为非空。<br>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>下表是阻塞队列的部分方法：</p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ul><p>JDK7提供了7个阻塞队列。分别是：</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><p>简单介绍下其中两个队列：</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>​    LinkedBlockingQueue默认大小是Integer.MAX_VALUE，可以设定大小，可以理解为一个缓存的有界等待队列。</li><li>基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</li><li> LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li></ul><h4 id="ArrayListBlockingQueue"><a href="#ArrayListBlockingQueue" class="headerlink" title="ArrayListBlockingQueue"></a>ArrayListBlockingQueue</h4><ul><li>ArrayListBlockingQueue是一个基于数组的有界缓存的阻塞队列，同LinkedBlockingQueue类似，内部维持着一个定长数据缓冲队列（该队列由数组构成）。ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</li><li>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 </li><li>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。</li></ul><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-java的原子类</title>
      <link href="2021/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>2021/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>一般情况下如果我们想避免原子性问题的时都会选择加锁，但是我们都知道加锁和解锁是有消耗的。并且只要有加锁、解锁就会伴随着线程阻塞、线程的唤醒，这样线程的切换也是消耗性能的。</p><p>从JDK1.5起就提供了<strong>原子类，能无锁的避免原子性问题</strong>，所以<strong>在简单的情况下,而且是只有就竞争一个共享变量的情况下，可以使用Java原子类</strong>，如果是多个共享变量的话基本上只能加锁了。</p><p> <strong>Java原子类可以分为五大类：</strong></p><ul><li><strong>原子更新基本类型</strong></li><li><strong>原子更新数组</strong></li><li><strong>原子更新引用类型</strong></li><li><strong>原子更新属性(类的字段)</strong></li><li><strong>原子累加器</strong></li></ul><p> 没加锁实现原子性的秘密就是<strong>硬件的支持</strong>，CPU指令肯定是原子性的，为了解决并发的问题CPU提供了一条指令——CAS(compare and swap 即比较并交换)。CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C。只有当内存中地址A的值等于B，才能把地址A的值变成C。也就是只有预期值B等于内存地址A中的值时，<strong>表明共享变量没有被其他线程修改过，所以才允许更新新值</strong>，这样就保证了原子性！</p><p><strong>CAS还会有ABA问题，就是当你比较的时候，可能你的值被一个线程改了之后，另一个线程又改了回来，然后你比较的时候发现和预期值一样，其实是被改过的</strong>。就类似你走在路上，你手机放口袋里，小偷偷走了你的手机，但是一抬头看到了头上的监控，又默默的放回你的口袋。你根本不知道发生了这件事，然后悠然的拿起手机，刷了波朋友圈，又默默的塞进口袋。。。</p><p>大部分情况下不需要关心这个，例如基本类型等，但是原子更新引用类型，因为可能比较的时候线程但是里面的某个属性已经变了。可以添加一个版本号来避免这个问题。</p><p>通常利用CAS来解决并发问题都通过自旋手段，这里的自旋的其实循环尝试，再说白一点就是while循环。举个例子来看一下AtomicInteger源码，声明了 <code>private volatile int value;</code> 通过volatile 关键字保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);  <span class="comment">//读取内存中的值</span></span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4)); <span class="comment">//如果预期值不符合则重新读取内存中的值做比较</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>原子类都是调用<code>sun.misc.Unsafe</code>来的实现的，就比如上面的代码就是调用<code>unsafe.getAndAddInt()</code>。 do while就是自旋操作了，<code>compareAndSwapInt</code>是native方法。</p><p>所有的原子类实现基本上都是这个思路！讲白了就是调用硬件提供CAS这种操作，Java并发包帮我们封装了一下，使得我们更容易的调用！</p><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><p>相关实现类：AtomicBoolean、AtomicInteger、AtomicLong。主要就是用来基本类型的操作</p><h3 id="原子更新数组类型"><a href="#原子更新数组类型" class="headerlink" title="原子更新数组类型"></a>原子更新数组类型</h3><p>相关实现类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。可以原子化地更新数组里面的每一个元素，和原子更新基本类型差别就是基本上方法都多了个数组的下标。</p><h3 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h3><p>相关实现类：AtomicReference、AtomicStampedReference 、AtomicMarkableReference。这个就要重点关注ABA，但是Java已经关注到了所以AtomicStampedReference 和 AtomicMarkableReference 就能避免ABA问题了，就是用了版本号！</p><h3 id="原子更新字段类型"><a href="#原子更新字段类型" class="headerlink" title="原子更新字段类型"></a>原子更新字段类型</h3><p>相关实现类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater 它们可以原子化地更新对象的属性，注意更新类的字段(属性)必须使用public volatile修饰符，这样才能保证可见性。</p><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>相关实现类：LongAccumulator、LongAdder、DoubleAccumulator、DoubleAdder。这几个类只能用来进行累加操作，现对于原子更新基本类型它们的性能更好些，所以如果只有累加操作可以用这几个类！</p><blockquote><p>引用<br><a href="https://juejin.cn/post/6844903826877579271">https://juejin.cn/post/6844903826877579271</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-线程池</title>
      <link href="2021/04/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/04/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。<br>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p><p>线程池顾名思义就是<strong>事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销</strong>。</p><p><strong>线程池有什么优点？</strong></p><ul><li><p>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</p></li><li><p>提高响应速度。</p></li><li><p>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</p></li><li><p>当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li><li><p>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</p></li></ul><p><strong>线程池都有哪些状态</strong></p><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><p><strong>线程池中 submit() 和 execute() 方法有什么区别</strong></p><ul><li><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p></li><li><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p></li><li><p>异常处理：submit()方便Exception处理</p></li></ul><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><ol><li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</li><li><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ol><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><strong>Executors 各个方法的弊端：</strong></p><ul><li><p>newFixedThreadPool 和 newSingleThreadExecutor:<br>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p></li><li><p>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</p></li><li><p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p></li></ul><p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。ThreadPoolExecutor构造函数重要参数分析<br>ThreadPoolExecutor 3 个最重要的参数：</p><ol><li>corePoolSize ：核心线程数，线程数定义了最小可以同时运行的线程数量。</li><li>maximumPoolSize ：线程池中允许存在的工作线程的最大数量</li><li>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</li><li>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit ：keepAliveTime 参数的时间单位。</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li></ol><p><strong>ThreadPoolExecutor饱和策略</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ol><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ol><p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。</p><p>一个简单的线程池Demo:Runnable+ThreadPoolExecutor<br>线程池实现原理</p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.command = s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">       processCommand();</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">    <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">        Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        <span class="comment">//执行Runnable</span></span><br><span class="line">        executor.execute(worker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ul><li><p>corePoolSize: 核心线程数为 5。</p></li><li><p>maximumPoolSize ：最大线程数 10</p></li><li><p>keepAliveTime : 等待时间为 1L。</p></li><li><p>unit: 等待时间的单位为 TimeUnit.SECONDS。</p></li><li><p>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</p></li><li><p>handler:饱和策略为 CallerRunsPolicy。</p></li></ul><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p> ScheduledThreadPoolExecutor的是在 JUC 包下，是 JDK1.5 新增的。该类内部结构和 <code>Timer</code>还是有点类似的，也是 3 个类：</p><ul><li><code>ScheduledThreadPoolExecutor</code>：程序员使用的接口。</li><li><code>DelayedWorkQueue</code> ： 存储任务的队列。</li><li><code>ScheduledFutureTask</code> ： 执行任务的线程。</li></ul><p><strong>构造方法介绍</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span><br><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)  </span><br><span class="line"><span class="comment">// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)  </span><br><span class="line"><span class="comment">// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)  </span><br></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code>最多支持 3 个参数：核心线程数量，线程工厂，拒绝策略。</p><p>之所以没有最大线程数量，是因为 <code>ScheduledThreadPoolExecutor</code> 内部是个无界队列，<code>maximumPoolSize</code> 也就没有意思了。</p><p> API 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> <span class="comment">// 修改或替换用于执行 callable 的任务。</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> &lt;V&gt; RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> <span class="comment">// 修改或替换用于执行 runnable 的任务。        </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> <span class="comment">// 使用所要求的零延迟执行命令。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">getContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">()</span> <span class="comment">// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。      </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">getExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">()</span> <span class="comment">// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BlockingQueue&lt;Runnable&gt;<span class="title">getQueue</span><span class="params">()</span> <span class="comment">// 返回此执行程序使用的任务队列。     </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">remove</span><span class="params">(Runnable task)</span> <span class="comment">// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。     </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">&lt;V&gt; ScheduledFuture&lt;V&gt;<span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行在给定延迟后启用的 ScheduledFuture。    </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;<span class="title">schedule</span><span class="params">(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;<span class="title">scheduleAtFixedRate</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> <span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">ScheduledFuture&lt;?&gt;<span class="title">scheduleWithFixedDelay</span><span class="params">(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit)</span> <span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。  </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> <span class="comment">// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。  </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> <span class="comment">// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。  </span></span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="comment">// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">List&lt;Runnable&gt;<span class="title">shutdownNow</span><span class="params">()</span> <span class="comment">// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> <span class="comment">//  提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。 </span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span> <span class="comment">//  提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。  </span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> <span class="comment">//  提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></span></span><br></pre></td></tr></table></figure><p>最经常使用的几个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。</span></span><br><span class="line">ScheduledThreadPoolExecutor(<span class="keyword">int</span> corePoolSize)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行在给定延迟后启用的一次性操作。  </span></span><br><span class="line">ScheduledFuture&lt;?&gt;schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 </span></span><br><span class="line">ScheduledFuture&lt;?&gt;scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。       </span></span><br><span class="line">ScheduledFuture&lt;?&gt;scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) </span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><p><code>ScheduledThreadPoolExecutor</code> 是个定时任务线程池，类似 <code>Timer</code>，但是比 <code>Timer</code>强大，健壮。比如不会像 Timer 那样，任务异常了，整个调度系统就彻底无用了。也比<code>Timer</code> 多了<code>Rate</code> 模式（<code>Rate 和 Delay</code>）。</p></li><li><p>这两种模式的区别就是任务执行的起点时间不同，<code>Rate</code>是从上一个任务的开始执行时间开始计算；<code>Delay</code> 是从上一个任务的结束时间开始计算。因此，如果任务本身的时间超过了间隔时间，那么这两种模式的间隔时间将会不一致。而任务的排序是通过 <code>ScheduledFutureTask</code>的 <code>compareTo</code>方法排序的，规则是先比较执行时间，如果时间相同，再比较加入时间。</p></li></ul><ul><li>如果任务执行过程中异常了，那么将不会再次重复执行。因为 <code>ScheduledFutureTask</code>的 <code>run</code>方法没有做<code>catch</code>处理。所以程序员需要手动处理，相对于 Timer 异常就直接费了调度系统来说，要好很多。</li></ul><ul><li><code>ScheduledThreadPoolExecutor</code> 的是实现基于 <code>ThreadPoolExecutor</code>，大部分功能都是重用的父类，<strong>只是自己在执行完毕之后，重新设置时间，并再次将任务还到了队列中</strong>，形成了定时任务。</li></ul><blockquote><p>引用</p><p><a href="https://thinkwon.blog.csdn.net/article/details/104863992">https://thinkwon.blog.csdn.net/article/details/104863992</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-关键字</title>
      <link href="2021/04/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>在 Java 在多线程的环境下，synchronized 关键字用来控制同一代码段不被多个线程同时执行，synchronized 可以修饰类、方法、变量。在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是早期的 synchronized 效率低的原因。</p><p>在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p><strong>synchronized的三种使用方式：</strong></p><ul><li><strong>修饰实例方法</strong>: 作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法</strong>: 是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态synchronized 方法占用的锁是当前实例对象锁。</li><li><strong>修饰代码块</strong>: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结</strong>： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) ，因为JVM中，字符串常量池具有缓存功能！</p><p> <strong>synchronized 关键字的具体使用</strong></p><p>单例模式：双重校验锁实现对象单例（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化；使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><p><strong>synchronized 锁升级的原理</strong></p><p><strong>锁的升级的目的</strong></p><p>锁升级是为了降低锁带来的性能消耗。在Java6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗；当JVM检测到不同的竞争状态时，就会根据需要自动切换到合适的锁，这种切换就是锁的升级。升级是不可逆的，也就是说只能从低到高，也就是偏向–&gt;轻量级–&gt;重量级，不能够降级</p><p><strong>锁级别</strong>：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p><p><strong>无锁</strong>：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。</p><p><strong>偏向锁</strong>：指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。</p><p><strong>轻量级锁</strong>：如果线程处于活动状态，升级为轻量级锁的状态。轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p><p>当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。</p><p><strong>重量级锁</strong>：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</p><p><strong>synchronized、volatile、CAS 比较</strong></p><ol><li>synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</li><li>volatile 提供多线程共享变量可见性和禁止指令重排序优化。</li><li>CAS 是基于冲突检测的乐观锁（非阻塞）</li></ol><p><strong>synchronized 和 Lock 有什么区别</strong></p><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；<br>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。<br>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><p><strong>synchronized 和 ReentrantLock 区别</strong></p><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。</p><ul><li><p>既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p></li><li><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p></li></ul><p>相同点：两者都是可重入锁</p><p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 是一种轻量级的同步机制。</p><ol><li>保证数据可见性：确保一个线程的修改能对其他线程是可见的</li><li>不保证原子性</li><li>禁止指令重排序</li></ol><p><strong>Java 中能创建 volatile 数组吗？</strong></p><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><p><strong>volatile 变量和 atomic 变量有什么不同？</strong></p><p>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</p><p>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><p><strong>volatile 能使得一个非原子操作变成原子操作吗？</strong></p><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p><p><strong>synchronized 和 volatile 的区别是什么？</strong></p><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p><p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p><p><strong>区别</strong></p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>什么是不可变对象，它对写并发应用有什么帮助？</strong><br>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p><p>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p><p>只有满足如下状态，一个对象才是不可变的；</p><p>它的状态不能在创建后再被修改；</p><p>所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</p><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104863992">https://blog.csdn.net/ThinkWon/article/details/104863992</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-状态和基本操作</title>
      <link href="2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>线程的生命周期</strong></p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="线程的基本状态"></p><p><strong>新建(new)</strong></p><p>新创建了一个线程对象。</p><p><strong>可运行(runnable)</strong></p><p>线程对象创建后，当调用线程对象的 start()方法，该线程处于<strong>就绪状态</strong>，等待被线程调度选中，获取cpu的使用权。</p><p><strong>运行(running)</strong></p><p>可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p><p><strong>阻塞(block)</strong></p><p>处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</p><p>阻塞的情况分三种：</p><ol><li> 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</li><li> 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ol><p><strong>死亡(dead)</strong></p><p>线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><p><strong>Java的线程调度算法</strong></p><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p><p>有<strong>两种调度模型</strong>：分时调度模型和抢占式调度模型。</p><p><strong>分时调度模型</strong></p><p>指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p><p><strong>Java虚拟机采用抢占式调度模型</strong>，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p><p><strong>线程的调度策略</strong></p><p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><ol><li>线程体中调用了 yield 方法让出了对 cpu 的占用权利</li><li>线程体中调用了 sleep 方法使线程进入睡眠状态</li><li>线程由于 IO 操作受到阻塞</li><li>另外一个更高优先级线程出现</li><li>在支持时间片的系统中，该线程的时间片用完</li></ol><p><strong>线程调度器(Thread Scheduler)</strong></p><p>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p><p><strong>时间分片(Time Slicing )</strong></p><p>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。</p><p>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><p><strong>线程同步以及线程调度相关的方法</strong></p><ol><li> wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ol><p><strong>sleep() 和 wait()</strong></p><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><p><strong>如何调用 wait() 方法的？使用 if 块还是循环？为什么？</strong></p><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">    <span class="comment">//  判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="keyword">while</span>(!locked) &#123;</span><br><span class="line">        <span class="comment">//  等待唤醒</span></span><br><span class="line">        monitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  处理其他的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</strong></p><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><p><strong>Thread 类中的 yield 方法有什么作用？</strong></p><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><p><strong>线程的 sleep()方法和 yield()方法有什么区别？</strong></p><ol><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li> 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</li><li>sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</li></ol><p><strong>如何停止一个正在运行的线程？</strong></p><p>在java中有以下3种方法可以终止正在运行的线程：</p><ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ul><p><strong>Java 中 interrupted 和 isInterrupted 方法的区别？</strong></p><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p><p>注意：线程中断仅仅是指线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。isInterrupted：查看当前中断信号是true还是false</p><p><strong>什么是阻塞式方法？</strong></p><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p><p><strong>Java 中你怎样唤醒一个阻塞的线程？</strong></p><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p><p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><p><strong>notify() 和 notifyAll() 有什么区别？</strong></p><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p><p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><p><strong>Java 如何实现多线程之间的通讯和协作？</strong></p><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p><p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><p><strong>Java中线程通信协作的最常见的两种方式：</strong></p><ol><li>syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</li><li>ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</li></ol><p><strong>实现线程同步的方法</strong></p><p>同步代码方法：sychronized 关键字修饰的方法</p><p>同步代码块：sychronized 关键字修饰的代码块</p><p>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</p><p>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义</p><p><strong>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</strong></p><p>在 java 虚拟机中，每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p><p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p><p>如果你提交任务时，线程池队列已满，这时会发生什么<br>这里区分一下：</p><p>（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p>（2）如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy</p><p><strong>什么叫线程安全？servlet 是线程安全吗?</strong></p><p>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p><p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p><p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p><p>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p><p><strong>在 Java 程序中怎么保证多线程的运行安全？</strong></p><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p><p>方法二：使用自动锁 synchronized。</p><p>方法三：使用手动锁 Lock。</p><p>手动锁 Java 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>你对线程优先级的理解是什么？</strong></p><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</p><p>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><p><strong>线程类的构造方法、静态块是被哪个线程调用的?</strong></p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：</p><p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</p><p>（2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</p><p><strong>一个线程运行时发生异常会怎样？</strong></p><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p><p><strong>Java 线程数过多会造成什么异常？</strong></p><ul><li>线程的生命周期开销非常高</li></ul><ul><li>消耗过多的 CPU</li></ul><ul><li>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</li></ul><ul><li>降低稳定性JVM</li></ul><ul><li>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-基础知识</title>
      <link href="2021/04/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p><strong>优点</strong></p><ul><li>充分利用多核CPU的计算能力</li><li>方便进行业务拆分，提升系统并发能力和性能：在特殊的业务场景下，先天的就适合于并发编程。现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li></ul><p><strong>缺点</strong></p><p>并发编程的目的是为了能提高程序的执行效率，运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：</p><ul><li>内存泄漏、</li><li>上下文切换、</li><li>线程安全、</li><li>死锁</li></ul><p><strong>并发编程三要素</strong></p><p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</p><p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p><p><strong>出现线程安全问题的原因：</strong></p><ul><li>线程切换带来的原子性问题</li><li>缓存导致的可见性问题</li><li>编译优化带来的有序性问题</li></ul><p><strong>解决办法：</strong></p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li><li>synchronized、volatile、LOCK，可以解决可见性问题</li><li>Happens-Before 规则可以解决有序性问题</li></ul><p><strong>并行、并发、串行</strong></p><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><p>在一个程序中可以同时运行多个不同的线程来执行不同的任务。</p><p><strong>多线程的好处：</strong></p><p>可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p><p><strong>多线程的劣势：</strong></p><p>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；</p><p>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</p><p>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p><strong>进程</strong></p><p>一个在内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p><strong>线程</strong></p><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a><strong>进程与线程的区别</strong></h4><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器（PC）</strong>，线程之间切换的开销小。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a><strong>上下文切换</strong></h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而<strong>一个 CPU 核心在任意时刻只能被一个线程使用</strong>，为了让这些线程都能得到有效执行，<strong>CPU 采取的策略是为每个线程分配时间片并轮转的形式</strong>。当<strong>一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用</strong>，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p><strong>上下文切换通常是计算密集型的</strong>。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p><em>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，<strong>linux上下文切换和模式切换的时间消耗非常少</strong>。</em></p><h4 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a><strong>守护线程和用户线程</strong></h4><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p><p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。</p><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a><strong>线程死锁</strong></h4><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/images/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.png" alt="线程死锁.png"></p><p><strong>形成死锁的四个必要条件</strong></p><ol><li><strong>互斥条件</strong>：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li><li><strong>请求与保持条件</strong>：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件</strong>：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li></ol><p><strong>如何避免线程死锁</strong></p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h4 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h4><ul><li>继承 Thread 类；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>使用 Executors 工具类创建线程池</li></ul><p><strong>继承 Thread 类</strong></p><p>步骤</p><ol><li>定义Thread类的子类，重写run方法，将相关逻辑在run()方法内实现</li><li>创建自定义的线程子类对象</li><li>调用子类实例的star()方法来启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法正在执行...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThread = <span class="keyword">new</span> MyThread(); </span><br><span class="line">    myThread.start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现 Runnable 接口</strong></p><p>步骤</p><ol><li>定义Runnable接口实现类MyRunnable，并重写run()方法</li><li>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，该Thread对象才是真正的线程对象</li><li>调用线程对象的start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现 Callable 接口</strong></p><p>步骤</p><ol><li>创建实现Callable接口的类myCallable</li><li>以myCallable为参数创建FutureTask对象</li><li>将FutureTask作为参数创建Thread对象</li><li>调用线程对象的start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call()方法执行中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回结果 &quot;</span> + futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Executors 工具类创建线程池</strong></p><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。</p><p>主要有</p><ul><li><p>newFixedThreadPool</p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p></li><li><p>newCachedThreadPool</p><p>创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行。</p></li><li><p>newSingleThreadExecutor</p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></li><li><p>newScheduledThreadPool</p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    MyRunnable runnableTest = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(runnableTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;线程任务开始执行&quot;</span>);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>runnable 和 callable</strong></p><p><strong>相同点</strong></p><ul><li><p>都是接口</p></li><li><p>都可以编写多线程程序</p></li></ul><ul><li>都采用Thread.start()启动线程</li></ul><p><strong>主要区别</strong></p><ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</li></ul><p>注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><p><strong>线程的 run()和 start()</strong></p><ul><li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</li><li>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</li><li>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</li><li>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</li></ul><p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p><ul><li>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</li><li> start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li><li>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><p><strong>Callable 和 Future</strong></p><ul><li>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</li></ul><ul><li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li></ul><p><strong>FutureTask</strong></p><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型-linux和java</title>
      <link href="2021/04/07/IO%E6%A8%A1%E5%9E%8B-linux%E5%92%8Cjava/"/>
      <url>2021/04/07/IO%E6%A8%A1%E5%9E%8B-linux%E5%92%8Cjava/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>IO操作是一个很复杂且很耗资源的过程，因为每一次IO操作都会涉及到用户空间和内核空间的转换，而这个过程是通过系统调用来完成的。IO操作经常需要与磁盘进行操作，所以IO操作相比于CPU是要慢几个数量级的，利用这二者在速度上的区别，可以实现不同种类的IO方式，也就是IO模型</p><!--model--><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>数据不会在内核空间与用户空间相互拷贝，减少了数据在用户态和内核态之间的切换</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>在发出一个调用时，在没有得到结果之前， 该调用就不返回</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>调用在发出之后，这个调用就直接返回了，所以没有返回结果。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>指在不能立刻得到结果之前，该调用不会阻塞当前线程</p><h4 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h4><p>可以执行任何 CPU 指令，访问任何内存地址</p><h4 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h4><p>用户态运行的程序必须委托系统调用来访问硬件和内存。</p><h3 id="java的IO模型"><a href="#java的IO模型" class="headerlink" title="java的IO模型"></a>java的IO模型</h3><p>应用程序是不能直接访问硬盘的 ，java中的IO实际是调用了操作系统的能力来完成，在用户态通过系统调用转到内核态，最终实现文件的读写或者通信。</p><p><img src="/images/IO/io%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.png" alt="io交互过程"></p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。处理完成后，通过输出流返回应答给客户端，处理的线程销毁；</p><p><strong>存在的问题</strong>：这种 one-thread-per-client 的模式对于 server 而言压力是很大的。假设有 1k 个 client，对应的 server 应该启动 1k 个 thread，那么 server 所耗费的内存，以及线程切换时候占用的时间等等都是致命伤。即使使用线程池的技术来限制线程个数，这种 blocking-IO 的模型还是没办法支撑大量连接。</p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/java-BIO.png" alt="java-BIO.png"></p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>java 1.4 之后引入了一套 NIO 接口。NIO 中最主要的一个功能就是可以进行非阻塞 IO 操作，提供了 Selector,Channel , Buffer等抽象，如果没能够读取到数据，非阻塞 IO 不会阻塞线程，而是直接返回 0。由于 NIO 不会因为数据还没有到达而被阻塞，那么就没有必要每一个 client 都分配一个 thread 不断去轮询判断是否有数据可读。可以使用一个 thread 监听所有的 client 连接，由这个 thread 循环判断是否有某个 client 的数据可读，如果有就告知其他 thread 某个 client 连接由数据可读。这种行为就被称之为 IO 复用。在 NIO 中提供了 <code>Selector</code> 类来监听所有 client 连接是否有数据可读。使用 <code>Selector</code> 来实现 IO 复用，只有一个 thread 需要关心数据是否到来，其他线程等待通知就好。如此一来，只有监听线程会一直循环判断，并不会占据太多 CPU 资源。</p><p>所以综上，NIO 本质上是一个同步非阻塞IO。 </p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/java-NIO.png" alt="java-NIO"></p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>当发起 IO 操作之后，线程不用等待 IO 读取完毕，而是可以直接返回，继续执行其他操作。等到数据读取完毕之后，系统会通知线程数据已经读取完毕。这种发起 IO 操作，但是不必等待数据读取完毕的 IO 操作称之为异步 IO。如果使用 AIO，一个线程可以同时发起多个 IO 操作，这就意味着，一个线程可以同时处理多个请求</p><h3 id="linux的IO模型"><a href="#linux的IO模型" class="headerlink" title="linux的IO模型"></a>linux的IO模型</h3><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/IO%E6%A8%A1%E5%9E%8B.png" alt="IO模型"></p><h4 id="BIO-1"><a href="#BIO-1" class="headerlink" title="BIO"></a>BIO</h4><p>在发起 IO 操作之后，当前调用线程就会处在阻塞状态，直到数据传输完成。</p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linux-BIO.png" alt="linux-BIO"></p><h4 id="NIO-1"><a href="#NIO-1" class="headerlink" title="NIO"></a>NIO</h4><p>NIO 是在 BIO 基础之上的一个改进，NIO 在数据还未准备好的情况下，不会阻塞进程，而是通过轮询的方式，不断的去查询数据时候准备好，当数据可以被读取时，当前线程就会处在阻塞状态，直到数据读取完成。</p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linux-NIO.png" alt="linux-NIO"></p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO 多路复用是对 NIO 的一个改进，在 NIO 中，需要不断轮询查看数据是否准备好，IO 多路复用的改进是不再主动去查询数据状态是否准备完成，而是等数据准备好的通知，当数据准备完成之后，才会开始传输数据。</p><p>与 NIO 一样，在数据的传输阶段，当前线程依然是阻塞的。</p><p>在 Linux 系统中，IO 多路复用的方式有多种：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linux-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="linux-IO多路复用.png"></p><h4 id="信号驱动-IO"><a href="#信号驱动-IO" class="headerlink" title="信号驱动 IO"></a>信号驱动 IO</h4><p>信号驱动 IO 通过 sigaction 系统调用，向内核发送一个信号，当内核中数据准备好之后，当前线程也会接收到一个信号，在这个过程中，当前线程也是非阻塞的。在接收到信号之后，就可以开始传输数据。</p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linux-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" alt="linux-信号驱动IO"></p><h4 id="AIO-1"><a href="#AIO-1" class="headerlink" title="AIO"></a>AIO</h4><p><strong>上面的这些 IO 模型虽然有些号称是不阻塞的，那是指在等待数据就绪的过程中是不阻塞的，但是在接收数据的时候，依然还是阻塞的。</strong></p><p>AIO 是这些 IO 模型中真正实现完全不阻塞，AIO 在被调用之后直接返回，连接收数据的阶段也是非阻塞的，等到数据接收完成之后，内核才会返回一个通知，也就是说当用户进程接收到通知时，数据已经接收完成。</p><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linex-AIO.png" alt="linex-AIO.png"></p><h4 id="linux的几种IO模型总结"><a href="#linux的几种IO模型总结" class="headerlink" title="linux的几种IO模型总结"></a>linux的几种IO模型总结</h4><p><img src="/images/linux%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E4%B8%8Ejava%E7%9A%84IO%E6%A8%A1%E5%9E%8B/linux%E7%9A%84%E5%87%A0%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93.png" alt="linux的几种IO模型总结"></p><blockquote><p>引用<br><a href="https://juejin.cn/post/6873806635047845896">https://juejin.cn/post/6873806635047845896</a><br><a href="https://juejin.cn/post/6844903497985441800">https://juejin.cn/post/6844903497985441800</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> linux </tag>
            
            <tag> IO </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算密集型和IO密集型</title>
      <link href="2021/04/07/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CIO%E5%AF%86%E9%9B%86%E5%9E%8B/"/>
      <url>2021/04/07/%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CIO%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="计算密集型"><a href="#计算密集型" class="headerlink" title="计算密集型"></a>计算密集型</h3><p>计算密集型就是计算、逻辑判断量非常大而且集中的类型，因为主要占用cpu资源所以又叫cpu密集型，而且当计算任务数等于cpu核心数的时候，是cpu运行效率最高的时候。<br>特点：消耗cpu</p><h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><p>IO密集型就是磁盘的读取数据和输出数据非常大的时候就是属于IO密集型<br>由于IO操作的运行时间远远大于cpu、内存运行时间，所以任务的大部分时间都是在等待IO操作完成，IO的特点是cpu消耗小，所以，IO任务越多，cpu效率越高，当然不是越多越好，有一个极限值。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h3 id="cpu核心数"><a href="#cpu核心数" class="headerlink" title="cpu核心数"></a>cpu核心数</h3><p>cpu核心数是指一个cpu由几个核心组成，核心数越多，cpu运行速度越快，比如处理同一份数据，单核是指一个人处理，双核是指两个人处理，所以核心数越多，cpu性能越好。</p><blockquote><p>引用<br><a href="https://blog.csdn.net/weixin_44601149/article/details/89479144">https://blog.csdn.net/weixin_44601149/article/details/89479144</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><ul><li>网络接口层（链路层）：包括操作系统中的设备驱动程序、计算机中对应的网络接口卡</li><li>网络层（互连层、网际层）：处理分组在网络中的活动，比如分组的选路。负责IP寻址，分割和组装数据包，路由选择等。</li><li>传输层：主要为两台主机上的应用提供端到端的通信</li><li>应用层：负责处理特定的应用程序细节。<span id="more"></span></li></ul><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li><code>物理层</code>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流。<br>单位：比特、数据位、流、比特流</li><li><code>数据链路层</code>：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。在这一层工作的设备是交换机，数据通过交换机来传输。<br>单位：帧、数据帧</li><li><code>网络层</code>：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器。<br>单位：数据报、数据包、分组、包</li><li><code>传输层</code>：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。<br>单位：数据段、分段、报文段</li><li><code>会话层</code>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）</li><li><code>表示层</code>：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））</li><li><code>应用层</code>：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ等。<br>单位：报文</li></ul><h3 id="OSI参考模型与TCP-IP参考模型对应关系"><a href="#OSI参考模型与TCP-IP参考模型对应关系" class="headerlink" title="OSI参考模型与TCP/IP参考模型对应关系"></a>OSI参考模型与TCP/IP参考模型对应关系</h3><p><img src="/images/network/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="OSI参考模型与TCP/IP参考模型对应关系"></p><p>​    共同点：</p><ul><li>两个都是以<code>协议栈</code>的概念为基础，协议栈中的协议彼此互相独立；</li><li>都采用了<code>层次结构</code>的概念，各层功能大体相似。</li></ul><p>不同点：</p><ul><li>OSI有7层，TCP/IP有4层。</li><li>TCP/IP网络层提供无连接通信，传输层支持无连接和面向连接两种；<br>OSI网络层支持面向连接和无连接，传输层只支持面向连接的通信。</li></ul><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p><strong>三次握手</strong>：</p><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。<br>用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK</p><ul><li>发送端首先发送一个带SYN标志的数据包给对方。</li><li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。</li><li>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</li></ul><blockquote><p>注意：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p></blockquote><p><strong>四次挥手</strong>：</p><p>断开一个TCP连接则需要四次挥手</p><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul><h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><ul><li>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</li><li>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</li></ul><h3 id="TCP：流量控制"><a href="#TCP：流量控制" class="headerlink" title="TCP：流量控制"></a>TCP：流量控制</h3><p>TCP协议利用窗口机制实现流量控制；<br>TCP连接建立时，双方都为之分配了固定大小的缓冲空间；TCP的接收端只允许另一端发送其缓冲区所能接纳的数据：</p><ul><li>接收端在给发送端发送确认段时，通告接收窗口大小；</li><li>发送端在接下来发送数据段时，确保未确认段的应用层数据总量不超过接收端通告的接收窗口大小，从而确保接收端不会发生缓存溢出。</li></ul><h3 id="TCP：拥塞控制"><a href="#TCP：拥塞控制" class="headerlink" title="TCP：拥塞控制"></a>TCP：拥塞控制</h3><p><strong>拥塞</strong><br>拥塞是指太多主机以太快的速度向网络中发送太多的数据，超过了网络处理能力，导致大量数据分组“拥挤”在网络中间设备（如路由器）队列中等待转发，网络性能显著下降的现象。<br>拥塞的后果：<br>①数据分组通过网络的时延显著增加。<br>②由于队列满导致大量分组被丢弃。</p><p><strong>拥塞控制</strong><br>拥塞控制就是通过合理调度、规范、调整向网络中发送数据的主机数量、发送速率或数据量，以避免拥塞或尽快消除已发生的拥塞。</p><p><strong>TCP拥塞控制：</strong><br>从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。<br>①窗口机制：<br>通过调节窗口的大小实现对发送数据速率的调整。<br>②窗口调整的基本策略：<br><code>AIMD（Additive Increase,Multiplicative Decrease）</code>加性增加，乘性减少；<br>网络未发生拥塞时，逐渐“加性”增加窗口大小，当网络拥塞时“乘性”快速减小窗口大小。<br>③TCP的拥塞控制算法：<br>包括了<code>慢启动</code>、<code>拥塞避免</code>、<code>快速重传</code>和<code>快速恢复</code>4部分。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>传输层无法保证数据的可靠传输，只能通过应用层来实现。<br>实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。<br>实现确认机制、重传机制、窗口确认机制。</p><p>如果不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</p><ul><li>发送：包的分片、包确认、包的重发</li><li>接收：包的调序、包的序号确认</li></ul><p>注：<br>①给数据包编号，按照包的顺序接收并存储；<br>②接收端接收到数据包后发送确认信息给发送端，发送端接收确认数据以后再继续发送下一个包，如果接收端收到的数据包的编号不是期望的编号，则要求发送端重新发送。</p><blockquote><p>目前利用udp实现了可靠的数据传输分别为RUDP、RTP、UDT。</p></blockquote><hr><h3 id="面向连接和非面向连接的服务"><a href="#面向连接和非面向连接的服务" class="headerlink" title="面向连接和非面向连接的服务"></a>面向连接和非面向连接的服务</h3><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。    </p><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p><h3 id="Http和Https"><a href="#Http和Https" class="headerlink" title="Http和Https"></a>Http和Https</h3><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；<br>Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。</p><p>二者之间存在如下不同：</p><ul><li>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</li><li>开销：Https通信需要证书，而证书一般需要向认证机构购买；</li></ul><blockquote><p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p></blockquote><p> <strong>HTTP请求报文和响应报文的结构</strong></p><p><strong>请求报文：从客户向服务器发送请求报文</strong></p><p>HTTP典型的请求方法有：</p><ul><li>GET：请求读取由URL所标识的信息</li><li>HEAD：请求读取由URL所标识的信息的首部，无须在响应报文中包含对象。</li><li>POST：给服务器添加信息（例如：注释）</li><li>OPTION：请求一些选项的信息</li><li>PUT：在指明的URL下存储一个文档</li></ul><p><strong>响应报文：从服务器到客户的回答</strong></p><p>HTTP状态码：</p><ul><li>1xx：信息提示；通告信息，可能还需要进一步交互。</li><li>2xx：成功；成功完成客户请求的操作，并进行响应</li><li>3xx：重定向；表示资源已移走，需要向新的URL发送请求</li><li>4xx：客户端错误；由于客户请求错误，无法成功响应</li><li>5xx：服务端错误；由于服务端错误，无法成功响应</li></ul><p><strong>IP地址分类</strong></p><p>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。</p><p>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。</p><p>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。</p><p>D类地址(224<del>239)：以1110开头，保留位多播地址。<br>E类地址(240</del>255)：以1111开头，保留位今后使用。</p><p><strong>ARP地址解析协议的工作过程</strong></p><p>通过IP地址获得物理地址，是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。</p><p>过程：</p><ul><li>每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系</li><li>当源主机要发送数据时，首先检查 ARP 列表中是否有对应 IP 地址的目的主机的 MAC 地址，如果有，则直接发送数据，如果没有，就向”本网段”的所有主机发送 ARP 数据包，该数据包包括的内容有：<code>源主机 IP 地址，源主机 MAC 地址，目的主机的 IP 地址</code>。  </li><li>当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的目的主机 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。 </li><li>源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。广播发送ARP请求，单播发送 ARP 响应。</li></ul><p><strong>DNS（Domain Name System）域名系统的工作原理</strong></p><p>当 DNS 客户机需要在程序中使用名称时，它会查询 DNS 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：</p><ul><li>指定的 DNS 域名</li><li>指定的查询类型</li><li>DNS 域名的指定类别</li></ul><p>基于 UDP 服务，端口 53，该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code> 等在其中需要完成主机名到 IP 地址的转换。</p><p><strong>静态路由和动态路由</strong></p><p>静态路由是由管理员手工配置的，适合比较简单的网络或需要做路由特殊控制。</p><p>动态路由则是由动态路由协议自动维护的，不需人工干预，适合比较复杂大型的网络。 </p><p>路由器能够自动地建立自己的路由表，并且能够根据实际实际情况的变化适时地进行调整。动态路由机制的运作依赖路由器的两个基本功能：对路由表的维护；路由器之间实时的路由信息交换。</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-HashMap</title>
      <link href="2021/04/06/Java--HashMap/"/>
      <url>2021/04/06/Java--HashMap/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p><strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p><strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p><strong>哈希表</strong>：数组+链表实现，结合数组和链表的优点，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>HashMap底层是用数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现Map.Entry&lt;K,V&gt;接口）实现，HashMap 通过 put &amp; get 方法存储和获取。</p><h4 id="put-和get"><a href="#put-和get" class="headerlink" title="put()和get()"></a>put()和get()</h4><ul><li>存储对象时，将 K/V 键值传给 put() 方法：<ol><li>调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</li><li>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；</li><li>判断K的hash值在HashMap中是否存在<ul><li> 如果 K 的 hash 值在 HashMap 中不存在，则执行插入；</li><li>如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；</li><li> 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则发生碰撞，插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</li></ul></li></ol></li></ul><ul><li>获取对象时，将 K 传给 get() 方法：<ol><li>调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；</li><li>顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</li></ol></li></ul><blockquote><p>注：</p><ul><li><p>JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法</p></li><li><p>当碰撞导致链表超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;</p></li><li><p>hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等</p></li><li><p>如果集合中的键值对大于12，调用resize方法进行数组扩容。</p></li></ul></blockquote><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>如果两个不同的Key，通过哈希函数得出的实际存储地址相同，然后要进行插入的时候，发现已经被其他元素占用了，这就是所谓的哈希冲突，也叫哈希碰撞。</p><p><strong>哈希冲突的解决方法</strong></p><p>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</p><p>再散列函数法</p><p>链地址法：HashMap即是采用了链地址法，也就是数组+链表的方式。</p><p>因此hashCode 相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，”碰撞”就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。</p><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p><img src="/images/java/HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="HahMap的数据结构"></p><h4 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h4><ul><li><p>hashMap的容量是hashMap的table数组大小决定的，table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1&lt;&lt;30；</p></li><li><p>loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；</p></li><li><p>扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）</p></li><li><p>如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p></li></ul><p>JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p><h3 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h3><p><strong>拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</strong></p><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡<strong>，</strong>引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><p><strong>说说你对红黑树的见解？</strong></p><p>1、每个节点非红即黑</p><p>2、根节点总是黑色的</p><p>3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</p><p>4、每个叶子节点都是黑色的空节点（NIL节点）</p><p>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</p><p><strong>HashMap，LinkedHashMap，TreeMap 区别？</strong></p><ul><li>HashMap 参考其他问题；</li><li>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；</li><li>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</li></ul><p><strong>HashMap &amp; TreeMap &amp; LinkedHashMap 使用场景？</strong></p><p>一般情况下，使用最多的是 HashMap。</p><ul><li>HashMap：在 Map 中插入、删除和定位元素时；</li><li>TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；</li><li>LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。</li></ul><p><strong>HashMap 和 HashTable 有什么区别？</strong></p><ul><li>HashMap 是线程不安全的，HashTable 是线程安全的；</li><li>由于线程安全，所以 HashTable 的效率比不上 HashMap；</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；</li><li>HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</li><li>HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</li></ul><p><strong>ConcurrentHashMap</strong> </p><p>ConcurrentHashMap 类是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现。</p><p>HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；</p><p>而针对 ConcurrentHashMap，在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了CAS（无锁算法）+ synchronized。</p><blockquote><p>引用</p><p><a href="https://www.cnblogs.com/heqiyoujing/p/11143298.html">https://www.cnblogs.com/heqiyoujing/p/11143298.html</a></p><p><a href="https://www.jianshu.com/p/75adf47958a7">https://www.jianshu.com/p/75adf47958a7</a></p><p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-集合框架扩容机制</title>
      <link href="2021/04/05/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>2021/04/05/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>资源与效率的关系很微妙，相对较少的资源+相对较高的效率=高性能，不知道我这样理解是否正确，如果不赞成我，可不可以手下留情，不要攻击我</p><p><strong>JDK版本：1.8</strong> </p><h3 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,首先是默认初始值的大小：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;,</span><br><span class="line"><span class="comment">//2，接着是一个默认的空对象数组：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//3，然后是ArrayList 实际数据存储的一个数组：</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">//4，elementData 的大小：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p><strong>获得ArrayList 的容量大小</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getCapacity</span><span class="params">(ArrayList list)</span> </span>&#123;</span><br><span class="line">    Integer length = <span class="keyword">null</span>;</span><br><span class="line">    Class c = list.getClass();</span><br><span class="line">    Field f;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = c.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] o = (Object[]) f.get(list);</span><br><span class="line">        length = o.length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>构造ArrayList 对象的时候，如果在构造函数里面什么也不传，会初始化一个空的数组；此时集合的容量和大小都为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一个元素后，容量为10，大小为1</p></li><li><p>再往里添加10个元素后，集合的容量为15，大小为11</p></li><li><p>再往里添加5个元素后，集合的容量为22，大小为16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Integer capacity = getCapacity(list);</span><br><span class="line">       log.info(<span class="string">&quot;arrayList初始容量：&quot;</span>+capacity);</span><br><span class="line">       list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       log.info(<span class="string">&quot;添加一个元素：abc&quot;</span>);</span><br><span class="line">       log.info(<span class="string">&quot;arrayList容量：&quot;</span>+getCapacity(list));</span><br><span class="line">       log.info(<span class="string">&quot;arrayList大小：&quot;</span>+list.size());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list.add(<span class="string">&quot;abc&quot;</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;再添加10个元素&quot;</span>);</span><br><span class="line">       log.info(<span class="string">&quot;arrayList容量：&quot;</span>+getCapacity(list));</span><br><span class="line">       log.info(<span class="string">&quot;arrayList大小：&quot;</span>+list.size());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           list.add(<span class="string">&quot;gaoxing&quot;</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;再添加5个元素&quot;</span>);</span><br><span class="line">       log.info(<span class="string">&quot;arrayList容量：&quot;</span>+getCapacity(list));</span><br><span class="line">       log.info(<span class="string">&quot;arrayList大小：&quot;</span>+list.size());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结：ArrayList 的内部实现，是用一个对象数组进行存放具体的值，然后用一种扩容的机制，进行数组的动态增长。</p><p>其扩容机制可以理解为，如果元素的个数，大于其容量，则把其容量扩展为原来容量的1.5倍。</p><h3 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h3><p><strong>HashMap中的变量</strong></p><ul><li>Node&lt;K,V&gt;：链表节点，包含了key、value、hash、next指针四个元素</li><li>table：Node&lt;K,V&gt;类型的数组，里面的元素是链表，用于存放HashMap元素的实体</li><li>size：记录了放入HashMap的元素个数</li><li>loadFactor：负载因子</li><li>threshold：阈值，决定了HashMap何时扩容，以及扩容后的大小，一般等于table大小乘以loadFactor</li></ul><table><thead><tr><th align="left">构造函数和描述</th></tr></thead><tbody><tr><td align="left"><code>HashMap()</code>构造一个具有默认初始容量 (16) 和默认加载因子 (0.75)的空<code>HashMap</code>。</td></tr><tr><td align="left"><code>HashMap(int initialCapacity)</code>构造一个具有指定初始容量和默认负载因子 (0.75)的空<code>HashMap</code>。</td></tr><tr><td align="left"><code>HashMap(int initialCapacity, float loadFactor)</code>构造一个具有指定初始容量和负载因子的空<code>HashMap</code>。</td></tr><tr><td align="left"><code>HashMap(Map&lt;? extends K,? extends V&gt; m)</code>使用与指定<code>Map</code>相同的映射构造一个新的<code>HashMap</code>。</td></tr></tbody></table><p><strong>扩容机制核心方法</strong></p><p>Node&lt;K,V&gt;[] resize()</p><p><strong>HashMap扩容分为三种情况：</strong></p><ol><li>使用默认构造方法初始化HashMap，在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12，当大容量大于12时，自动扩容</li><li>指定初始容量的构造方法初始化HashMap初始容量会等于threshold 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</li><li>HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。</li></ol><blockquote><p>引用</p><p><a href="https://blog.csdn.net/eases_stone/article/details/79843851">https://blog.csdn.net/eases_stone/article/details/79843851</a></p><p><a href="https://blog.csdn.net/superxlcr/article/details/72810733">https://blog.csdn.net/superxlcr/article/details/72810733</a></p><p><a href="https://blog.csdn.net/u010890358/article/details/80496144">https://blog.csdn.net/u010890358/article/details/80496144</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-集合框架</title>
      <link href="2021/04/04/java-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
      <url>2021/04/04/java-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的集合类"><a href="#常用的集合类" class="headerlink" title="常用的集合类"></a>常用的集合类</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p><ul><li>Collection接口的子接口包括：List、Set、Queue</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet</li><li>List接口的实现类主要有：ArrayList、LinkedList以及Vector等</li></ul><p><strong>List，Set，Map的特点：</strong></p><ul><li><p><strong>List</strong>：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p></li><li><p><strong>Set</strong>：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p></li><li><p><strong>Queue</strong>:队列是一种比较特殊的线性结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中最先插入的元素也将最先被删除，对应的最后插入的元素将最后被删除。因此队列又称为“先进先出”（FIFO—first in first out）的线性表，与栈(FILO-first in last out)刚好相反。Queue接口常用的实现类是ArrayBlockingQueue,LinkedBlockingQueue ,PriorityBlockingQueue,DelayQueue,SynchronousQueue </p></li><li><p>Map接口不是collection的子接口，Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p></li></ul><p><img src="/images/java/List-Set-Map%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="List-Set-Map的继承关系"></p><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><p><strong>Collection</strong></p><ul><li><p><strong>List</strong></p><ul><li><p>Arraylist： Object数组<br>Vector： Object数组</p></li><li><p>LinkedList： 双向循环链表</p></li></ul></li><li><p><strong>Set</strong></p><ul><li><p>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</p></li><li><p>LinkedHashSet： <strong>LinkedHashSet 继承与 HashSet</strong>，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</p></li><li><p>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</p></li></ul></li></ul><p><strong>Map</strong></p><ul><li>HashMap： <strong>JDK1.8之前HashMap由数组+链表组成的</strong>，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.<strong>JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>Iterator 接口提供遍历任何 Collection 的接口，我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常；边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种最常见的错误代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。<br>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。<br>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><p><strong>Java 中 List 遍历的最佳实践</strong></p><ul><li><p><strong>for 循环遍历</strong>，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p></li><li><p><strong>迭代器遍历</strong>，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p></li><li><p><strong>foreach 循环遍历</strong>。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p></li></ul><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><p>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。<br>如果没有实现该接口，表示不支持 Random Access，如LinkedList。<br>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><p><strong>ArrayList 和 LinkedList 的区别</strong></p><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p>补充：数据结构基础之双向链表；双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</p><p><strong>ArrayList 和 Vector 的区别</strong></p><ul><li><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p></li><li><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的；Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间；Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p></li><li><p>性能：ArrayList 在性能方面要优于 Vector。</p></li><li><p>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p></li></ul><p><strong>List 和 Set 的区别</strong></p><ul><li><p>List , Set 都是继承自Collection 接口</p></li><li><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p></li></ul><ul><li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul><ul><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li></ul><p><strong>Set和List对比</strong></p><ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p><strong>HashSet 的实现原理</strong></p><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><p>向HashSet 中add ()元素时，判断元素是否存在的依据，<u>不仅要比较hash值，同时还要结合equles 方法比较</u>。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hashCode（）与equals（）的相关规定</strong>：</p><ol><li><p>如果两个对象相等，则hashcode一定也是相同的</p></li><li><p>两个对象相等,对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p></li><li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。<br><strong>==与equals的区别</strong></p></li><li><p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同 </p></li><li><p>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</p></li><li><p>==指引用是否相同 equals()指的是值是否相同<br><strong>HashSet与HashMap的区别</strong></p></li></ol><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><strong>BlockingQueue</strong></p><p>Java.util.concurrent.BlockingQueue是一个有界阻塞队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><p><strong>在 Queue 中 poll()和 remove()区别？</strong></p><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。<br>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h4><ul><li><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li><li><p><strong>HashMap的数据结构</strong>： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p></li><li><p><strong>HashMap 基于 Hash 算法实现的</strong></p><p>当我们往Hashmap中put元素时，<u>利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</u><br>存储时，如果出现hash值相同的key，此时有两种情况。(1)<u>如果key相同，则覆盖原始值</u>；(2)<u>如果key不同（出现冲突），则将当前的key-value放入链表中</u><br>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。<br>需要注意<u>Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树</u>来提高查询效率，从原来的O(n)到O(logn)</p></li></ul><p><strong>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</strong></p><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<u>拉链法</u>的方式可以解决哈希冲突。</p><p>JDK1.8之前<br>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/images/java/HashMap-jdk1.8.png" alt="HashMap-jdk1.8"></p><p>JDK1.8之后<br>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，<u>当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</u></p><p><img src="/images/java/HashMap-jdk1.8-2.png" alt="HashMap-jdk1.8-2.png"></p><p>JDK1.7 VS JDK1.8 比较<br>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：inflateTable()</td><td>直接集成到了扩容函数resize()中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><p><strong>HashMap的put方法的具体流程？</strong></p><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img src="/images/java/HashMap-putVal%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="HashMap-putVal方法执行流程图.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Map.put和相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建 </span></span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理  </span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树 </span></span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表 </span></span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断该链表尾部指针是不是空的</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//链表结构转树形结构</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><p><strong>HashMap的扩容操作是怎么实现的？</strong></p><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        &#125;<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class="line">    <span class="comment">// 直接将该值赋给新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的threshold = 新的cap * 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历新数组的所有桶下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class="line">                                <span class="comment">// 代表下标保持不变的链表的头元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                <span class="comment">// loTail.next指向当前e</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// loTail指向当前的元素e</span></span><br><span class="line">                            <span class="comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class="line">                            <span class="comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class="line">                            <span class="comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>HashMap是怎么解决哈希冲突的？</strong></p><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；</p><p><strong>什么是哈希？</strong><br>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><p><strong>什么是哈希冲突？</strong><br>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><p><strong>HashMap的数据结构</strong></p><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<u>数组的特点是：寻址容易，插入和删除困难</u>；<u>链表的特点是：寻址困难，但插入和删除容易</u>；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：</p><p><img src="/images/java/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="HashMap数据结构"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p><p><strong>hash()函数</strong><br>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是<u>让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动</u>，在JDK 1.8中的hash()函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#x2F;&#x2F; 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><p><strong>JDK1.8新增红黑树</strong></p><p><img src="/images/java/HashMap-%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="HashMap-红黑树.png"></p><p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><p>总结<br>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ol><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ol><p><strong>能否使用任何类作为 Map 的 key？</strong><br>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><p>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</p><p>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</p><p>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</p><p>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</p><p><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong><br>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><p>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；<br><strong>如果使用Object作为HashMap的Key，应该怎么办呢？</strong><br>答：重写hashCode()和equals()方法</p><p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；<br>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；<br><strong>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</strong><br>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>那怎么解决呢？</strong></p><p>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；<br>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；<br><strong>HashMap 的长度为什么是2的幂次方</strong><br>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><p><strong>HashMap 与 HashTable 有什么区别？</strong><br>线程安全： <u>HashMap 是非线程安全的，HashTable 是线程安全的</u>；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；<br>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；<br>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。<br><u>初始容量大小和每次扩充容量大小的不同</u> ：</p><p> ①创建时如果不指定容量初始值，<u>Hashtable 默认的初始大小为11</u>，<u>之后每次扩充，容量变为原来的2n+1</u>。<u>HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍</u>。</p><p>②创建时如果给定了容量初始值，那么 <u>Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次</u>方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。<br>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。<br>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。<br><strong>如何决定使用 HashMap 还是 TreeMap？</strong><br>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，<u>假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择</u>。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><p><strong>HashMap 和 ConcurrentHashMap 的区别</strong><br><u>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好</u>，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）<br>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。<br><strong>ConcurrentHashMap 和 Hashtable 的区别？</strong><br>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><p>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。<br>两者的对比图：</p><p>HashTable:</p><p><img src="/images/java/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable全表锁.png"></p><p>JDK1.7的ConcurrentHashMap：</p><p><img src="/images/java/ConcurrentHashMap-%E5%88%86%E6%AE%B5%E9%94%81.png" alt="ConcurrentHashMap-分段锁.png"></p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><p>![ConcurrentHashMap- 红黑二叉树节点-链表节点.png](/images/java/ConcurrentHashMap- 红黑二叉树节点-链表节点.png)</p><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><p><strong>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</strong><br>JDK1.7</p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p><img src="/images/java/ConcurrentHashMap-Segment%E9%94%81.png" alt="ConcurrentHashMap-Segment锁"></p><p>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；<br>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。<br>JDK1.8</p><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><p>结构如下：</p><p><img src="/images/java/ConcurrnetHashMap%E9%94%81%E5%8D%87%E7%BA%A7.png" alt="ConcurrnetHashMap锁升级.png"></p><p>附加源码，有需要的可以看看</p><p>插入元素过程（建议去看看源码）：</p><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin&#125;</span></span><br></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    binCount = <span class="number">1</span>;    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;        K ek;        <span class="keyword">if</span> (e.hash == hash &amp;&amp;            ((ek = e.key) == key ||             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;            oldVal = e.val;            <span class="keyword">if</span> (!onlyIfAbsent)                e.val = value;            <span class="keyword">break</span>;        &#125;        Node&lt;K,V&gt; pred = e;        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);            <span class="keyword">break</span>;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；<br>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>Array 和 ArrayList 区别</strong></p><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。<br>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。<br>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><p><strong>Array 和 List 之间的转换</strong></p><p>Array 转 List： Arrays. asList(array) ；<br>List 转 Array：List 的 toArray() 方法。</p><p><strong>comparable 和 comparator的区别</strong></p><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序<br>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序<br>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><p><strong>Collection 和 Collections 区别</strong></p><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。<br>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？<br>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104588551">https://blog.csdn.net/ThinkWon/article/details/104588551</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-锁</title>
      <link href="2021/04/03/java-%E9%94%81/"/>
      <url>2021/04/03/java-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。另外Java中往往是按照是否含有某一特性来定义锁，如下图<img src="/images/java/java-%E9%94%81-%E6%80%BB%E7%BB%93.png" alt="java-锁-总结"></p><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。另外Java中往往是按照是否含有某一特性来定义锁，如下图</p><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li><p>悲观锁：多个线程并发的访问操作同一个资源时，悲观锁会在获取资源前先得到锁，操作完后释放锁；</p><p>具体实现：在JAVA中，synchronized和Lock都是属于悲观锁</p></li><li><p>乐观锁：是在更新数据的时候才会去判断数据有没有被其他线程更新，如果没有被其他线程更新，就将更新的数据重新写入，如果被其他线程更新了，则会报错或重试；</p><p>具体实现：Java的乐观锁是通过无锁编程实现的，最常用的就是CAS算法+自旋</p></li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>阻塞或唤醒一个线程需要操作系统切换CPU状态来完成，切换状态需要战胜CPU的时间；对锁定资源的操作简单或复杂，所需要的时间有可能多，也有可能很少</p></blockquote><p>如果对锁定资源的操作很简单，需要消耗时间不长，在操作资源被其他资源锁定的情况下，通过自旋的方式，而不是阻塞的方式，等他基他线程释放锁后来获得锁，这种形式的锁是自旋锁；</p><h3 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h3><ul><li><p>无锁：不对资源进行锁定，所有的线程都可以访问并修改同一个资源，但是只有一个线程能修改成功</p></li><li><p>偏向锁：资源被一个线路访问操作的时候，自动获取锁，降低获取锁的代价</p></li><li><p>轻量级锁：当持有资源的锁是偏向锁的时候，被另外的线程访问操作时，该锁会通过自旋的方式升级成轻量级锁，轻量级锁的轻主要体现在其他线程在获取被锁的资源时，会通过自旋的方式等待锁定资源上的锁释放后再获取，不会阻塞</p></li><li><p>重量级锁：是相对于轻量级锁来说的，在其他线程访问被锁定的资源时，等待的线程会进入阻塞状态</p></li></ul><p>这里的无锁、偏向锁、轻量级锁、重量级锁是指的锁的状态，专门会对synchronized的，也就syschronized这种锁会随着锁的竞争状态逐步升级，便不能降级</p><h3 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h3><ul><li><p>公平锁：多个线程在竞争锁的时候，申请获取锁的线程会直接进入队列排队，按照申请锁定的先后顺序来获取，线程在等等待的过程中会阻塞</p><p>具体实现：ReentrantLock的内部类Sync里的FairSync</p></li><li><p>非公平锁：多个线程在竞争锁的时候，获取不到锁的线程会被入队列等待，如果锁刚好可用，无须阻塞可以直接获取，与公平锁的区别就是后申请锁的线程可能会先获取到锁</p><p>具体实现：ReentrantLock的内部类Sync里的NonfairSync，ReentrantLock默认是非公平锁</p></li></ul><h3 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h3><ul><li><p>可重入锁：一个线程在外层方法获取到锁后，进行入内层方法时，会自动获取到锁，不会因为外部方法未释放锁而进入阻塞，形成死锁</p><p>具体实现：ReentrantLock、syschronized</p></li><li><p>非可重入锁：与可重入锁是相对于可重入锁相反的，有可能会形成死锁现象</p><p>具体实现：NonReentrantLock</p></li></ul><h3 id="独享锁与共享锁"><a href="#独享锁与共享锁" class="headerlink" title="独享锁与共享锁"></a>独享锁与共享锁</h3><ul><li><p>独享锁：又成排他锁，同一时刻只能被一个线程持有，不能再加其他锁，持有锁的线程可以读或写数据</p><p>具体实现：ReentrantReadWriteLock里的WriteLock</p></li><li><p>共享锁：可以被多个线程持有，持有该锁的线程保能读数据，不能写数据，也不能再加独享锁</p><p>具体实现：ReentrantReadWriteLock里的ReadLock</p></li></ul><blockquote><p>原文：</p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-ConcurrentHashMap</title>
      <link href="2021/04/02/Java-ConcurrentHashMap/"/>
      <url>2021/04/02/Java-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap不仅实现了HashMap支持的所有功能，并且保持了和HashMap一样的高效的前提下，还实现了线程安全。另外ConcurrentHashMap的实现从JDK1.7到JDK1.8，改动比较大，下面分别就两个版本的put()和get()，总结一下有哪些变化。</p><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数组和 HashEntry 数组结构构成，Segment数组默认长度是16。采取分段锁来保证安全性。Segment  继承于 ReentrantLock，属于重入锁，在 ConcurrentHashMap 中扮演锁的角色；HashEntry 则用于存储键值对数据。</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，Segment 的结构和 HashMap 类似，是一个数组和链表结构。</p><p><img src="/images/java/jdk1.7-ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="jdk1.7 ConcurrentHashMap结构"></p><h5 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h5><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p><ol><li>通过 key 定位到 Segment，然后尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</li><li>拿到锁后，将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry，遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value，不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>最后释放获取当前 Segment 的锁。</li></ol><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p>JDK1.8 的实现已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><p><img src="/images/java/jdk1.8-ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="jdk1.8 ConcurrentHashMap结构"></p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化table的工作将发生在进行put操作时，如果发现table还没有被初始化，那么就会调用方法initTable来进行table的初始化，下面展示了初始化table的具体流程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个比较关键的变量sizeCtl，sizeCtl是一个用于同步多个线程的共享变量，如果它的当前值为负数，则说明table正在被某个线程初始化或者扩容，所以，如果某个线程想要初始化table或者对table扩容，需要去竞争sizeCtl这个共享变量，获得变量的线程才有许可去进行接下来的操作，没能获得的线程将会一直自旋来尝试获得这个共享变量，所以获得sizeCtl这个变量的线程在完成工作之后需要设置回来，使得其他的线程可以走出自旋进行接下来的操作。</p><p>在initTable方法中我们可以看到，当线程发现sizeCtl小于0的时候，他就会让出CPU时间，而稍后再进行尝试，当发现sizeCtl不再小于0的时候，就会通过调用方法compareAndSwapInt来讲sizeCtl共享变量变为-1，以告诉其他试图获得sizeCtl变量的线程，目前正在由本线程在享用该变量，在我完成我的任务之前你们可以先休息一会，我完成工作之后会释放掉的。而其他的线程在发现sizeCtl小于0的时候就会理解这种交流，他们会让出cpu时间，等待下次调度再来尝试获取sizeCtl来进行自己的工作。在完成初始化table的任务之后，线程需要将sizeCtl设置成可以使得其他线程获得变量的状态</p><h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p>在ConcurrentHashMap中查询一条记录首先需要知道这条记录存储的table的位置，该位置上可能为null，如果为null，说明想要查询的记录还不存在于ConcurrentHashMap中，否则，就在该位置上的链表或者红黑树中查找记录，下面来详细分析一下ConcurrentHashMap的get方法的实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>计算出记录的key的hashCode</p></li><li><p>通过使用(hashCode &amp; (length - 1))的计算方法来获得该记录在table中的index</p></li><li><p>判断该位置上是否为null，如果为null，则返回null，</p></li><li><p>如果该位置上的有一个元素，且与我们先要查找的记录匹配，则直接返回这个节点的值</p></li><li><p>如果该节点的hashCode小于0，则说明该位置上是一颗红黑树，至于为什么hashCode值小于0就代表是一颗红黑树而不是链表了，则通过调用Node的find方法来查找到节点，而这个Node的find方法在子类中被重写，所以会直接调用子类的find方法来进行查找。</p></li><li><p>如果table的index位置上为一条链表，那么就通过链表的查找方法来进行记录查找。</p><p>最后需要注意的是，ConcurrentHashMap是一种线程安全的HashMap，get方法的过程中使用任何与锁等效的组件来做线程同步，因为table数组是被volatile关键字修饰的，保证了table数组的可见性，所以没有必要加锁来实现并发了。</p></li></ol><h5 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h5><p>在进行put操作的时候，可能会发现table数组还没有初始化的情况，或者发现table中容纳的记录数量超过了阈值的情况，前者我们需要进行table的初始化，而后者需要我们对table进行扩容操作。初始化table的过程在上面已经进行了分析，这里只分析table的扩容操作。</p><ol><li>计算记录的key的hashCode，根据hashCode计算table的index位置</li><li>获取该index的值，如果该位置还为null，说明该位置上还没有记录，则通过调用casTabAt方法来讲该新的记录插入到table的index位置上去，</li><li>table的index位置上的值不会null，则通过synchronized关键字对table的index位置加锁，需要特别注意的是，当前线程只会锁住table的index位置，其他位置上没有锁住，所以此时其他线程可以安全的获得其他的table位置来进行操作。这也就提高了ConcurrentHashMap的并发度。然后判断table的index位置上的第一个节点的hashCode值，这个节点要么是链表的头节点，要么是红黑树的根节点，如果hashCode值小于0，那么就是一颗红黑树，如果不小于0，那么就还是一条链表，如果是一条链表，那么就寻找是否已经有记录的key和当前想要插入的记录是一致的，如果一致，那么这次put的效果就是replace，否则，将该记录添加到链表中去。如果是一颗红黑树，那么就通过调用putTreeVal方法来进行插入操作。</li><li>在插入操作完成之后，需要判断本次操作是否是更新操作，如果是更新操作，则不会造成size的变化；如果本次put操作时一次添加操作，那么就需要进行更新size的操作；如果在更新size之后发现table中的记录数量达到了阈值，就需要进行扩容操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable();</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>引用</p><p><a href="https://juejin.cn/post/6844904018729254926">https://juejin.cn/post/6844904018729254926</a></p><p><a href="https://www.jianshu.com/p/cf5e024d9432">https://www.jianshu.com/p/cf5e024d9432</a></p><p><a href="https://juejin.cn/post/6844903641866846222">https://juejin.cn/post/6844903641866846222</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合框架 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础理论</title>
      <link href="2021/04/01/JVM-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>2021/04/01/JVM-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><h4 id="JVM-的主要组成"><a href="#JVM-的主要组成" class="headerlink" title="JVM 的主要组成"></a>JVM 的主要组成</h4><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><p><strong>Class loader(类装载)</strong> ：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</p><p><strong>Execution engine（执行引擎）</strong> ：执行classes中的指令。</p><p><strong>Native Interface(本地接口)</strong> ：与native libraries交互，是其它编程语言交互的接口。</p><p><strong>Runtime data area(运行时数据区域)</strong> ：这就是我们常说的JVM的内存。</p><p><img src="/images/jvm/JVM.png" alt="JVM"></p><h4 id="java程序编译加载运行过程"><a href="#java程序编译加载运行过程" class="headerlink" title="java程序编译加载运行过程"></a>java程序编译加载运行过程</h4><ol><li>首先通过编译器把 Java 代码转换成字节码</li><li>类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内</li><li>字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li></ol><p><img src="/images/jvm/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="java程序运行机制"></p><h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><p>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p><p><strong>JVM加载Class文件的原理机制</strong></p><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p><strong>类装载方式，有两种 ：</strong></p><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><p><strong>类加载器</strong></p><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器,主要有以下四种类加载器:</p><ul><li><p>**启动类加载器(Bootstrap ClassLoader)**：是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的java核心类库，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；无法被java程序直接引用。</p></li><li><p><strong>扩展类加载器(extensions class loader)：</strong>负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库</p></li><li><p><strong>系统类加载器（system class loader）</strong>：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p></li><li><p><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</p></li></ul><p><strong>类装载的执行过程</strong></p><p>类装载分为以下 5 个步骤：</p><ol><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ol><p><strong>双亲委派模型</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p><img src="/images/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派"></p><h4 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h4><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。</p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li><strong>程序计数器（Program Counter Register）</strong>：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li><strong>Java 虚拟机栈（Java Virtual Machine Stacks）</strong>：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li><strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li><strong>Java 堆（Java Heap）</strong>：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li><strong>方法区（Methed Area）</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><p><img src="/images/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区"></p><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p><strong>浅拷贝</strong>（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p><p><strong>深拷贝</strong>（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p><strong>浅复制</strong>：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p><strong>深复制</strong>：在计算机中开辟一块新的内存地址用于存放复制的对象。</p><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p><strong>堆</strong></p><ul><li>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</li><li>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</li><li>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</li><li>静态变量放在方法区，<br>静态的对象还是放在堆。</li><li>堆对于整个应用程序都是共享、可见的。</li></ul><p><strong>栈</strong></p><ul><li>栈使用的是数据结构中的栈，<u>先进后出</u>的原则，物理地址分配是<u>连续</u>的。所以性能快。</li><li>栈是连续的，所以分配的内存大小要在<u>编译期就确认</u>，大小是<u>固定的</u>。</li><li>栈存放：<u>局部变量，操作数栈，返回结果</u>。该区更关注的是程序方法的执行。</li><li>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</li></ul><h4 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h4><p><strong>队列</strong></p><ul><li>队列的插入称为入队，队列的删除称为出队</li><li>队列是在队尾入队，队头出队，即两边都可操作。</li><li>队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）</li></ul><p><strong>栈</strong></p><ul><li>栈的插入称为进栈，栈的删除称为出栈</li><li>栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作</li><li>栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除</li></ul><h3 id="Java内存溢出"><a href="#Java内存溢出" class="headerlink" title="Java内存溢出"></a>Java内存溢出</h3><p><strong>Java会存在内存泄漏吗？请简单描述</strong></p><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：<u>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</u>，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p>GC 就是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><p><strong>Java 中的引用类型</strong></p><p>强引用：发生 gc 的时候不会被回收。</p><p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p><p>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p><p>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><p><strong>判断对象是否可以被回收</strong></p><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p><p>一般有两种方法来判断：</p><ul><li><p><strong>引用计数器法</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p></li><li><p><strong>可达性分析算法</strong>：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p></li></ul><h4 id="JVM-垃圾回收算法"><a href="#JVM-垃圾回收算法" class="headerlink" title="JVM 垃圾回收算法"></a>JVM 垃圾回收算法</h4><ol><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li><li>标记-清除算法：标记无用对象，然后进行清除回收。</li></ol><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h5><p>是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><p>标记阶段：标记出可以回收的对象。<br>清除阶段：回收被标记的对象所占用的空间。<br>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</p><p>优点：实现简单，不需要对象进行移动。</p><p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h5><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p><p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h5><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p><p>优点：解决了标记-清理算法存在的内存碎片问题。</p><p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a><strong>分代收集算法</strong></h5><p>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代和永久代，如图所示：</p><p><img src="/images/jvm/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="img"></p><h4 id="JVM-垃圾回收器"><a href="#JVM-垃圾回收器" class="headerlink" title="JVM 垃圾回收器"></a><strong>JVM 垃圾回收器</strong></h4><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。<br><img src="/images/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="垃圾回收器"></p><ol><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ol><p><strong>CMS 垃圾回收器</strong></p><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><p><strong>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</strong></p><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p><p>老年代回收器：Serial Old、Parallel Old、CMS</p><p>整堆回收器：G1</p><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</p><p>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><p><strong>分代垃圾回收器工作过程</strong></p><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p><strong>JVM 调优的工具</strong></p><ol><li>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</li><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ol><p><strong>常用的 JVM 调优的参数</strong></p><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul><blockquote><p>引用<br><a href="https://blog.csdn.net/ThinkWon/article/details/104390752">https://blog.csdn.net/ThinkWon/article/details/104390752</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇怪的世界</title>
      <link href="2021/04/01/strange-world/"/>
      <url>2021/04/01/strange-world/</url>
      
        <content type="html"><![CDATA[<p>这篇文可能很短，因为我是想哪写到那，可能说停就停；当然也有可能很长，这个世界奇怪的地方太多，如果我发现了，我想我会在这里把它记录下来</p><p>2021-04-01</p><p>这个世界很奇怪，人们喜欢真相，但有的时候却害怕不想面对，甚至怕面对真相的残酷；<br>人们喜欢或来自于别人善意的谎言，或来自于自我的麻痹，却讨厌欺骗和背叛；<br>真的是相当矛盾呀<br>我把我真实的一面展现在你的面前，你却更喜欢包装后的我；<br>我把包装后的自己展现到你的面前，你却更喜欢真实的自我；<br>奇怪的人类，奇怪的世界呀，我只能说我还是做我自己吧，颜色一样不一样，我不知道，但我更知道我是谁，我是什么样；<br>你喜欢不喜欢，认可不认可，我不知道，但我知道，人生苦短，我只做我自己。<br>希望你也是。</p><p>2021-04-26</p><p>我是凡夫，俗人，不是君子，也非小人，还有点小脾气<br>但我仰慕、赞同君子，和而不同，能一起把酒言欢，亦可包容对方与己意见相左<br>我不齿小人貌和神离，同而不和<br>做自己很难，坚持做自己更难，但是更有意义，心里更坦然</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰器模式</title>
      <link href="2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。</p><p>装饰器模式的主要优点：</p><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li><li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li><li>装饰器模式完全遵守开闭原则</li></ul><p>缺点：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li><p>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</p></li><li><p>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</p></li><li><p>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</p></li><li><p>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p><p><img src="/images/untype/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="装饰器模式类图"></p></li></ol><p>装饰模式和代理模式的类图结构几乎一样，仅仅是使用的目的有所差异，对比学习有助于理解装饰模式的使用。假设有一个接口Human，一个接口的实现类Man。人类Human是可以跑步的，但是不能飞。如果想给人类加上飞翔的翅膀，可以有三种解决方案：</p><ol><li><p>修改实现类Man的方法，但不符合开闭原则</p></li><li><p>给实现类Man添加一个子类，扩展一个人类可以飞的功能。问题在于，如果又想给人类增加猎豹般奔跑的速度，需要继续扩展一个子类。显然，使用继承的方式去扩展一个类的功能，会增加类的层级，类的臃肿会加大维护的成本。</p></li><li><p>使用装饰模式扩展一个类的功能。好处在于，如果继承关系是纵向的，那么装饰类则是某个类横向的扩展，并不会影响继承链上的其他类。例如：C extends B , B extends A，如果需要扩展B的功能，可以设计一个B的装饰类，它并不会影响B的子类C。如果采用在B里面增加方法，势必会使B的所有子类结构被改变。</p></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>   基本步骤：</p><ul><li>定义一个接口Human</li><li>定义一个被装饰的类Man</li><li>定义一个装饰的抽象类，内部持有被装饰类的引用</li><li>定义一个装饰的实现类</li><li>定义一个接口Human，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽取一个抽象方法run，人类是可以跑步的。</p><p>定义一个被装饰的类Man，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人会跑步&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个装饰的抽象类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecorator</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="comment">//持有被装饰类的引用 </span></span><br><span class="line"><span class="keyword">private</span> Human human;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数注入被装饰者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractDecorator</span><span class="params">(Human human)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.human = human;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用被装饰类的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">human.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行，模块间的依赖关系，通过成员变量实现，符合迪米特法则。</p><p>第6行，模块间的依赖通过抽象Human产生，而不是通过Man，符合依赖倒置原则。</p><p>定义一个装饰的实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ManDecorator</span><span class="params">(Human human)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用父类的构造方法</span></span><br><span class="line"><span class="keyword">super</span>(human);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰类增加的功能</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;人可以飞&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增强了功能的run方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.run();</span><br><span class="line">fly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建被装饰的类</span></span><br><span class="line">Human human = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建装饰的类，并添加被装饰类的引用</span></span><br><span class="line">Human superMan = <span class="keyword">new</span> ManDecorator(human);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行增强后的run方法</span></span><br><span class="line">superMan.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用场景：<br>替代继承，扩展一个类的功能<br>动态的给一个对象添加功能，以及动态的撤销该功能</p><p>优点：<br>动态扩展一个实现类的功能，在不需要添加功能的时候，可以撤销装饰。<br>装饰类和被装饰类模块间，通过抽象产生依赖，不会相互耦合<br>装饰模式替换继承，可以避免继承链的子类被影响</p><h3 id="装饰模式与代理模式的区别"><a href="#装饰模式与代理模式的区别" class="headerlink" title="装饰模式与代理模式的区别"></a>装饰模式与代理模式的区别</h3><p>装饰模式：侧重给一个实现类动态添加功能，不会对实现类的方法进行过滤拦截</p><p>代理模式：侧重将一个实现类的功能，委托给代理类来处理，可以对实现类的方法进行过滤拦截(某种情况下，可能不执行实现类的方法)</p><blockquote><p>引用：<br>-<a href="http://c.biancheng.net/view/1366.html">http://c.biancheng.net/view/1366.html</a><br>-<a href="https://blog.csdn.net/pihailailou/article/details/82813374">https://blog.csdn.net/pihailailou/article/details/82813374</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>妙哉午后</title>
      <link href="2021/03/30/beijing-changping/"/>
      <url>2021/03/30/beijing-changping/</url>
      
        <content type="html"><![CDATA[<p>花团锦簇少年郎，<br>轻舞飞扬好时光。<br>且行且止随心往，<br>莫待而立叹过往。</p><span id="more"></span><p><img src="/images/untype/%E6%98%8C%E5%B9%B3-%E7%99%BE%E5%96%84%E5%9B%AD%E5%8C%BA.jpg" alt="昌平-百善园区"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="2021/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>Target（目标抽象类）</strong>：目标抽象类<u>定义客户所需接口</u>，可以是一个抽象类或接口，也可以是具体类。</p><p><strong>Adapter（适配器类）</strong>：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p><p><strong>Adaptee（适配者类）</strong>：<u>适配者即被适配的角色</u>，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p><p>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在JDK类库的事件处理包java.awt.event中广泛使用了缺省适配器模式，如WindowAdapter、KeyAdapter、MouseAdapter等。</p><p>示例</p><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>首先有一个已存在的将被适配的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个目标接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法，可以通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line"></span><br><span class="line">        Target adapterTarget = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapterTarget.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被适配者的方法</span><br></pre></td></tr></table></figure><p><img src="/images/untype/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E5%9B%BE.png" alt="类适配器模式-类图"></p><p>这样我们即可在新接口 Target 中适配旧的接口或类</p><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 Adapter 是将 Adaptee 作为一个成员属性，而不是继承它</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>再来一个好理解的例子笔记本的电源（适配器），我们平时用电都是 220V，但是笔记本需要20V，用适配器模式来将 220V 的输入电压变换为 20V 输出</p><p>定义输出交流电接口，输出220V交流电类和输出110V交流电类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteBookPowerAdapter</span> <span class="keyword">extends</span> <span class="title">AC220</span>  <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = <span class="keyword">super</span>.outputAC();</span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入AC:&quot;</span> + adapterInput + <span class="string">&quot;V&quot;</span> + <span class="string">&quot;，输出DC:&quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;电源适配成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteBookPowerAdapterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       DC5Adapter dc5Adapter=<span class="keyword">new</span> NoteBookPowerAdapter();</span><br><span class="line">       dc5Adapter.outputDC5V();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入AC:220V，输出DC:5V</span><br><span class="line">电源适配成功</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>主要优点：</strong></p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p><strong>具体来说，类适配器模式还有如下优点：</strong></p><ul><li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li></ul><p><strong>对象适配器模式还有如下优点：</strong></p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul><p><strong>类适配器模式的缺点如下：</strong></p><ol><li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</li><li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ol><p><strong>对象适配器模式的缺点如下：</strong></p><p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。<br><strong>适用场景：</strong></p><p>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。<br>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p><blockquote><p>引用<br><a href="https://blog.csdn.net/wwwdc1012/article/details/82780560">https://blog.csdn.net/wwwdc1012/article/details/82780560</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="2021/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ol><p>它的主要缺点如下。</p><ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ol><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol><li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ol><p><img src="/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="观察者模式类图"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>皇帝同志最近发现户部尚书和兵部尚书有些许异常，派出锦衣卫张三和李四，监视其一举一动，一言一行，一旦有情况，两卫皇帝同志的爪牙马上会马上向皇帝同志报告消息</p><h4 id="抽象大臣类"><a href="#抽象大臣类" class="headerlink" title="抽象大臣类"></a>抽象大臣类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Jinyiwei&gt; jinyiweiList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Jinyiwei jinyiwei)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jinyiweiList.add(jinyiwei);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Jinyiwei jinyiwei)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jinyiweiList.remove(jinyiwei);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Jinyiwei jinyiwei : jinyiweiList) &#123;</span><br><span class="line">            jinyiwei.report(<span class="string">&quot;我是&quot;</span> + jinyiwei.getType() + <span class="string">&quot;，向皇帝同志报告一下，&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getTypeName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">(String food)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleeping</span><span class="params">(String wife)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">(String work)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体目标：户部尚书"><a href="#具体目标：户部尚书" class="headerlink" title="具体目标：户部尚书"></a>具体目标：户部尚书</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuBuShangshu</span> <span class="keyword">extends</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String typeName = <span class="string">&quot;户部尚书&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.typeName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + food + <span class="string">&quot;真难吃&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleeping</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + wife + <span class="string">&quot;真好，会做饭来能挣钱&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">(String work)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + work + <span class="string">&quot;真爽，名正言顺欣赏美女&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体目标：兵部尚书"><a href="#具体目标：兵部尚书" class="headerlink" title="具体目标：兵部尚书"></a>具体目标：兵部尚书</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BingbuShangshu</span> <span class="keyword">extends</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String typeName = <span class="string">&quot;兵部尚书&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.typeName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + food + <span class="string">&quot;好香啊&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleeping</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + wife + <span class="string">&quot;身材真好，明天不想上班了&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">(String work)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">this</span>.getTypeName() + <span class="string">&quot;说：&quot;</span> + work + <span class="string">&quot;工作好难，谋反算了&quot;</span>;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">this</span>.notify(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象观察者：锦衣卫"><a href="#抽象观察者：锦衣卫" class="headerlink" title="抽象观察者：锦衣卫"></a>抽象观察者：锦衣卫</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Jinyiwei</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="观察者一：东厂首领张三"><a href="#观察者一：东厂首领张三" class="headerlink" title="观察者一：东厂首领张三"></a>观察者一：东厂首领张三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zhangsan</span> <span class="keyword">implements</span> <span class="title">Jinyiwei</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;东厂锦衣卫首领张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="观察者二：西厂首领李四"><a href="#观察者二：西厂首领李四" class="headerlink" title="观察者二：西厂首领李四"></a>观察者二：西厂首领李四</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Lisi implements Jinyiwei &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;东厂锦衣卫首领李四&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void report(String message) &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建户部尚书</span></span><br><span class="line">    Minister hubushangshu=<span class="keyword">new</span> HuBuShangshu();</span><br><span class="line">    <span class="comment">//在户部尚书身边悄悄安排一名锦衣卫张三</span></span><br><span class="line">    Jinyiwei zhangsan=<span class="keyword">new</span> Zhangsan();</span><br><span class="line">    hubushangshu.add(zhangsan);</span><br><span class="line">    hubushangshu.eating(<span class="string">&quot;红烧鱼&quot;</span>);</span><br><span class="line">    hubushangshu.working(<span class="string">&quot;给皇帝同志选秀&quot;</span>);</span><br><span class="line">    hubushangshu.sleeping(<span class="string">&quot;春香&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">    <span class="comment">//创建兵部尚书</span></span><br><span class="line">    Minister bingbushangshu=<span class="keyword">new</span> BingbuShangshu();</span><br><span class="line">    <span class="comment">//在兵部尚书身边悄悄安排一名锦衣卫李四</span></span><br><span class="line">    Jinyiwei lisi=<span class="keyword">new</span> Lisi();</span><br><span class="line">    bingbushangshu.add(lisi);</span><br><span class="line">    bingbushangshu.eating(<span class="string">&quot;铁锅炖大鹅&quot;</span>);</span><br><span class="line">    bingbushangshu.working(<span class="string">&quot;训练新兵&quot;</span>);</span><br><span class="line">    bingbushangshu.sleeping(<span class="string">&quot;秋香&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">户部尚书说：红烧鱼真难吃</span><br><span class="line">我是东厂锦衣卫首领张三，向皇帝同志报告一下，户部尚书说：红烧鱼真难吃</span><br><span class="line">户部尚书说：给皇帝同志选秀真爽，名正言顺欣赏美女</span><br><span class="line">我是东厂锦衣卫首领张三，向皇帝同志报告一下，户部尚书说：给皇帝同志选秀真爽，名正言顺欣赏美女</span><br><span class="line">户部尚书说：春香真好，会做饭来能挣钱</span><br><span class="line">我是东厂锦衣卫首领张三，向皇帝同志报告一下，户部尚书说：春香真好，会做饭来能挣钱</span><br><span class="line">---------------</span><br><span class="line">兵部尚书说：铁锅炖大鹅好香啊</span><br><span class="line">我是东厂锦衣卫首领李四，向皇帝同志报告一下，兵部尚书说：铁锅炖大鹅好香啊</span><br><span class="line">兵部尚书说：训练新兵工作好难，谋反算了</span><br><span class="line">我是东厂锦衣卫首领李四，向皇帝同志报告一下，兵部尚书说：训练新兵工作好难，谋反算了</span><br><span class="line">兵部尚书说：秋香身材真好，明天不想上班了</span><br><span class="line">我是东厂锦衣卫首领李四，向皇帝同志报告一下，兵部尚书说：秋香身材真好，明天不想上班了</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。</p><p>通过前面的分析与应用实例可知观察者模式适合以下几种情形。</p><ol><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li><li>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</li></ol><blockquote><p>引用<br><a href="http://c.biancheng.net/view/1390.html">http://c.biancheng.net/view/1390.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML-类图关系</title>
      <link href="2021/03/26/UML-%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/"/>
      <url>2021/03/26/UML-%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>在UML类图中，常见的有以下几种关系:</p><p>泛化（Generalization）, 实现（Realization）,关联（Association）,聚合（Aggregation）,组合(Composition)，依赖(Dependency)</p><h3 id="1-泛化-Generalization"><a href="#1-泛化-Generalization" class="headerlink" title="1.泛化(Generalization)"></a>1.泛化(Generalization)</h3><p>【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为例如：老虎是动物的一种.</p><p>【箭头指向】：带三角箭头的实线，箭头指向父类</p><p><img src="/images/untype/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.gif" alt="泛化关系"></p><h3 id="2-实现（Realization"><a href="#2-实现（Realization" class="headerlink" title="2.实现（Realization)"></a>2.实现（Realization)</h3><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现</p><p>【箭头指向】：带三角箭头的虚线，箭头指向接口</p><p> <img src="/images/untype/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.gif" alt="实现关系"></p><h3 id="3-关联（Association）"><a href="#3-关联（Association）" class="headerlink" title="3.关联（Association）"></a>3.关联（Association）</h3><p>【关联关系】：是一种拥有的关系,它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子</p><p>关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p><p><img src="/images/untype/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.gif" alt="关联关系"> </p><p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><p> <img src="/images/untype/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB2.gif" alt="关联关系2"></p><p>上图为自身关联：</p><h3 id="4-聚合（Aggregation）"><a href="#4-聚合（Aggregation）" class="headerlink" title="4. 聚合（Aggregation）"></a>4. 聚合（Aggregation）</h3><p>【聚合关系】：是整体与部分的关系.如车和轮胎是整体和部分的关系.</p><p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p><p><img src="/images/untype/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.gif" alt="聚合关系"> </p><h3 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5. 组合(Composition)"></a>5. 组合(Composition)</h3><p>【组合关系】：是整体与部分的关系.,没有公司就不存在部门   组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><p> <img src="/images/untype/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.gif" alt="组合关系"></p><h3 id="6-依赖-Dependency"><a href="#6-依赖-Dependency" class="headerlink" title="6. 依赖(Dependency)"></a>6. 依赖(Dependency)</h3><p>【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。</p><p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p><p>【箭头及指向】：带箭头的虚线，指向被使用者</p><p> <img src="/images/untype/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.gif" alt="依赖关系"></p><p>各种关系的强弱顺序：</p><p>泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</p><p>下面这张UML图，比较形象地展示了各种类图关系：</p><p><img src="/images/untype/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB%E7%BB%BC%E5%90%88.gif"></p><blockquote><p>引用：<br><a href="https://www.cnblogs.com/qianpangzi/p/10842672.html">https://www.cnblogs.com/qianpangzi/p/10842672.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 类图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/25/hello-world/"/>
      <url>2021/03/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>年与时驰<br>意与日去<br>兜兜转转这些年</p><span id="more"></span><p>迷茫过<br>逃避过<br>奋起过<br>拼搏过<br>成功过<br>失败过<br>如今处事愈发沉静<br>内心却愈发空虚<br>。。。<br>。。。。<br>。。。。。<br>应该做些什么了<br>来沉淀自己<br>留作记忆<br>新的状态就从这个hello world开始吧</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI机制的应用</title>
      <link href="2021/03/18/SPI%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2021/03/18/SPI%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p><h2 id="SPI-有什么用？"><a href="#SPI-有什么用？" class="headerlink" title="SPI 有什么用？"></a><strong>SPI 有什么用？</strong></h2><p>举个栗子，现在我们设计了一款全新的日志框架：super-logger。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperLoggerConfiguration</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">configure</span><span class="params">(String configFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后来一个默认的XML实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfiguration</span> <span class="keyword">implements</span> <span class="title">SuperLoggerConfiguration</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(String configFile)</span></span>&#123;     </span><br><span class="line">        ......    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123;        </span><br><span class="line">        SuperLoggerConfiguration configuration = <span class="keyword">new</span> XMLConfiguration();  </span><br><span class="line">        configuration.configure(configFile);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getLogger</span><span class="params">(Class clazz)</span></span>&#123;  </span><br><span class="line">        ......   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制/扩展/重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。</p><p>比如现在用户/使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？</p><p>如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。</p><p>下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。</p><h2 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a><strong>JDK SPI</strong></h2><p>JDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在”META-INF/services/“下的多个配置实现文件。</p><p>为了解决上面的扩展问题，现在我们在META-INF/services/下创建一个以接口全限定名命名的文件，如com.github.kongwu.spisamples.SuperLoggerConfiguration文件（没有后缀）。在文件中只有一行代码，那就是我们默认的com.github.kongwu.spisamples.XMLConfiguration（注意，一个文件里也可以写多个实现，回车分隔）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration</span>:<span class="string"></span></span><br><span class="line"><span class="attr">com.github.kongwu.spisamples.XMLConfiguration</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">SuperLoggerConfiguration configuration;</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;   </span><br><span class="line">    <span class="comment">//加载并初始化实现类 </span></span><br><span class="line">    configuration = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对最后一个configuration类调用configure方法</span></span><br><span class="line">configuration.configure(configFile);</span><br></pre></td></tr></table></figure><p>最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerFactory</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123;        </span><br><span class="line">        ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);  </span><br><span class="line">        Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();        </span><br><span class="line">        SuperLoggerConfiguration configuration;</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;           </span><br><span class="line">            configuration = iterator.next();</span><br><span class="line">            <span class="comment">//加载并初始化实现类       </span></span><br><span class="line">        &#125;       </span><br><span class="line">        configuration.configure(configFile);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getLogger</span><span class="params">(Class clazz)</span></span>&#123;  </span><br><span class="line">        ......   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？</p><p>试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？</p><p>SPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？</p><p>所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 super-logger 包里增加了默认的SuperLoggerConfiguration 实现。</p><p>为了支持 YAML 配置，现在在使用方/用户的代码里，增加一个YAMLConfiguration的 SPI 配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration</span>:<span class="string"></span></span><br><span class="line"><span class="attr">com.github.kongwu.spisamples.ext.YAMLConfiguration</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。</p><p>在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们**使用最后一个实现配置作为最终的实例。</p><p>再等等？最后一个？怎么算最后一个？</p><p>使用方/用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？</p><p>这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。</p><p>举个栗子，如果我们程序的启动脚本为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp super-logger.jar:a.jar:b.jar:main.jar example.Main</span><br></pre></td></tr></table></figure><p>默认的XMLConfiguration SPI配置在super-logger.jar，扩展的YAMLConfiguration SPI配置文件在main.jar，那么iterator获取的最后一个元素一定为YAMLConfiguration。</p><p>但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp main.jar:super-logger.jar:a.jar:b.jar example.Main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。</p><p>由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。</p><p>所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式。</p><p>总结：</p><h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a><strong>Dubbo SPI</strong></h2><p>Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。</p><p>Dubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optimusPrime</span> = <span class="string">org.apache.spi.OptimusPrime</span></span><br><span class="line"><span class="attr">bumblebee</span> = <span class="string">org.apache.spi.Bumblebee</span></span><br></pre></td></tr></table></figure><p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimusPrime</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bumblebee</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSPITest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);     </span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>); </span><br><span class="line">        optimusPrime.sayHello();    </span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>); </span><br><span class="line">        bumblebee.sayHello();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！</p><p>通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：dubbo protocol - dubbo://来看看Dubbo中协议的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取    Protocol SPI 配置中别名为dubbo的那个实现，com.alibaba.dubbo.rpc.Protocol文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapperlistener&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrappermock&#x3D;com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line"></span><br><span class="line">dubbo&#x3D;com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line"></span><br><span class="line">injvm&#x3D;com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocolrmi&#x3D;com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocolhessian&#x3D;com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocolcom.alibaba.dubbo.rpc.protocol.http.HttpProtocolcom.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocolthrift&#x3D;com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocolmemcached&#x3D;com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocolredis&#x3D;com.alibaba.dubbo.rpc.protocol.redis.RedisProtocolrest&#x3D;com.alibaba.dubbo.rpc.protocol.rest.RestProtocolregistry&#x3D;com.alibaba.dubbo.registry.integration.RegistryProtocolqos&#x3D;com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</span><br><span class="line"><span class="comment">//protocol: DubboProtocol</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了</p><p>Dubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，如果遇到重复就跳过不会加载了。</p><p>所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 - 加载顺序不严谨。</p><h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a><strong>Spring SPI</strong></h2><p>Spring 的 SPI 配置文件是一个固定的文件 - META-INF/spring.factories，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有factories文件中配置的LoggingSystemFactory</span></span><br><span class="line">List&lt;LoggingSystemFactory&gt;&gt; factories = SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一段 Spring Boot 中 spring.factories 的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Logging Systemsorg.springframework.boot.logging.LoggingSystemFactory&#x3D;\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br><span class="line"># PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader&#x3D;\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"># ConfigData Location Resolversorg.springframework.boot.context.config.ConfigDataLocationResolver&#x3D;\</span><br><span class="line">org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\</span><br><span class="line">org.springframework.boot.context.config.StandardConfigDataLocationResolver</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。</p><p>Spring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……</p><p>和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。</p><p>但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个</p><p>如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个META-INF/spring.factories文件，只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的  spring.factories 文件然后修改 ; 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个META-INF/spring.factories文件，而不是完整的复制+修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory&#x3D;\</span><br><span class="line">com.example.log4j2demo.Log4J2LoggingSystem.Factory</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h2><p><img src="/images/java/%E5%87%A0%E7%A7%8DSPI%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="几种SPI机制的区别"></p><p>三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示</p><blockquote><p>来源：</p><p><a href="https://juejin.cn/post/6950266942875779108">https://juejin.cn/post/6950266942875779108</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat-线程模型</title>
      <link href="2021/03/17/tomcat-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/03/17/tomcat-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Tomcat 是一个免费的、开源的、轻量级的 Web 应用服务器。适合在并发量不是很高的中小企业项目中使用。</p><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p>Tomcat 的核心功能有两个，分别是负责接收和反馈外部请求的连接器 Connector，和负责处理请求的容器 Container。其中连接器和容器相辅相成，一起构成了基本的 web 服务 Service。每个 Tomcat 服务器可以管理多个 Service。</p><table><thead><tr><th align="left">组件</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">Connector</td><td align="left">负责对外接收反馈请求。它是 Tomcat 与外界的交通枢纽，监听端口接收外界请求，并将请求处理后传递给容器做业务处理，最后将容器处理后的结果反馈给外界。</td></tr><tr><td align="left">Container</td><td align="left">负责对内处理业务逻辑。其内部由Engine、Host、Context 和 Wrapper 四个容器组成，用于管理和调用 Servlet 相关逻辑。</td></tr><tr><td align="left">Service</td><td align="left">对外提供的 Web 服务。主要包含连接器和容器两个核心组件，以及其他功能组件。Tomcat 可以管理多个 Service，且各 Service 之间相互独立。</td></tr></tbody></table><p><img src="/images/tomcat/tomcat%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt="tomcat工作过程图"></p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>tomcat支持三种接收请求的处理方式：BIO、NIO、APR、AIO</p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>阻塞式I/O操作，表示Tomcat使用的是传统Java I/O操作(即Java.io包及其子包)。Tomcat7以下版本默认情况下是以bio模式运行的，由于每个请求都要创建一个线程来处理，线程开销较大，不能处理高并发的场景，在三种模式中性能也最低</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO模式是java SE 1.4及后续版本提供的一种新的I/O操作方式，是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，它拥有比传统I/O操作(bio)更好的并发运行性能。在tomcat 8之前要让Tomcat以nio模式来运行比较简单，只需要在Tomcat安装目录/conf/server.xml文件中将如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;connectionTimeout&#x3D;&quot;20000&quot;redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;connectionTimeout&#x3D;&quot;20000&quot;redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>Tomcat8以上版本，默认使用的就是NIO模式，不需要额外修改</p><h4 id="APR"><a href="#APR" class="headerlink" title="APR"></a>APR</h4><p>APR是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能， 也是Tomcat运行高并发应用的首选模式。<br>启用这种模式稍微麻烦一些，需要安装一些依赖库</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>异步非阻塞，tomcat8.0后支持</p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
