<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>和而不同</title>
  
  <subtitle>五朝</subtitle>
  <link href="https://gaoxing27.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gaoxing27.gitee.io/"/>
  <updated>2022-02-28T02:57:22.775Z</updated>
  <id>https://gaoxing27.gitee.io/</id>
  
  <author>
    <name>凡夫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>夜听冰河</title>
    <link href="https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/"/>
    <id>https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/</id>
    <published>2022-01-23T09:10:58.000Z</published>
    <updated>2022-02-28T02:57:22.775Z</updated>
    
    <content type="html"><![CDATA[<p>给自已取了一个新的网名，“夜听冰河”。<br>取自：《十一月四日风雨大作》作者：陆游 作于公元1192年<br>僵卧孤村不自哀，尚思为国戍轮台。<br>夜阑卧听风吹雨，铁马冰河入梦来。<br>夜深了，年近古稀（陆游生于公元1125年，此诗作于1192年，当时作者67岁）的一老翁直挺挺的躺在孤寂荒凉的小乡村里，一边听着外面的风吹着雨，雨又打着风，一边又在想如今虽身处荒野，但这又算得了什么，哪里有值得感到悲哀的，只要我还能再为国家戍守边疆，再出一份力，听着听着，想着想着，竟迷迷糊糊睡着了，仿佛真的回到了边关，骑着披甲的战马，跨过冰封的河流。。。<br>如实说，这首诗读高中时学习过，也理解诗要表达的感情，但是偶然间，脑子里不自主的闪现出，“夜阑卧听风吹雨，铁马冰河入梦来。”，就再次去品味这首诗，竟别有另一番感触。只能说好的诗人，一定是一个感情充沛，精神世界丰富的人；好的诗，一定是最简单的文字里承载着最真挚的感情。无疑，陆游是一个伟大的诗人，他的这首十一月四日风雨大作也是一首不朽的诗。从放翁先生的诗中，感受到了真挚爱国报国之情，也看到一年近七十的老翁，人生失意，壮志未酬，不是追悔，不是抱怨，亦不是叹时光匆匆，却是年老之躯，少年雄心，做梦都在想着能披甲再战，一颗不屈之心，一副铮铮之骨跃然纸上。也许正是先生这不屈之心，铮铮之骨早已烙入我心，才会在某一刻闪现在我的脑海中。<br>诗解析完了，思考却没有停止，为什么后两句突然会跃现于我的脑海里？对于现代社会的人们，确切说是世俗社会的人们来说，一首写于829年前的诗，还有什么意义？<br>澄清一点我这里之所以说是世俗社会的，是因为当前社会世俗规则大行其道，有人可能不解了，什么又是世俗规则呢？简单说：搞钱第一，有钱就代表成功，没有挣到钱就代表失败，金钱第一，也是实力、地位的象征。而我所理解的现代社会，是物质与精神同等重要的社会，人们除了追求更高的物质生活，也漫游于丰富的精神海洋。因商场失败，跳楼自杀；因家产继承，兄弟反目；因一己贪欲，行贿受贿索贿如登大堂。凡此种种，数不胜数。<br>其实这一切的后果，都是可以避免的，但前提是你的精神世界是丰富的、充沛的，无论得意、失意，都能为你点燃一盏灯火，指引你前行。对于身负巨额债务的人来说，如果你听过“海到尽头天作岸，山登绝顶我为峰。如日东山能再起，大鹏展翅恨天低。”，哪还用以寻死求解脱；如果你明白“打虎亲兄弟，上阵父子兵”、“兄弟阋于墙，外御其侮”，家资丰厚或贫瘠，当兄谦弟恭，戮力同心，何愁家道不兴？身居显位，是实力所至，已得人前之贵，如果你懂得，“为天地立心，为生民立命，为往圣继绝学，为万世开太平。”，又何必以蝇蝇之利污洁白之羽，展天之翅。<br>很喜欢，沈复在《浮生六记》中的一段话，送给自己及所有精神世界还很贫瘠的人：世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。<br>多么的洒脱无碍，来去如风呀，只要过得幸福、轻松、自在，何必为多拿两个铜板而机关算尽？</p>]]></content>
    
    
    <summary type="html">世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>岁月磨我少年志</title>
    <link href="https://gaoxing27.gitee.io/2021/12/20/%E5%B2%81%E6%9C%88%E7%A3%A8%E6%88%91%E5%B0%91%E5%B9%B4%E5%BF%97/"/>
    <id>https://gaoxing27.gitee.io/2021/12/20/%E5%B2%81%E6%9C%88%E7%A3%A8%E6%88%91%E5%B0%91%E5%B9%B4%E5%BF%97/</id>
    <published>2021-12-20T06:49:14.000Z</published>
    <updated>2022-02-28T02:57:12.251Z</updated>
    
    <content type="html"><![CDATA[<p>岁月磨我少年志<br>时光凉我善良心<br>总有人间一两风<br>填我十万八千梦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;岁月磨我少年志&lt;br&gt;时光凉我善良心&lt;br&gt;总有人间一两风&lt;br&gt;填我十万八千梦&lt;/p&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>终日奔波只为饥</title>
    <link href="https://gaoxing27.gitee.io/2021/11/29/%E7%BB%88%E6%97%A5%E5%A5%94%E6%B3%A2%E5%8F%AA%E4%B8%BA%E9%A5%A5/"/>
    <id>https://gaoxing27.gitee.io/2021/11/29/%E7%BB%88%E6%97%A5%E5%A5%94%E6%B3%A2%E5%8F%AA%E4%B8%BA%E9%A5%A5/</id>
    <published>2021-11-29T12:40:12.000Z</published>
    <updated>2021-12-09T10:53:32.595Z</updated>
    
    <content type="html"><![CDATA[<p>终日奔波只为饥<br>方才一饱便思衣<br>衣食两般皆具足<br>又思娇柔美貌妻</p><span id="more"></span><p>娶得美妻生下子<br>恨无田地少根基<br>门前买下田千顷<br>又思出门少马骑<br>槽头拴了骡和马<br>又思无官被人欺<br>一品当朝为宰相<br>还想山河夺帝基<br>心满意足为天子<br>又想长生不老期<br>一旦求得长生药<br>再跟上帝论高低</p><blockquote><p>—-来源于网络</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;终日奔波只为饥&lt;br&gt;方才一饱便思衣&lt;br&gt;衣食两般皆具足&lt;br&gt;又思娇柔美貌妻&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>node-基本原理及工作流程</title>
    <link href="https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-16T02:52:33.000Z</published>
    <updated>2021-06-27T14:16:13.808Z</updated>
    
    <content type="html"><![CDATA[<p>Node 是一个服务器端 JavaScript 解释器，可以方便地搭建出响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型，非常适合在分布式设备上运行数据密集型的实时应用。</p><p>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台，功能完善，它实现了诸如文件系统、模块、包、操作系统 API、网络通信等功能 。</p><h3 id="v8引擎"><a href="#v8引擎" class="headerlink" title="v8引擎"></a>v8引擎</h3><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎，负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；你可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p><h3 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h3><p>Java，PHP等编程语言是面向对象编程，Node是事件驱动编程的思想。<br>事件驱动编程，即为需要处理的事件编写相应的事件处理程序，代码在事件发生时执行，当事件触发时被操作系统唤醒，这样能更加有效地使用cpu。<br>事件驱动模型如图：</p><p><img src="/images/node/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" alt="事件驱动模型"></p><p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p><ul><li><p>事件源：产生事件的地方(html元素)</p></li><li><p>事件：点击/鼠标操作/键盘操作等等</p></li><li><p>事件对象：当某个事件发生时，可能会产生一个事件对象，该事件对象会封装好该事件的信息，传递给事件处理程序</p></li><li><p>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。</p><p>我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">e</span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.alert(<span class="string">&quot;x=&quot;</span>+e.clientX+<span class="string">&quot;y=&quot;</span>+e.clientY); </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span> <span class="attr">onmousedown</span>=<span class="string">&quot;test1(event)&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h3><p>通常应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，而CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务，所以I/O才是应用程序的瓶颈所在；在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。</p><p>《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</p><p><img src="/images/node/node%E6%94%AF%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="node支行流程图"></p><p>Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。</p><p>Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br>在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/xiangzhihong8/article/details/53954600">https://blog.csdn.net/xiangzhihong8/article/details/53954600</a></p></blockquote>]]></content>
    
    
    <summary type="html">Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</summary>
    
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>图解kafka</title>
    <link href="https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/"/>
    <id>https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/</id>
    <published>2021-06-15T07:47:44.000Z</published>
    <updated>2021-07-08T13:25:02.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。</p><p><img src="/images/kafka/base.jpg" alt="kafka"></p><p>生产者消费者<br>生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7-kafka-%E6%B6%88%E8%B4%B9.jpg" alt="生产-kafka-消费"></p><p>一个服务可以同时为生产者和消费者。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85-kafka.png" alt="生产消费者-kafka"></p><h3 id="Topics-主题"><a href="#Topics-主题" class="headerlink" title="Topics 主题"></a>Topics 主题</h3><p>Topic 是生产者发送消息的目标地址，是消费者的监听目标。</p><p><img src="/images/kafka/kafka-topic.png" alt="kafka-topic"></p><p>一个服务可以监听、发送多个 Topics。</p><p><img src="/images/kafka/%E5%8D%95%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AATopics.png" alt="单个服务监听多个Topics"></p><p>Kafka 中有一个【consumer-group（消费者组）】的概念。</p><p>这是一组服务，扮演一个消费者。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84.png" alt="消费者组"></p><p>如果是消费者组接收消息，Kafka 会把一条消息路由到组中的某一个服务。</p><p><img src="/images/kafka/%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1.png" alt="路由消息到消费者组中的某一个服务"></p><p>这样有助于消息的负载均衡，也方便扩展消费者。</p><p>Topic 扮演一个消息的队列。</p><p>首先，一条消息发送了。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E5%88%B0topic.png" alt="生产消息到topic"></p><p>然后，这条消息被记录和存储在这个队列中，不允许被修改。</p><p><img src="/images/kafka/topic%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9.png" alt="topic中的消息不允许修改"></p><p>接下来，消息会被发送给此 Topic 的消费者。</p><p>但是，这条消息并不会被删除，会继续保留在队列中。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E5%B9%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BC%9A%E7%BB%A7%E7%BB%AD%E4%BF%9D%E7%95%99%E5%9C%A8%E9%98%9F%E5%88%97.png" alt="消息并不会被删除，会继续保留在队列"></p><p>继续发送消息。</p><p><img src="/images/kafka/%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="继续发送消息"></p><p>像之前一样，这条消息会发送给消费者、不允许被改动、一直呆在队列中。</p><p>（消息在队列中能呆多久，可以修改 Kafka 的配置）</p><p><img src="/images/kafka/a.png" alt="a"></p><p><img src="/images/kafka/b.png" alt="b"></p><h3 id="Partitions-分区"><a href="#Partitions-分区" class="headerlink" title="Partitions 分区"></a>Partitions 分区</h3><p>上面 Topic 的描述中，把 Topic 看做了一个队列，实际上，一个 Topic 是由多个队列组成的，被称为【Partition（分区）】。</p><p>这样可以便于 Topic 的扩展。</p><p><img src="/images/kafka/topic-Partitions.png" alt="topic-Partitions"></p><p>生产者发送消息的时候，这条消息会被路由到此 Topic 中的某一个 Partition。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0Topic%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAPartition.png" alt="生产者发送消息到Topic中的某一个Partition"></p><p>消费者监听的是所有分区。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA.png" alt="消费者监听的是所有分区"></p><p>生产者发送消息时，默认是面向 Topic 的，由 Topic 决定放在哪个 Partition，默认使用轮询策略。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%94%B1Topic%E5%86%B3%E5%AE%9A%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AAPartition.png" alt="产者发送消息由Topic决定放在哪个Partition"></p><p>也可以配置 Topic，让同类型的消息都在同一个 Partition。</p><p>例如，处理用户消息，可以让某一个用户所有消息都在一个 Partition。</p><p>例如，用户1发送了3条消息：A、B、C，默认情况下，这3条消息是在不同的 Partition 中（如 P1、P2、P3）。</p><p>在配置之后，可以确保用户1的所有消息都发到同一个分区中（如 P1）。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="消息有序性"></p><p>这个功能有什么用呢？</p><p>这是为了提供消息的【有序性】。</p><p>消息在不同的 Partition 是不能保证有序的，只有一个 Partition 内的消息是有序的。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A72.png" alt="消息有序性2"></p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A73.png" alt="消息有序性3"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Kafka 是集群架构的，ZooKeeper是重要组件。</p><p><img src="/images/kafka/kafka-zookeeper.png" alt="kafka-zookeeper"></p><p>ZooKeeper 管理者所有的 Topic 和 Partition。</p><p>Topic 和 Partition 存储在 Node 物理节点中，ZooKeeper负责维护这些 Node。</p><p><img src="/images/kafka/kafka-zookeeper-znode.png" alt="kafka-zookeeper-znode"></p><p>例如，有2个 Topic，各自有2个 Partition。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B.png" alt="示例.png"></p><p>这是逻辑上的形式，但在 Kafka 集群中的实际存储可能是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B2.png" alt="示例2"></p><p>Topic A 的 Partition #1 有3份，分布在各个 Node 上。</p><p>这样可以增加 Kafka 的可靠性和系统弹性。</p><p>3个 Partition #1 中，ZooKeeper 会指定一个 Leader，负责接收生产者发来的消息。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B3.png" alt="示例3"></p><p>其他2个 Partition #1 会作为 Follower，Leader 接收到的消息会复制给 Follower。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B4.png" alt="示例4"></p><p>这样，每个 Partition 都含有了全量消息数据。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B5.png" alt="示例5"></p><p>即使某个 Node 节点出现了故障，也不用担心消息的损坏。</p><p>Topic A 和 Topic B 的所有 Partition 分布可能就是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B6.png" alt="示例6"></p><blockquote><p>原文<br>-<a href="https://blog.csdn.net/duysh/article/details/116355977">https://blog.csdn.net/duysh/article/details/116355977</a></p></blockquote>]]></content>
    
    
    <summary type="html">kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。一个服务可以同时为生产者和消费者。Topic 是生产者发送消息的目标地址，是消费者的监听目标。</summary>
    
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/categories/kafka/"/>
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/tags/kafka/"/>
    
    <category term="消息队列" scheme="https://gaoxing27.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="中间件" scheme="https://gaoxing27.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>简单生活，努力工作，爱自己爱家人</title>
    <link href="https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/"/>
    <id>https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/</id>
    <published>2021-06-01T10:32:48.000Z</published>
    <updated>2021-06-01T11:59:46.029Z</updated>
    
    <content type="html"><![CDATA[<p>静心平想，其实我是一个很幸运的人，我挺知足。</p><p>上学时代，激情满怀，却资质平庸，成绩上并无高点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。我不想一下就耗尽自己的力气，同时也没有来得及去享受加油和呐喊助威。我希望我拼得不是速度，而是耐力。也许我跑的不是最快，不是第一，但是每坚实的跑出一步，都是我对的人生发于心的热爱，我会记住沿途的每一张笑脸和每一个从身边的奔跑过的人。</p><p>最近躺平、内卷，这两个词挺热的，了解完躺平、内卷，我简直下巴要掉到地上了，虽然现在生活好了，同时压力更大了，竞争更激烈，但是通过这种方式来对表达自己的反抗，太愚蠢了。也许目标看似遥不可及，如果躺下了，真就不可及了。</p><p>聪明的人善于计算，以现在的能力再怎么努力，也买不起房子、谈不起恋爱、结不起婚、生得起养不起孩子、上不起医院看不起病……，我感觉这些计算都是错的，这让我想起一个成语故事：刻舟求剑；社会在发展，经济在发展，人也在发展，发展就是变化，既然一切都是在变化中，为什么要用现在来计算未来，这哪是聪明，简直愚蠢；人类已经登上了月球，以后也许还会上火星，以后的以后还有更多的未知和惊喜</p><p>停止焦虑对你的束缚吧，世界上没有一种精密的模型可以计算未来，计算人的潜力，计算人的决心 </p><p>拾起这好时光，决心让自己变简单，让生活变简单，努力爱自己、家人和工作</p>]]></content>
    
    
    <summary type="html">静心平想，其实我是一个很幸运的人，应该知足。 上学时代，激情满怀，却资质平庸，成绩上并无高点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-spring-原理</title>
    <link href="https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-28T09:35:13.000Z</published>
    <updated>2021-06-30T10:59:27.129Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：</p><ul><li>添加dubbo-spring-boot-starter依赖</li><li>定义@org.apache.dubbo.config.annotation.Service注解</li></ul><p>声明@DubboComponentScan，用于扫描@Service注解，Dubbo中的@Service注解和Spring中提供的@Service注解功能类似，用于实现Dubbo服务的暴露，与它相对应的时@Reference，它的作用类似于Spring中的@Autowired注解。而@DubboComponentScan和Spring中的@ComponentScan作用类似，用于扫描@Service、@Reference等注解。</p><h3 id="DubboComponentScan注解解析"><a href="#DubboComponentScan注解解析" class="headerlink" title="@DubboComponentScan注解解析"></a>@DubboComponentScan注解解析</h3><p><strong>DubboComponentScan</strong>注解的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解主要通过@Import导入一个DubboComponentScanRegistrar类。DubboComponentScanRegistrar实现了ImportBeanDefinitionRegistrar接口，并且重写了registerBeanDefinitions方法。在registerBeanDefinitions方法中主要做了以下几件事：</p><ul><li>获取扫描包的路径，默认扫描当前配置类所在的包</li><li>注册@Service注解的解析类</li><li>注册@Reference注解的解析类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refisterBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportBeanDefinitionRegistrar是Spring提供的一种动态注入Bean的机制，和ImportSelector接口的功能类似，在refisterBeanDefinitions方法中，主要会实例化一些BeanDefinition并且注入到Spring IoC容器中；继续看registerServiceAnnotationBeanPostProcessor()方法，逻辑比较简单，就是把SerficeAnnotationBeanPostProcessor注册到容器；registerReferenceAnnotationBeanPostProcessor()方法是把ReferenceAnnotationBeanPostProcessor注册到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构建BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(<span class="number">2</span>);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 把BeanDefinition注册到IoC容器中</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Service解析"><a href="#Service解析" class="headerlink" title="@Service解析"></a>@Service解析</h3><p>ServiceAnnotationBeanPostProcessor用于解析@Service注解，ReferenceAnnotationBeanPostProcessor用于解析@Reference注解</p><h3 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h3><p>ServiceAnnotationBeanPostProcessor类的定义如下，它的核心逻辑就是解析@Service注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor实现了4个接口，EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware这三个接口比较好理解，重点看一下BeanDefinitionRegistryPostProcessor；BeanDefinitionRegistryPostProcessor接口继承自BeanFactoryPostProcessor，是一种比较特殊的BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor中的postProcessBeanDefinitionRegistry方法可以让我们实现自定义的注册Bean定义的逻辑。该方法主要做了以下几件事：</p><ul><li>调用registerBeans注册DubboBootstrapApplicationListener类</li><li>通过resolvePackagesToScan对packagesToScan参数进行去空格处理，并把配置文件中配置的扫描参数也一起处理。</li><li>调用registerServiceBeans完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, <span class="keyword">new</span> Class[]&#123;DubboBootstrapApplicationListener.class&#125;);</span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = <span class="keyword">this</span>.resolvePackagesToScan(<span class="keyword">this</span>.packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">&quot;packagesToScan is empty , ServiceBean registry will be ignored!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postProcessBeanDefinitionRegistry()方法的核心逻辑都在registerServiceBeans这个方法中，这个方法会查找需要扫描的指定包里面有@Service注解的类并将其注册成Bean。</p><ul><li>定义DubboClassPathBeanDefinitionScanner扫描对象，扫描指定路径下的类，将符合条件的类装配到IoC容器中。</li><li>BeanNameGenerator是Beans体系中比较重要的一个组件，会通过一定的算法计算出需要装配的Bean的name。</li><li>addIncludeFilter设置Scan的过滤条件，只扫描@Service注解修饰的类。</li><li>遍历指定的包，通过findServiceBeanDefinitionHolders查找@Service注解修饰的类。</li><li>通过registerServiceBean完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan The base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">                <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">            scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                    registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(beanDefinitionHolders.size() + <span class="string">&quot; annotated Dubbo&#x27;s @Service Components &#123; &quot;</span> +</span><br><span class="line">                            beanDefinitionHolders +</span><br><span class="line">                            <span class="string">&quot; &#125; were scanned under package[&quot;</span> + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span></span><br><span class="line">                            + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码主要作用就是通过扫描指定路径下添加了@Service注解的类，通过registerServiceBean来注册ServiceBean，整体来看，Dubbo的注解扫描进行服务发布的过程，实际上就是基于Spring的扩展。</p><p>继续分析registerServiceBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">     Service service = findAnnotation(beanClass, Service.class);</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">     String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">     AbstractBeanDefinition serviceBeanDefinition =</span><br><span class="line">             buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ServiceBean Bean name</span></span><br><span class="line">     String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; <span class="comment">// check duplicated candidate bean</span></span><br><span class="line">         registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">&quot;The BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean has been registered with name : &quot;</span> + beanName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">             logger.warn(<span class="string">&quot;The Duplicated BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean[ bean name : &quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;] was be found , Did @DubboComponentScan scan to same package in many times?&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resolveClass获取BeanDefinitionHolder中的Bean</li><li>findServiceAnnotation方法从beanClass类中找到@Service注解</li><li>getAnnotationAttributes方法获得注解中的属性，比如loadBalance、cluster等。</li><li>resolveServiceInterfaceClass方法用于获得beanClass对应的接口定义，其实在@Service(interfaceClass=xxxx.class)注解的声明中也可以声明interfaceClass，注解中声明的优先级最高，如果没有声明该属性，则会从父类中查找。</li><li>annotatedServiceBeanName代表Bean的名称。</li><li>buildServiceBeanDefinition用来构造org.apache.dubbo.config.spring.ServiceBean对象，每个Dubbo服务的发布最终都会出现一个ServiceBean。</li><li>调用registerBeanDefinition将ServiceBean注入Spring IoC容器中。</li></ul><p>从整个方法的分析来看，registerServiceBean方法主要是把一个ServiceBean注入到Spring IoC容器中，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不是像普通的Bean注入一样直接将HelloServiceImpl对象的实例注入容器，而是注入一个ServiceBean对象。对于HelloServiceImpl来说，它并不需要把自己注入Spring IoC容器中，而是需要把自己发布到网络上，提供给网络上的服务消费者来访问。那它是怎么发布到网络上的呢？</p><p>上面在postProcessBeanDefinitionRegistry方法中注册了DubboBootstrapApplicationListener事件监听Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrapApplicationListener</span> <span class="keyword">extends</span> <span class="title">OneTimeExecutionApplicationContextEventListener</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DubboBootstrap dubboBootstrap = DubboBootstrap.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrapApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextRefreshedEvent((ContextRefreshedEvent)event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextClosedEvent((ContextClosedEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的Bean都处理完成之后，Spring IoC会发布一个事件，事件类型为ComtextRefreshedEvent，当触发整个事件时，会调用onContextRefreshedEvent方法。在这个方法中，可以看到Dubbo服务启动的触发机制dubboBootstrap.start()。从这个方法中会进入org.apache.dubbo.config.ServiceConfig类中的export()方法，这个方法会启动一个网络监听，从而实现服务发布。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/yangbaggio/article/details/105913431">https://blog.csdn.net/yangbaggio/article/details/105913431</a></p><p><a href="https://blog.csdn.net/DaySurprise/article/details/114897735">https://blog.csdn.net/DaySurprise/article/details/114897735</a></p><p><a href="https://www.cnblogs.com/jackion5/p/11219707.html">https://www.cnblogs.com/jackion5/p/11219707.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">使用Dubbo最方便的地方在于它可以和Spring非常方便的集成，实际上，Dubbo对于配置的优化，也是随着Spring一同发展的，从最早的XML形式到后来的注解方式以及自动装配，都是在不断地简化开发过程来提高开发效率。在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：添加dubbo-spring-boot-starter依赖;定义@org.apache.dubbo.config.annotation.Service注解</summary>
    
    
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/categories/Dubbo/"/>
    
    
    <category term="Spring" scheme="https://gaoxing27.gitee.io/tags/Spring/"/>
    
    <category term="Springboot" scheme="https://gaoxing27.gitee.io/tags/Springboot/"/>
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo-原理</title>
    <link href="https://gaoxing27.gitee.io/2021/05/27/dubbo-%E5%8E%9F%E7%90%86/"/>
    <id>https://gaoxing27.gitee.io/2021/05/27/dubbo-%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-27T11:22:17.000Z</published>
    <updated>2021-06-30T10:59:22.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dubbo基础"><a href="#dubbo基础" class="headerlink" title="dubbo基础"></a>dubbo基础</h2><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。</p><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架Dubbo就出现了</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul><li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li><li>软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><strong>核心组件</strong></h4><ul><li><p>Provider：暴露服务的服务提供方</p></li><li><p>Consumer：调用远程服务消费方</p></li><li><p>Registry：服务注册与发现注册中心</p></li><li><p>Monitor：监控中心和访问调用统计</p></li><li><p>Container：服务运行容器</p><p><strong>注册中心</strong></p><p>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</p></li></ul><p><img src="/images/dubbo/Dubbo%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="Dubbo核心组件"></p><h4 id="服务注册与发现流程"><a href="#服务注册与发现流程" class="headerlink" title="服务注册与发现流程"></a><strong>服务注册与发现流程</strong></h4><ul><li>服务容器Container负责启动，加载，运行服务提供者。</li><li>服务提供者Provider在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</p><ul><li>接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</li><li>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li><li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</li><li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li><li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</li><li>远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li><li>网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li><li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</li></ul><p><img src="/images/dubbo/Dubbo%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="dubbo架构设计图"></p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>服务器端（服务提供者） 在框架启动时， 会初始化服务实例， 通过Proxy组件调<br>用具体协议（Protocol ） ,把服务端要暴露的接口封装成Invoker （真实类型是<br>AbstractProxylnvoker）,然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例<br>到内存中， 最后通过Registry把服务元数据注册到注册中心和本地。   </p><p>Proxy组件： Dubbo框架生成的代理类， 调用的方法其实是Proxy组件生成的代理方法， 会自动发起远程/本地调用， 并返回结果,<br>整个过程对用户完全透明。</p><p> Protocol： 协议就是对数据格式的一种约定。 它可以把我们对接口的配置,<br>根据不同的协议转换成不同的Invoker对象。 例如： 用DubboProtocol可以把XML文<br>件中一个远程接口的配置转换成一个Dubbolnvoker</p><p>Exporter： 用于暴露到注册中心的对象， 它的内部属性持有了 Invoker对象， 我们可以<br>认为它在Invoker上包了 一层。</p><p>Registry： 把Exporter注册到注册中心  </p><h4 id="服务调用过程"><a href="#服务调用过程" class="headerlink" title="服务调用过程"></a>服务调用过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>调用过程也是从一个Proxy开始的， Proxy持有了一个Invoker对象。 然后触发invoke<br>调用。 在invoke调用过程中， 需要使用Cluster, Cluster负责容错， 如调用失败的重试。 Cluster<br>在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表（一个接口可能有多个<br>节点提供服务） 。 由于可以调用的远程服务有很多， 此时如果用户配置了路由规则（如指定某些<br>方法只能调用某个节点） ， 那么还会根据路由规则将Invoker列表过滤一遍。<br>然后， 存活下来的Invoker可能还会有很多，于是会继续通过<br>LoadBalance方法做负载均衡， 最终选出一个可以调用的Invokero这个Invoker在调用之前又会<br>经过一个过滤器链， 这个过滤器链通常是处理上下文、 限流、 计数等。<br>接着， 会使用Client做数据传输， 如我们常见的Netty Client等。 传输之前肯定要做一些私<br>有协议的构造， 此时就会用到Codec接口。 构造完成后， 就对数据包做序列化（Serialization）,<br>然后传输到服务提供者端。 服务提供者收到数据包， 也会使用Codec处理协议头及一些半包、<br>粘包等。 处理完成后再对完整的数据报文做反序列化处理。<br>随后， 这个Request会被分配到线程池（ThreadPool）中进行处理。Server会处理这些Request,<br>根据请求查找对应的Exporter （它内部持有了 Invoker）。 Invoker是被用装饰器模式一层一层套<br>了非常多Filter的， 因此在调用最终的实现类之前， 又会经过一个服务提供者端的过滤器链。<br>最终， 我们得到了具体接口的真实实现并调用， 再原路把结果返回。<br>至此， 一个完整的远程调用过程就结束了。 </p><h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>SPI，Service Provider Interface，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader</p><p> Dubbo 并未使用Java SPI，而是重新实现了一套功能更强的SPI机制。Dubbo SPI的相关逻辑被封装在了ExtensionLoader类中，通过ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI所需的配置文件，需放置在META-INF/dubbo路径下</p><p>与Java SPI实现类配置不同，Dubbo SPI是通过键值对的方式进行配置。这样我们可以按需加载指定的实现类。另外在测试Dubbo SPI时，需要在Robot接口上标注@SPI注解 </p><h4 id="monitor原理"><a href="#monitor原理" class="headerlink" title="monitor原理"></a>monitor原理</h4><ul><li>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。</li></ul><ol><li>MonitorFilter 向 DubboMonitor 发送数据</li><li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference</li><li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大写为 100000）</li><li>SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以死循环的形式来写）</li><li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</li></ol><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>默认：Random LoadBalance:</p><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><h4 id="集群容错机制"><a href="#集群容错机制" class="headerlink" title="集群容错机制"></a>集群容错机制</h4><p>默认：Failover Cluster</p><ul><li>Failover </li></ul><p>当出现失败时， 会重试其他服务器。 用户可以通过retries=”2n设置重试次数。 这是<br>Dubbo的默认容错机制， 会对请求做负载均衡。 通常使用在读操作或幕等的写操作上，<br>但重试会导致接口的延退增大， 在下游机器负载已经达到极限时， 重试容易加重下游<br>服务的负载</p><ul><li>Failfast</li></ul><p> 快速失败， 当请求失败后， 快速返回异常结果， 不做任何重试。 该容错机制会对请求<br>做负载均衡， 通常使用在非幕等接口的调用上。 该机制受网络抖动的影响较大</p><ul><li>Failsafe</li></ul><p> 当出现异常时， 直接忽略异常。 会对请求做负载均衡。 通常使用在“佛系” 调用场景，<br>即不关心调用是否成功， 并且不想抛异常影响外层调用， 如某些不重要的日志同步， 即使出现异常也无所谓</p><ul><li>Fallback</li></ul><p> 请求失败后， 会自动记录在失败队列中， 并由一个定时线程池定时重试， 适用于一些<br>异步或最终一致性的请求。 请求会做负载均衡</p><ul><li>Forking</li></ul><p> 同时调用多个相同的服务， 只要其中一个返回， 则立即返回结果。 用户可以配置forks=“最大并行调用数” 参数来确定最大并行调用的服务数量。 通常使用在对接口<br>实时性要求极高的调用上， 但也会浪费更多的资源</p><ul><li>Broadcast </li></ul><p>广播调用所有可用的服务， 任意一个节点报错则报错。 由于是广播， 因此请求不需要<br>做负载均衡。 通常用于服务状态更新后的广播</p><ul><li>Mock</li></ul><p> 提供调用失败时， 返回伪造的响应结果。 或直接强制返回伪造的结果， 不会发起远程<br>调用</p><ul><li>Available </li></ul><p>最简单的方式， 请求不会做负载均衡， 遍历所有服务列表， 找到第一个可用的节点，<br>直接请求并返回结果。 如果没有可用的节点， 则直接抛出异常</p><ul><li>Mergeable </li></ul><p>Mergeable可以自动把多个节点请求得到的结果进行合并</p><h4 id="调用超时设置"><a href="#调用超时设置" class="headerlink" title="调用超时设置"></a>调用超时设置</h4><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><ul><li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>Dubbo注册中心集群挂掉之后，消费者和生产者之间可以继续通信；因为在Dubbo启动时，消费者会从注册中心Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地，每次调用时，按照本地缓存的地址调用就可以。</p><p>默认使用 Netty 作为通讯框架。</p><p>支持的通信协议：</p><ul><li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</li><li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li><li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li><li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li><li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li><li>Memcache：基于 Memcache实现的 RPC 协议。</li><li>Redis：基于 Redis 实现的RPC协议。</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>为保证在远程调用过程中对象的完整性和可传递性，服务消费者和服务提供者之间传递数据的时候需要进行序列化和反序列化，默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><p>序列化：把对象转换成有序的二进制字节流，以便在网络上传输或者保存在本地文件中</p><p>反序列化：把序列化后的对象的二进制字节流通过反序列化重建对象。</p><h4 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h4><ul><li>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</li><li>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</li></ul><h3 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h3><ul><li><p>工厂模式</p></li><li><p>装饰器模式</p></li><li><p>观察者模式</p></li><li><p>动态代理模式</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="版本兼容性问题"><a href="#版本兼容性问题" class="headerlink" title="版本兼容性问题"></a>版本兼容性问题</h4><p>可以用版本号（version）解决兼容性问题，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用</p><h4 id="与SpringCloud关系"><a href="#与SpringCloud关系" class="headerlink" title="与SpringCloud关系"></a>与SpringCloud关系</h4><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p><h4 id="与SpringCloud区别"><a href="#与SpringCloud区别" class="headerlink" title="与SpringCloud区别"></a>与SpringCloud区别</h4><ul><li><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p></li><li><p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p></li></ul><h4 id="与Dubbox的区别"><a href="#与Dubbox的区别" class="headerlink" title="与Dubbox的区别"></a>与Dubbox的区别</h4><ul><li>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</li></ul><blockquote><p>引用<br><a href="https://juejin.cn/post/6844904127076499463">https://juejin.cn/post/6844904127076499463</a><br><a href="https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA">https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA</a></p></blockquote>]]></content>
    
    
    <summary type="html">Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架Dubbo就出现了</summary>
    
    
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/categories/Dubbo/"/>
    
    
    <category term="Spring" scheme="https://gaoxing27.gitee.io/tags/Spring/"/>
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>redis-线程模型</title>
    <link href="https://gaoxing27.gitee.io/2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gaoxing27.gitee.io/2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-05-27T09:27:14.000Z</published>
    <updated>2021-06-30T10:41:43.697Z</updated>
    
    <content type="html"><![CDATA[<p> redis是单线程模型，所谓单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块该使用多线程仍会使用了多个线程。redis是基于内存的，那么<code>CPU</code>不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。</p><p><code>Redis</code>基于<code>Reactor</code>模式开发了自己的网络事件处理器，称之为文件事件处理器(<code>File Event Hanlder</code>)。文件事件处理器由<code>Socket</code>、<code>IO</code>多路复用程序、文件事件分派器(<code>dispather</code>)，事件处理器(<code>handler</code>)四部分组成。文件事件处理器的模型如下所示：</p><p><img src="/images/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="redis线程模型图"></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p><code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。<code>IO</code>多路复用程序会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，文件事件分派器接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的事件处理器进行处理。</p><h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><ul><li><p>AE_READABLE</p><p>当客户端连接服务器端时，服务器端会将连接应答处理器与<code>socket</code>的<code>AE_READABLE</code>事件关联起来；</p><p>当客户端向服务端发送命令的时候，服务器端将命令请求处理器与<code>AE_READABLE</code>事件关联起来；</p></li><li><p>AE_WRITABLE</p><p>当服务端有数据需要回传给客户端时，服务端将命令回复处理器与<code>socket</code>的<code>AE_WRITABLE</code>事件关联起来。</p></li></ul><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul><li><strong>连接应答处理器</strong>：用于处理客户端的连接请求；</li><li><strong>命令请求处理器</strong>：用于执行客户端传递过来的命令；</li><li><strong>命令回复处理器</strong>：用于返回客户端命令的执行结果；</li></ul><h3 id="客户端与服务端交互"><a href="#客户端与服务端交互" class="headerlink" title="客户端与服务端交互"></a>客户端与服务端交互</h3><p><img src="/images/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" alt="redis客户端与服务端交互流程"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>I/O多路复用本来就是用来解决对多个I/O监听时，一个I/O阻塞影响其他I/O的问题</p><blockquote><p>引用<br><a href="https://juejin.cn/post/6844903849489235982">https://juejin.cn/post/6844903849489235982</a></p></blockquote>]]></content>
    
    
    <summary type="html">redis是单线程模型，更严谨一点，Redis的单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块该使用多线程，仍会使用了多个线程。redis是基于内存的，那么`CPU`不是`Redis`的瓶颈。`Redis`的瓶颈最有可能是机器内存或者网络带宽。</summary>
    
    
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/categories/redis/"/>
    
    
    <category term="IO" scheme="https://gaoxing27.gitee.io/tags/IO/"/>
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/tags/redis/"/>
    
    <category term="线程模型" scheme="https://gaoxing27.gitee.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>redis-集群</title>
    <link href="https://gaoxing27.gitee.io/2021/05/26/redis-%E9%9B%86%E7%BE%A4/"/>
    <id>https://gaoxing27.gitee.io/2021/05/26/redis-%E9%9B%86%E7%BE%A4/</id>
    <published>2021-05-26T09:41:51.000Z</published>
    <updated>2021-06-30T10:41:35.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>Redis Cluster是Redis官方提供的Redis集群功能，分布式架构，去中心化，即Redis Cluster中有多个节点，每个节点都负责进行数据读写操作，每个节点之间通过一种特殊的二进制 协议相互交互集群信息进行通信。Redis Cluster 将所有数据划分为 16384 的 slots，，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中， 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信 息。这样当客户端要查找某个 key 时，可以直接定位到目标节点。  另外，RedisCluster 的每个节点会将集群的配置信息持久化到配置文件中，所以 必须确保配置文件是可写的，而且尽量不要依靠人工修改配置文件。</p><p><img src="/images/redis/redis-cluster-%E6%9E%B6%E6%9E%84.png" alt="redis-cluster-架构"></p><p>跳转：当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并 不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点 地址，告诉客户端去连这个节点去获取数据。客户端收到 MOVED 指令后，要立即纠正本地的槽位映射表。后续所有 key 将 使用新的槽位映射表。</p><p>容错：Redis Cluster 可以为每个主节点设置若干个从节点，单主节点故障时，集群会 自动将其中某个从节点提升为主节点。如果某个主节点没有从节点，那么当它发 生故障时，集群将完全处于不可用状态。不过 Redis 也提供了一个参数 cluster-require-full-coverage 可以允许部分节点故障，其它节点还可以继续 提供对外访问。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="哨兵模式"></p><p>More Actions我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用 的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。 它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点 切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来 查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时， 客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户 端。如此应用程序将无需重启即可自动完成节点切换。比如上图的主节点挂掉 后，集群将可能自动调整为下图所示结构。</p><p><img src="/images/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BE%E5%90%8E.png" alt="哨兵模式重新选举后"></p><p>从这张图中我们能看到主节点挂掉了，原先的主从复制也断开了，客户端和损坏 的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点 建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经 挂掉了主节点，待它恢复后，原主节点成为新的主节点的从节点；</p><blockquote><p>引用：<br><a href="https://www.jianshu.com/p/813a79ddf932">https://www.jianshu.com/p/813a79ddf932</a><br>《Redis 深度历险：核心原理与应用实践》</p></blockquote>]]></content>
    
    
    <summary type="html">Redis Cluster是Redis官方提供的Redis集群功能，分布式架构，去中心化，即Redis Cluster中有多个节点，每个节点都负责进行数据读写操作，每个节点之间通过一种特殊的二进制 协议相互交互集群信息进行通信。Redis Cluster 将所有数据划分为 16384 的 slots，，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中， 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信 息。这样当客户端要查找某个 key 时，可以直接定位到目标节点。</summary>
    
    
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/tags/redis/"/>
    
  </entry>
  
</feed>
