<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静</title>
  
  <subtitle>五朝</subtitle>
  <link href="https://gaoxing27.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gaoxing27.gitee.io/"/>
  <updated>2022-03-25T05:24:06.701Z</updated>
  <id>https://gaoxing27.gitee.io/</id>
  
  <author>
    <name>夜听冰河</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache架构师总结的30条架构原则</title>
    <link href="https://gaoxing27.gitee.io/2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/"/>
    <id>https://gaoxing27.gitee.io/2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-25T03:52:33.000Z</published>
    <updated>2022-03-25T05:24:06.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作者叫 Srinath，是一位科学家，软件架构师，也是一名在分布式系统上工作的程序员。他是 Apache Axis2 项目的联合创始人，也是 Apache Software 基金会的成员。他是 WSO2 流处理器（wso2.com/analytics）的联席架构师。Srinath 撰写了两本关于 MapReduce 和许多技术文章的书。他获得了博士学位。来自美国印第安纳大学。  </p></blockquote><p>Srinath 通过不懈的努力最终总结出了 30 条架构原则，他主张架构师的角色应该由开发团队本身去扮演，而不是专门有个架构师团队或部门。而不是专门有个架构师团队或部门。Srinath 认为架构师应该扮演的角色是一个引导者，讨论发起者，花草修建者，而不是定义者和构建者。Srinath 为了解决团队内部的架构纷争和抉择，制定了以下 30 条原则，这些原则被成员们广泛认可，也成为了新手架构师的学习途径。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>原则 1：KISS(Keep it simple,sutpid) ：保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。  </p><blockquote><p>点评：简单即是复杂！拿你的代码来说，你想要写的简单且容易理解的话，你就需要花更多的时间去思考。  </p></blockquote><p>原则 2：YAGNI(You aren’t gonna need it)：不要去搞一些不需要的东西，需要的时候再搞吧。</p><blockquote><p>点评 : 这一点我被 diss 过好几次，之前的时候，我总是臆想觉得某个功能以后可能会用到，然后就顺手把它实现了，实际到了后面并没用上，反而造成了代码冗余。</p></blockquote><p>原则 3： 爬，走，跑。换句话说就是先保证跑通，然后再优化变得更好，然后继续优化让其变得伟大。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑（最大两周），然后去迭代。</p><p>原则 4：创建稳定、高质量的产品的唯一方法就是<strong>自动化测试</strong>。所有的都可以自动化，当你设计时，不妨想想这一点。</p><blockquote><p>点评：单侧还是很有必要的，但是没有一个恒定的标准说你应该怎么去做。</p></blockquote><p>原则 5： 时刻要想投入产出比（ROI）。就是划得来不。</p><p>原则 6： 了解你的用户，然后基于此来平衡你需要做哪些事情。不要花了几个月时间做了一个 devops 用户界面，最后你发现那些人只喜欢命令行。此原则是原则 5 的一个具体表现。</p><blockquote><p>点评:是否有站在用户的角度思考问题呢？是否是为了用新技术而用新技术？</p></blockquote><p>原则 7：设计和测试一个功能，尽可能的独立。当你做设计时，应该想想这一条。从长远来看这能给你解决很多问题，否则你的功能只能等待系统其他所有的功能都就绪了才能测试，这显然很不好。有了这个原则， 你的版本将会更加的顺畅。</p><p>原则 8： 不要搞花哨的。我们都喜欢高端炫酷的设计。最后我们搞了很多功能和解决方案到我们的架构中，然后这些东西根本不会被用到。<br>点评:简单点！说话的方式简单点！</p><h4 id="功能选择"><a href="#功能选择" class="headerlink" title="功能选择"></a>功能选择</h4><p>原则 9： 不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。这个观点主要思想就是你挑几个很少的使用场景，然后把它搞出来，然后发布上线让用户使用，然后基于体验和用户反馈再决定下一步要做什么。</p><p>原则 10： 尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。</p><p>原则 11： 等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。</p><p>原则 12：<strong>有时候你要有勇气和客户说不</strong>。这时候你需要找到一个更好的解决方案来去解决。记住亨利福特曾经说过的 ：”如果我问人们他们需要什么，他们会说我需要一匹速度更快的马”。记住：你是那个专家，你要去引导和领导。要去做正确的事情，而不是流行的事情。最终用户会感谢你为他们提供了汽车。</p><h4 id="服务端设计和并发"><a href="#服务端设计和并发" class="headerlink" title="服务端设计和并发"></a>服务端设计和并发</h4><p>原则 13：要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。</p><p>原则 14： 要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情。</p><p>原则 15：如果你的设计是一个无阻塞且事件驱动的架构，那么千万不要阻塞线程或者在这些线程中做一些 IO 操作，如果你做了，你的系统会慢的像骡子一样。</p><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>原则 16：无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来，这是起码的。</p><p>原则 17：保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便（使用原则 18）。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的。</p><p>原则 18：实现一个操作尽可能的幂等。这样的话就比较好恢复，而且你还处于至少一次传递（at least once delivery）的状态。</p><p>原则 19： 知道 CAP 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的。</p><p>原则 20： 分布式一致性无法扩展，也无法进行组通信，也无法进行集群范围内的可靠通信。理想情况下最大的节点限制为 8 个节点。</p><p>原则 21： 在分布式系统中，你永远无法避免延迟和失败。</p><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><p>原则 22： 要了解你的用户和清楚他们的目标。他们是新手、专家还是偶然的用户？他们了解计算机科学的程度。极客喜欢扩展点，开发者喜欢示例和脚本，而普通人则喜欢 UI。</p><p>原则 23： 最好的产品是不需要产品手册的。</p><blockquote><p>点评：这个是说产品易用。很多人觉得敏捷开发下不需要文档，实际上，一个系统即是在敏捷开发的情况下，有些必要的文档比如重大更新记录、相关硬件设施等等还是需要的。</p></blockquote><p>原则 24： 当你无法在两个选择中做决定的时候，请不要直接把这个问题通过提供配置选项的方式传递给用户。这样只能让用户更加的发懵。如果连你这个专家都无法选择的情况下，交给一个比你了解的还少的人这样合适吗？最好的做法的是每次都找到一个可行的选项；次好的做法是自动的给出选项，第三好的做法是增加一个配置参数，然后设置一个合理的默认值。</p><p>原则 25： 总是要为配置设置一个合理的默认值。</p><p>原则 26：设计不良的配置会造成一些困扰。应该总是为配置提供一些示例值。</p><p>原则 27： 配置值必须是用户能够理解和直接填写的。比如：不能让用户填写最大缓存条目的数量，而是应该让用户填写可被用于缓存的最大内存。</p><p>原则 28： 如果输入了未知的配置要抛出错误。永远不要悄悄的忽略。悄悄的忽略配置错误往往是找 bug 花了数小时的罪魁祸首。</p><h4 id="艰难的问题"><a href="#艰难的问题" class="headerlink" title="艰难的问题"></a>艰难的问题</h4><p>原则 29： 梦想着新的编程语言就会变得简单和明了，但往往要想真正掌握会很难。不要轻易的去换编程语言。</p><p>原则 30： 复杂的拖拉拽的界面是艰难的，不要去尝试这样的效果，除非你准备好了 10 人年的团队。</p><p>最后，说一个我的感受。在一个理想的世界里，一个平台应该是有多个正交组件组成-每个组件都负责一个方面（比如，security，messaging，registry，mdidation，analytics）。好像一个系统构建成这样才是完美的。</p><p>但不幸的是，现实中我们很难达到这样的状态。因为在项目初始状态时，很多事情是不确定的，你无法做到这样的独立性，现在我更倾向于在开始的时候适当的重复是必要的，当你尝试铲除他们的时候，你会发现引入了新的复杂性，分布本身就意味着复杂。有时候治愈的过程要比疾病本身更加的糟糕。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为一个架构师，应该像园丁一般，更多的是修剪花草，除草而不是去定义和构建，你应该策划而不是指挥，你应该去修剪而不是去定义，应该是讨论而不是贴标签。</p><p>虽然在短期内可能会觉得也没什么，但从长远看，指导团队找到自己的方式会带来好处。如果你稍不留神，就很容易让架构成为一个空洞的词汇。比如设计者会说他的架构是错误的，但不知道为什么是错误的。一个避免这种情况的好办法就是有一个原则列表，这个原则列表是被广泛接受的，这个列表是人们讨论问题的锚点，也是新手架构师学习的路径。</p>]]></content>
    
    
    <summary type="html">Srinath 通过不懈的努力最终总结出了 30 条架构原则，他主张架构师的角色应该由开发团队本身去扮演，而不是专门有个架构师团队或部门。而不是专门有个架构师团队或部门。Srinath 认为架构师应该扮演的角色是一个引导者，讨论发起者，花草修建者，而不是定义者和构建者。Srinath 为了解决团队内部的架构纷争和抉择，制定了以下 30 条原则，这些原则被成员们广泛认可，也成为了新手架构师的学习途径。</summary>
    
    
    
    <category term="架构设计" scheme="https://gaoxing27.gitee.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构设计" scheme="https://gaoxing27.gitee.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>好好的写代码吧</title>
    <link href="https://gaoxing27.gitee.io/2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/"/>
    <id>https://gaoxing27.gitee.io/2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/</id>
    <published>2022-02-28T03:59:13.000Z</published>
    <updated>2022-02-28T03:59:52.060Z</updated>
    
    <content type="html"><![CDATA[<p>好好的写软件、写代码，不给别人挖坑，这应该是每个程序员对自己最基本的要求。当然我也踩过别人的坑，曾经由于自己的无知，也给别人挖过坑。不管因为什么，烂的代码一旦上线，你就得维护它，这是件很痛苦的事情。就好像你撒了一个谎，为了圆这个谎，你不得不再撒更多的谎，可谎言终究是谎言，终究会被扯破的一天。当某一天实在维护不动了，你走了，来了一个新的程序员来维护他，你失去了一个成为优秀程序员的机会，同时也浪费了更多人的时间和精力。<br>我们的时间应该去写好的代码、做好的事情，然后享受生活，而不是和这些烂代码搏斗。如果不重视这些事情，会制造很多麻烦，会让质量下降，会让一个本来可以快速推进的事情变得缓慢，会让你不得不去做一些无聊的事情、解决一些无聊的问题。也会挫伤想写好的代码的人的积极性。所以，如果你不好好写代码，你乱管理事情，我会认为你在给我制造麻烦，浪费我的时间，那么我就会和你有一些争论。<br>无论在哪个位置，都应该有一些自己的追求，至少不要成为别人的麻烦，而是努力成为一个解决麻烦的人。如果你的心和大脑在解决麻烦的路上，那么你犯的错误，我称之为经验；如果你是一个麻烦制造者，并且浑然不觉，那么我想我会提醒你；当然，我并不想教你做事，我只是想和你一起成为麻烦、问题的终结者，然后下班。</p>]]></content>
    
    
    <summary type="html">好好的写软件、写代码，不给别人挖坑，这应该是每个程序员对自己最基本的要求。当然我也踩过别人的坑，曾经由于自己的无知，也给别人挖过坑。不管因为什么，烂的代码一旦上线，你就得维护它，这是件很痛苦的事情。就好像你撒了一个谎，为了圆这个谎，你不得不再撒更多的谎，可谎言终究是谎言，终究会被扯破的一天。当某一天实在维护不动了，你走了，来了一个新的程序员来维护他，你失去了一个成为优秀程序员的机会，同时也浪费了更多人的时间和精力。</summary>
    
    
    
    <category term="工作" scheme="https://gaoxing27.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="工作" scheme="https://gaoxing27.gitee.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>好文摘录</title>
    <link href="https://gaoxing27.gitee.io/2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    <id>https://gaoxing27.gitee.io/2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/</id>
    <published>2022-02-15T03:52:04.000Z</published>
    <updated>2022-03-11T01:41:22.991Z</updated>
    
    <content type="html"><![CDATA[<p>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，则万事可成  <span id="more"></span></p><hr><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p><hr><p>如果此时的你正在经历痛苦<br>那么请记住<br>我们所遭遇的痛苦与磨难<br>其实只是过去行为的一个结果<br>我们没有理由去责怪他人<br>更没有必要自责<br>你若能能积极的心态面对它<br>那么正在经历的痛苦<br>不仅完结了一个旧的因果<br>而且还会成为一个新的善因<br>痛苦并不总是坏事<br>人生的得失起伏<br>都可以是让你觉悟的契机<br>关键是看你以怎样的心态去面对<br>—次第花开  </p><hr><p>初入红尘<br>不知人间疾苦<br>蓦然回首<br>已是苦中之人<br>这杯中酒三分<br>这酒中悲七分<br>关关难过关关过<br>夜夜难熬夜夜熬<br>愿这世间所有爱恨情仇皆溶于酒<br>且将这风尘作酒<br>一饮消愁</p><hr><p>世间万物都是空<br>功名利禄逝如风<br>天也空地也空<br>人生渺茫在其中<br>金也空银也空<br>死后何曾在手中<br>权也空名也空<br>转眼荒郊土一捧<br>情也空义也空<br>大难来时影无踪<br>生如百花逢春好<br>死如黄叶落秋风<br>回首仔细思量起<br>便是南柯一梦中<br>–看破想通，万事皆空  </p><hr><p>君子慎独<br>不欺暗室<br>卑以自牧<br>含章可贞<br>大丈夫立于天地之间<br>当仰天地浩然正气<br>行光明磊落之事<br>克己慎独守心明性  </p><hr><p>子成人父方解油盐非易事<br>女为人母才知酱醋味千般<br>幼年常感父身宽<br>双肩可撼千重山<br>而今转瞬成人父<br>才知年少见识偏<br>流光逝<br>步蹒跚<br>碎银几两汉子难<br>也曾心怀青云志<br>回首只盼老少安  </p><hr><p>自古人生最忌满<br>半贫半富半自安<br>半命半天半机遇<br>半取半舍半行善<br>半聋半哑半糊涂<br>半智半愚半圣贤<br>半人半我半自在<br>半醒半醉半神仙<br>半亲半爱半苦乐<br>半俗半禅半随缘<br>人生一半在于我<br>另外一半听自然  </p><hr><p>对于无能为力的事，当断<br>对于生命中无缘的人，当舍<br>对于心中的烦与杂念，当离<br>目光所及，皆是回忆；<br>心之所想，皆是过往；<br>只有放下执念，心才能回归安宁。</p><hr><p>鱼那么信任水，水却把它煮了<br>树叶那么信任风，风却把它吹落了<br>我那么信任你，你却把我伤害了<br>后来我才发现<br>煮鱼的不是水，而是火<br>吹落树叶的不是风，而是秋天，<br>伤害我的也不是你，而是我的自作多情；  </p><hr><p>聋子说炮不响<br>瞎子说灯不亮<br>瘸子说炮挺响，灯也亮<br>只是这看起来平平坦坦的路走起来有点摇摇晃晃<br>人呐，<br>如果看不到自己的问题和不足，总会认为错的是别人。</p><hr><p>人间非净土<br>各有各的苦<br>同是红尘悲伤客<br>莫笑谁是可怜人<br>杯中倒满无情酒<br>眼中再无意中人</p><hr><p>几时归去<br>做个闲人<br>忙时勤努力<br>闲时赏风月<br>逢人不说人间事<br>便是人间无事人<br>若无闲事挂心头<br>便是人间好时节  </p><hr><p>你我暮年<br>闲坐庭院<br>云卷云舒听雨声<br>星密星稀赏月影<br>花开花落忆江南<br>你话往时我话往事<br>愿有岁月可回首<br>且以深情共白头  </p><hr><p>时光总在静中定<br>流水却穿五孔桥<br>年少应虑道中事<br>莫等红尘催白头  </p><hr><p>半山烟雨半生忧<br>一念心轻万事休<br>山后本是清静地<br>怎奈俗人一身愁  </p><hr><p>我本一身傲骨<br>奈何世事无常<br>悲从心中起<br>百般不如人<br>本以为傲从骨中生<br>万难不屈膝<br>可是傲骨又值几分钱<br>最可叹放下了尊严<br>却换不回柴米油盐  </p><hr><p>三十而立<br>人生将半<br>也曾克己奋发<br>胸怀激荡<br>幻想红衣白马<br>气吐眉扬<br>然终是柴米挫了锐气<br>染了风霜  </p><hr><p>半生风雨半生寒<br>一杯浊酒敬流年<br>回首过往半生路<br>七分酸楚三人甜<br>日出东方催人醒<br>不及晚霞懂我情<br>辞别再无相见日<br>终是一人度春秋  </p><hr><p>世事茫茫，光阴有限，算来何必奔忙。<br>人生碌碌，竟短论长，却不道荣枯有数，得失难量。<br>看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。<br>荣华花上露，富贵草上霜。<br>机关参透，万虑皆忘。<br>夸什么龙楼凤阁，说什么利锁名缰。<br>闲来静处，且将诗酒猖狂。</p><hr><p>法不轻传，<br>道不贱卖，<br>师不顺路，<br>医不叩门，<br>千金不传无义子，<br>万财不渡忘恩人，<br>医逢信者但可救，<br>道遇无明枉费心，<br>甘露不润无根草，<br>妙法只渡有缘人。</p><hr><p>不与君子争名，<br>不与小人夺利，<br>不与天地比巧，<br>将军有剑不斩苍蝇，<br>文臣执笔不负苍生。</p><hr><p>终日奔波只为饥<br>方才一饱便思衣<br>衣食两般皆具足<br>又思娇柔美貌妻<br>娶得美妻生下子<br>恨无田地少根基<br>门前买下田千顷<br>又思出门少马骑<br>槽头拴了骡和马<br>又思无官被人欺<br>一品当朝为宰相<br>还想山河夺帝基<br>心满意足为天子<br>又想长生不老期<br>一旦求得长生药<br>再跟上帝论高低</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;坐中静，破焦虑之贼&lt;br&gt;舍中得，破欲望之贼&lt;br&gt;事上练，破犹豫之贼&lt;br&gt;三贼皆破，则万事可成</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>夜听冰河</title>
    <link href="https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/"/>
    <id>https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/</id>
    <published>2022-01-23T09:10:58.000Z</published>
    <updated>2022-02-28T02:57:22.775Z</updated>
    
    <content type="html"><![CDATA[<p>给自已取了一个新的网名，“夜听冰河”。<br>取自：《十一月四日风雨大作》作者：陆游 作于公元1192年<br>僵卧孤村不自哀，尚思为国戍轮台。<br>夜阑卧听风吹雨，铁马冰河入梦来。<br>夜深了，年近古稀（陆游生于公元1125年，此诗作于1192年，当时作者67岁）的一老翁直挺挺的躺在孤寂荒凉的小乡村里，一边听着外面的风吹着雨，雨又打着风，一边又在想如今虽身处荒野，但这又算得了什么，哪里有值得感到悲哀的，只要我还能再为国家戍守边疆，再出一份力，听着听着，想着想着，竟迷迷糊糊睡着了，仿佛真的回到了边关，骑着披甲的战马，跨过冰封的河流。。。<br>如实说，这首诗读高中时学习过，也理解诗要表达的感情，但是偶然间，脑子里不自主的闪现出，“夜阑卧听风吹雨，铁马冰河入梦来。”，就再次去品味这首诗，竟别有另一番感触。只能说好的诗人，一定是一个感情充沛，精神世界丰富的人；好的诗，一定是最简单的文字里承载着最真挚的感情。无疑，陆游是一个伟大的诗人，他的这首十一月四日风雨大作也是一首不朽的诗。从放翁先生的诗中，感受到了真挚爱国报国之情，也看到一年近七十的老翁，人生失意，壮志未酬，不是追悔，不是抱怨，亦不是叹时光匆匆，却是年老之躯，少年雄心，做梦都在想着能披甲再战，一颗不屈之心，一副铮铮之骨跃然纸上。也许正是先生这不屈之心，铮铮之骨早已烙入我心，才会在某一刻闪现在我的脑海中。<br>诗解析完了，思考却没有停止，为什么后两句突然会跃现于我的脑海里？对于现代社会的人们，确切说是世俗社会的人们来说，一首写于829年前的诗，还有什么意义？<br>澄清一点我这里之所以说是世俗社会的，是因为当前社会世俗规则大行其道，有人可能不解了，什么又是世俗规则呢？简单说：搞钱第一，有钱就代表成功，没有挣到钱就代表失败，金钱第一，也是实力、地位的象征。而我所理解的现代社会，是物质与精神同等重要的社会，人们除了追求更高的物质生活，也漫游于丰富的精神海洋。因商场失败，跳楼自杀；因家产继承，兄弟反目；因一己贪欲，行贿受贿索贿如登大堂。凡此种种，数不胜数。<br>其实这一切的后果，都是可以避免的，但前提是你的精神世界是丰富的、充沛的，无论得意、失意，都能为你点燃一盏灯火，指引你前行。对于身负巨额债务的人来说，如果你听过“海到尽头天作岸，山登绝顶我为峰。如日东山能再起，大鹏展翅恨天低。”，哪还用以寻死求解脱；如果你明白“打虎亲兄弟，上阵父子兵”、“兄弟阋于墙，外御其侮”，家资丰厚或贫瘠，当兄谦弟恭，戮力同心，何愁家道不兴？身居显位，是实力所至，已得人前之贵，如果你懂得，“为天地立心，为生民立命，为往圣继绝学，为万世开太平。”，又何必以蝇蝇之利污洁白之羽，展天之翅。<br>很喜欢，沈复在《浮生六记》中的一段话，送给自己及所有精神世界还很贫瘠的人：世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。<br>多么的洒脱无碍，来去如风呀，只要过得幸福、轻松、自在，何必为多拿两个铜板而机关算尽？</p>]]></content>
    
    
    <summary type="html">世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>node-基本原理及工作流程</title>
    <link href="https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-16T02:52:33.000Z</published>
    <updated>2021-06-27T14:16:13.808Z</updated>
    
    <content type="html"><![CDATA[<p>Node 是一个服务器端 JavaScript 解释器，可以方便地搭建出响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型，非常适合在分布式设备上运行数据密集型的实时应用。</p><p>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台，功能完善，它实现了诸如文件系统、模块、包、操作系统 API、网络通信等功能 。</p><h3 id="v8引擎"><a href="#v8引擎" class="headerlink" title="v8引擎"></a>v8引擎</h3><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎，负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；你可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p><h3 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h3><p>Java，PHP等编程语言是面向对象编程，Node是事件驱动编程的思想。<br>事件驱动编程，即为需要处理的事件编写相应的事件处理程序，代码在事件发生时执行，当事件触发时被操作系统唤醒，这样能更加有效地使用cpu。<br>事件驱动模型如图：</p><p><img src="/images/node/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" alt="事件驱动模型"></p><p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p><ul><li><p>事件源：产生事件的地方(html元素)</p></li><li><p>事件：点击/鼠标操作/键盘操作等等</p></li><li><p>事件对象：当某个事件发生时，可能会产生一个事件对象，该事件对象会封装好该事件的信息，传递给事件处理程序</p></li><li><p>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。</p><p>我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">e</span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.alert(<span class="string">&quot;x=&quot;</span>+e.clientX+<span class="string">&quot;y=&quot;</span>+e.clientY); </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span> <span class="attr">onmousedown</span>=<span class="string">&quot;test1(event)&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h3><p>通常应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，而CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务，所以I/O才是应用程序的瓶颈所在；在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。</p><p>《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</p><p><img src="/images/node/node%E6%94%AF%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="node支行流程图"></p><p>Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。</p><p>Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br>在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/xiangzhihong8/article/details/53954600">https://blog.csdn.net/xiangzhihong8/article/details/53954600</a></p></blockquote>]]></content>
    
    
    <summary type="html">Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</summary>
    
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>图解kafka</title>
    <link href="https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/"/>
    <id>https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/</id>
    <published>2021-06-15T07:47:44.000Z</published>
    <updated>2021-07-08T13:25:02.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。</p><p><img src="/images/kafka/base.jpg" alt="kafka"></p><p>生产者消费者<br>生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7-kafka-%E6%B6%88%E8%B4%B9.jpg" alt="生产-kafka-消费"></p><p>一个服务可以同时为生产者和消费者。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85-kafka.png" alt="生产消费者-kafka"></p><h3 id="Topics-主题"><a href="#Topics-主题" class="headerlink" title="Topics 主题"></a>Topics 主题</h3><p>Topic 是生产者发送消息的目标地址，是消费者的监听目标。</p><p><img src="/images/kafka/kafka-topic.png" alt="kafka-topic"></p><p>一个服务可以监听、发送多个 Topics。</p><p><img src="/images/kafka/%E5%8D%95%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AATopics.png" alt="单个服务监听多个Topics"></p><p>Kafka 中有一个【consumer-group（消费者组）】的概念。</p><p>这是一组服务，扮演一个消费者。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84.png" alt="消费者组"></p><p>如果是消费者组接收消息，Kafka 会把一条消息路由到组中的某一个服务。</p><p><img src="/images/kafka/%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1.png" alt="路由消息到消费者组中的某一个服务"></p><p>这样有助于消息的负载均衡，也方便扩展消费者。</p><p>Topic 扮演一个消息的队列。</p><p>首先，一条消息发送了。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E5%88%B0topic.png" alt="生产消息到topic"></p><p>然后，这条消息被记录和存储在这个队列中，不允许被修改。</p><p><img src="/images/kafka/topic%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9.png" alt="topic中的消息不允许修改"></p><p>接下来，消息会被发送给此 Topic 的消费者。</p><p>但是，这条消息并不会被删除，会继续保留在队列中。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E5%B9%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BC%9A%E7%BB%A7%E7%BB%AD%E4%BF%9D%E7%95%99%E5%9C%A8%E9%98%9F%E5%88%97.png" alt="消息并不会被删除，会继续保留在队列"></p><p>继续发送消息。</p><p><img src="/images/kafka/%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="继续发送消息"></p><p>像之前一样，这条消息会发送给消费者、不允许被改动、一直呆在队列中。</p><p>（消息在队列中能呆多久，可以修改 Kafka 的配置）</p><p><img src="/images/kafka/a.png" alt="a"></p><p><img src="/images/kafka/b.png" alt="b"></p><h3 id="Partitions-分区"><a href="#Partitions-分区" class="headerlink" title="Partitions 分区"></a>Partitions 分区</h3><p>上面 Topic 的描述中，把 Topic 看做了一个队列，实际上，一个 Topic 是由多个队列组成的，被称为【Partition（分区）】。</p><p>这样可以便于 Topic 的扩展。</p><p><img src="/images/kafka/topic-Partitions.png" alt="topic-Partitions"></p><p>生产者发送消息的时候，这条消息会被路由到此 Topic 中的某一个 Partition。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0Topic%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAPartition.png" alt="生产者发送消息到Topic中的某一个Partition"></p><p>消费者监听的是所有分区。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA.png" alt="消费者监听的是所有分区"></p><p>生产者发送消息时，默认是面向 Topic 的，由 Topic 决定放在哪个 Partition，默认使用轮询策略。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%94%B1Topic%E5%86%B3%E5%AE%9A%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AAPartition.png" alt="产者发送消息由Topic决定放在哪个Partition"></p><p>也可以配置 Topic，让同类型的消息都在同一个 Partition。</p><p>例如，处理用户消息，可以让某一个用户所有消息都在一个 Partition。</p><p>例如，用户1发送了3条消息：A、B、C，默认情况下，这3条消息是在不同的 Partition 中（如 P1、P2、P3）。</p><p>在配置之后，可以确保用户1的所有消息都发到同一个分区中（如 P1）。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="消息有序性"></p><p>这个功能有什么用呢？</p><p>这是为了提供消息的【有序性】。</p><p>消息在不同的 Partition 是不能保证有序的，只有一个 Partition 内的消息是有序的。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A72.png" alt="消息有序性2"></p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A73.png" alt="消息有序性3"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Kafka 是集群架构的，ZooKeeper是重要组件。</p><p><img src="/images/kafka/kafka-zookeeper.png" alt="kafka-zookeeper"></p><p>ZooKeeper 管理者所有的 Topic 和 Partition。</p><p>Topic 和 Partition 存储在 Node 物理节点中，ZooKeeper负责维护这些 Node。</p><p><img src="/images/kafka/kafka-zookeeper-znode.png" alt="kafka-zookeeper-znode"></p><p>例如，有2个 Topic，各自有2个 Partition。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B.png" alt="示例.png"></p><p>这是逻辑上的形式，但在 Kafka 集群中的实际存储可能是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B2.png" alt="示例2"></p><p>Topic A 的 Partition #1 有3份，分布在各个 Node 上。</p><p>这样可以增加 Kafka 的可靠性和系统弹性。</p><p>3个 Partition #1 中，ZooKeeper 会指定一个 Leader，负责接收生产者发来的消息。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B3.png" alt="示例3"></p><p>其他2个 Partition #1 会作为 Follower，Leader 接收到的消息会复制给 Follower。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B4.png" alt="示例4"></p><p>这样，每个 Partition 都含有了全量消息数据。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B5.png" alt="示例5"></p><p>即使某个 Node 节点出现了故障，也不用担心消息的损坏。</p><p>Topic A 和 Topic B 的所有 Partition 分布可能就是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B6.png" alt="示例6"></p><blockquote><p>原文<br>-<a href="https://blog.csdn.net/duysh/article/details/116355977">https://blog.csdn.net/duysh/article/details/116355977</a></p></blockquote>]]></content>
    
    
    <summary type="html">kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。一个服务可以同时为生产者和消费者。Topic 是生产者发送消息的目标地址，是消费者的监听目标。</summary>
    
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/categories/kafka/"/>
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/tags/kafka/"/>
    
    <category term="消息队列" scheme="https://gaoxing27.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="中间件" scheme="https://gaoxing27.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>简单生活，努力工作，爱自己爱家人</title>
    <link href="https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/"/>
    <id>https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/</id>
    <published>2021-06-01T10:32:48.000Z</published>
    <updated>2022-03-11T02:05:50.190Z</updated>
    
    <content type="html"><![CDATA[<p>静心平想，其实我是一个很幸运的人，我挺知足。</p><p>上学时代，激情满怀，却资质平庸，成绩上并无亮点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。我不想一下就耗尽自己的力气，同时也没有来得及去享受加油和呐喊助威。我希望我拼得不是速度，而是耐力。也许我跑的不是最快，不是第一，但是每坚实的跑出一步，都是我对的人生发于心的热爱，我会记住沿途的每一张笑脸和每一个从身边的奔跑过的人。</p><p>最近躺平、内卷，这两个词挺热的，了解完躺平、内卷，我简直下巴要掉到地上了，虽然现在生活好了，同时压力更大了，竞争更激烈，但是通过这种方式来对表达自己的反抗，太愚蠢了。也许目标看似遥不可及，如果躺下了，真就不可及了。</p><p>聪明的人善于计算，以现在的能力再怎么努力，也买不起房子、谈不起恋爱、结不起婚、生得起养不起孩子、上不起医院看不起病……，我感觉这些计算都是错的，这让我想起一个成语故事：刻舟求剑；社会在发展，经济在发展，人也在发展，发展就是变化，既然一切都是在变化中，为什么要用现在来计算未来，这哪是聪明，简直愚蠢；人类已经登上了月球，以后也许还会上火星，以后的以后还有更多的未知和惊喜</p><p>停止焦虑对你的束缚吧，世界上没有一种精密的模型可以计算未来，计算人的潜力，计算人的决心。<br>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，万事可成<br>拾起这好时光，决心让自己变简单，让生活变简单，努力爱自己、家人和工作。</p>]]></content>
    
    
    <summary type="html">静心平想，其实我是一个很幸运的人，应该知足。上学时代，激情满怀，却资质平庸，成绩上并无高点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-spring-原理</title>
    <link href="https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-28T09:35:13.000Z</published>
    <updated>2021-06-30T10:59:27.129Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：</p><ul><li>添加dubbo-spring-boot-starter依赖</li><li>定义@org.apache.dubbo.config.annotation.Service注解</li></ul><p>声明@DubboComponentScan，用于扫描@Service注解，Dubbo中的@Service注解和Spring中提供的@Service注解功能类似，用于实现Dubbo服务的暴露，与它相对应的时@Reference，它的作用类似于Spring中的@Autowired注解。而@DubboComponentScan和Spring中的@ComponentScan作用类似，用于扫描@Service、@Reference等注解。</p><h3 id="DubboComponentScan注解解析"><a href="#DubboComponentScan注解解析" class="headerlink" title="@DubboComponentScan注解解析"></a>@DubboComponentScan注解解析</h3><p><strong>DubboComponentScan</strong>注解的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解主要通过@Import导入一个DubboComponentScanRegistrar类。DubboComponentScanRegistrar实现了ImportBeanDefinitionRegistrar接口，并且重写了registerBeanDefinitions方法。在registerBeanDefinitions方法中主要做了以下几件事：</p><ul><li>获取扫描包的路径，默认扫描当前配置类所在的包</li><li>注册@Service注解的解析类</li><li>注册@Reference注解的解析类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refisterBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportBeanDefinitionRegistrar是Spring提供的一种动态注入Bean的机制，和ImportSelector接口的功能类似，在refisterBeanDefinitions方法中，主要会实例化一些BeanDefinition并且注入到Spring IoC容器中；继续看registerServiceAnnotationBeanPostProcessor()方法，逻辑比较简单，就是把SerficeAnnotationBeanPostProcessor注册到容器；registerReferenceAnnotationBeanPostProcessor()方法是把ReferenceAnnotationBeanPostProcessor注册到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构建BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(<span class="number">2</span>);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 把BeanDefinition注册到IoC容器中</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Service解析"><a href="#Service解析" class="headerlink" title="@Service解析"></a>@Service解析</h3><p>ServiceAnnotationBeanPostProcessor用于解析@Service注解，ReferenceAnnotationBeanPostProcessor用于解析@Reference注解</p><h3 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h3><p>ServiceAnnotationBeanPostProcessor类的定义如下，它的核心逻辑就是解析@Service注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor实现了4个接口，EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware这三个接口比较好理解，重点看一下BeanDefinitionRegistryPostProcessor；BeanDefinitionRegistryPostProcessor接口继承自BeanFactoryPostProcessor，是一种比较特殊的BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor中的postProcessBeanDefinitionRegistry方法可以让我们实现自定义的注册Bean定义的逻辑。该方法主要做了以下几件事：</p><ul><li>调用registerBeans注册DubboBootstrapApplicationListener类</li><li>通过resolvePackagesToScan对packagesToScan参数进行去空格处理，并把配置文件中配置的扫描参数也一起处理。</li><li>调用registerServiceBeans完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, <span class="keyword">new</span> Class[]&#123;DubboBootstrapApplicationListener.class&#125;);</span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = <span class="keyword">this</span>.resolvePackagesToScan(<span class="keyword">this</span>.packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">&quot;packagesToScan is empty , ServiceBean registry will be ignored!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postProcessBeanDefinitionRegistry()方法的核心逻辑都在registerServiceBeans这个方法中，这个方法会查找需要扫描的指定包里面有@Service注解的类并将其注册成Bean。</p><ul><li>定义DubboClassPathBeanDefinitionScanner扫描对象，扫描指定路径下的类，将符合条件的类装配到IoC容器中。</li><li>BeanNameGenerator是Beans体系中比较重要的一个组件，会通过一定的算法计算出需要装配的Bean的name。</li><li>addIncludeFilter设置Scan的过滤条件，只扫描@Service注解修饰的类。</li><li>遍历指定的包，通过findServiceBeanDefinitionHolders查找@Service注解修饰的类。</li><li>通过registerServiceBean完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan The base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">                <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">            scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                    registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(beanDefinitionHolders.size() + <span class="string">&quot; annotated Dubbo&#x27;s @Service Components &#123; &quot;</span> +</span><br><span class="line">                            beanDefinitionHolders +</span><br><span class="line">                            <span class="string">&quot; &#125; were scanned under package[&quot;</span> + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span></span><br><span class="line">                            + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码主要作用就是通过扫描指定路径下添加了@Service注解的类，通过registerServiceBean来注册ServiceBean，整体来看，Dubbo的注解扫描进行服务发布的过程，实际上就是基于Spring的扩展。</p><p>继续分析registerServiceBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">     Service service = findAnnotation(beanClass, Service.class);</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">     String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">     AbstractBeanDefinition serviceBeanDefinition =</span><br><span class="line">             buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ServiceBean Bean name</span></span><br><span class="line">     String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; <span class="comment">// check duplicated candidate bean</span></span><br><span class="line">         registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">&quot;The BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean has been registered with name : &quot;</span> + beanName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">             logger.warn(<span class="string">&quot;The Duplicated BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean[ bean name : &quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;] was be found , Did @DubboComponentScan scan to same package in many times?&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resolveClass获取BeanDefinitionHolder中的Bean</li><li>findServiceAnnotation方法从beanClass类中找到@Service注解</li><li>getAnnotationAttributes方法获得注解中的属性，比如loadBalance、cluster等。</li><li>resolveServiceInterfaceClass方法用于获得beanClass对应的接口定义，其实在@Service(interfaceClass=xxxx.class)注解的声明中也可以声明interfaceClass，注解中声明的优先级最高，如果没有声明该属性，则会从父类中查找。</li><li>annotatedServiceBeanName代表Bean的名称。</li><li>buildServiceBeanDefinition用来构造org.apache.dubbo.config.spring.ServiceBean对象，每个Dubbo服务的发布最终都会出现一个ServiceBean。</li><li>调用registerBeanDefinition将ServiceBean注入Spring IoC容器中。</li></ul><p>从整个方法的分析来看，registerServiceBean方法主要是把一个ServiceBean注入到Spring IoC容器中，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不是像普通的Bean注入一样直接将HelloServiceImpl对象的实例注入容器，而是注入一个ServiceBean对象。对于HelloServiceImpl来说，它并不需要把自己注入Spring IoC容器中，而是需要把自己发布到网络上，提供给网络上的服务消费者来访问。那它是怎么发布到网络上的呢？</p><p>上面在postProcessBeanDefinitionRegistry方法中注册了DubboBootstrapApplicationListener事件监听Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrapApplicationListener</span> <span class="keyword">extends</span> <span class="title">OneTimeExecutionApplicationContextEventListener</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DubboBootstrap dubboBootstrap = DubboBootstrap.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrapApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextRefreshedEvent((ContextRefreshedEvent)event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextClosedEvent((ContextClosedEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的Bean都处理完成之后，Spring IoC会发布一个事件，事件类型为ComtextRefreshedEvent，当触发整个事件时，会调用onContextRefreshedEvent方法。在这个方法中，可以看到Dubbo服务启动的触发机制dubboBootstrap.start()。从这个方法中会进入org.apache.dubbo.config.ServiceConfig类中的export()方法，这个方法会启动一个网络监听，从而实现服务发布。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/yangbaggio/article/details/105913431">https://blog.csdn.net/yangbaggio/article/details/105913431</a></p><p><a href="https://blog.csdn.net/DaySurprise/article/details/114897735">https://blog.csdn.net/DaySurprise/article/details/114897735</a></p><p><a href="https://www.cnblogs.com/jackion5/p/11219707.html">https://www.cnblogs.com/jackion5/p/11219707.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">使用Dubbo最方便的地方在于它可以和Spring非常方便的集成，实际上，Dubbo对于配置的优化，也是随着Spring一同发展的，从最早的XML形式到后来的注解方式以及自动装配，都是在不断地简化开发过程来提高开发效率。在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：添加dubbo-spring-boot-starter依赖;定义@org.apache.dubbo.config.annotation.Service注解</summary>
    
    
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/categories/Dubbo/"/>
    
    
    <category term="Spring" scheme="https://gaoxing27.gitee.io/tags/Spring/"/>
    
    <category term="Springboot" scheme="https://gaoxing27.gitee.io/tags/Springboot/"/>
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo-原理</title>
    <link href="https://gaoxing27.gitee.io/2021/05/27/dubbo-%E5%8E%9F%E7%90%86/"/>
    <id>https://gaoxing27.gitee.io/2021/05/27/dubbo-%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-27T11:22:17.000Z</published>
    <updated>2021-06-30T10:59:22.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dubbo基础"><a href="#dubbo基础" class="headerlink" title="dubbo基础"></a>dubbo基础</h2><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。</p><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架Dubbo就出现了</p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul><li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li><li>软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ul><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h4><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><strong>核心组件</strong></h4><ul><li><p>Provider：暴露服务的服务提供方</p></li><li><p>Consumer：调用远程服务消费方</p></li><li><p>Registry：服务注册与发现注册中心</p></li><li><p>Monitor：监控中心和访问调用统计</p></li><li><p>Container：服务运行容器</p><p><strong>注册中心</strong></p><p>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</p></li></ul><p><img src="/images/dubbo/Dubbo%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="Dubbo核心组件"></p><h4 id="服务注册与发现流程"><a href="#服务注册与发现流程" class="headerlink" title="服务注册与发现流程"></a><strong>服务注册与发现流程</strong></h4><ul><li>服务容器Container负责启动，加载，运行服务提供者。</li><li>服务提供者Provider在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者Consumer在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心Registry返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者Consumer和提供者Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>Dubbo框架设计一共划分了10个层，而最上面的Service层是留给实际想要使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口， 位于中轴线上的为双方都用到的接口。</p><ul><li>接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</li><li>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li><li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</li><li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li><li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</li><li>远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li><li>网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li><li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</li></ul><p><img src="/images/dubbo/Dubbo%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="dubbo架构设计图"></p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>服务器端（服务提供者） 在框架启动时， 会初始化服务实例， 通过Proxy组件调<br>用具体协议（Protocol ） ,把服务端要暴露的接口封装成Invoker （真实类型是<br>AbstractProxylnvoker）,然后转换成Exporter,这个时候框架会打开服务端口等并记录服务实例<br>到内存中， 最后通过Registry把服务元数据注册到注册中心和本地。   </p><p>Proxy组件： Dubbo框架生成的代理类， 调用的方法其实是Proxy组件生成的代理方法， 会自动发起远程/本地调用， 并返回结果,<br>整个过程对用户完全透明。</p><p> Protocol： 协议就是对数据格式的一种约定。 它可以把我们对接口的配置,<br>根据不同的协议转换成不同的Invoker对象。 例如： 用DubboProtocol可以把XML文<br>件中一个远程接口的配置转换成一个Dubbolnvoker</p><p>Exporter： 用于暴露到注册中心的对象， 它的内部属性持有了 Invoker对象， 我们可以<br>认为它在Invoker上包了 一层。</p><p>Registry： 把Exporter注册到注册中心  </p><h4 id="服务调用过程"><a href="#服务调用过程" class="headerlink" title="服务调用过程"></a>服务调用过程</h4><p><img src="/images/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="dubbo服务暴露和调用过程.png"></p><p>调用过程也是从一个Proxy开始的， Proxy持有了一个Invoker对象。 然后触发invoke<br>调用。 在invoke调用过程中， 需要使用Cluster, Cluster负责容错， 如调用失败的重试。 Cluster<br>在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表（一个接口可能有多个<br>节点提供服务） 。 由于可以调用的远程服务有很多， 此时如果用户配置了路由规则（如指定某些<br>方法只能调用某个节点） ， 那么还会根据路由规则将Invoker列表过滤一遍。<br>然后， 存活下来的Invoker可能还会有很多，于是会继续通过<br>LoadBalance方法做负载均衡， 最终选出一个可以调用的Invokero这个Invoker在调用之前又会<br>经过一个过滤器链， 这个过滤器链通常是处理上下文、 限流、 计数等。<br>接着， 会使用Client做数据传输， 如我们常见的Netty Client等。 传输之前肯定要做一些私<br>有协议的构造， 此时就会用到Codec接口。 构造完成后， 就对数据包做序列化（Serialization）,<br>然后传输到服务提供者端。 服务提供者收到数据包， 也会使用Codec处理协议头及一些半包、<br>粘包等。 处理完成后再对完整的数据报文做反序列化处理。<br>随后， 这个Request会被分配到线程池（ThreadPool）中进行处理。Server会处理这些Request,<br>根据请求查找对应的Exporter （它内部持有了 Invoker）。 Invoker是被用装饰器模式一层一层套<br>了非常多Filter的， 因此在调用最终的实现类之前， 又会经过一个服务提供者端的过滤器链。<br>最终， 我们得到了具体接口的真实实现并调用， 再原路把结果返回。<br>至此， 一个完整的远程调用过程就结束了。 </p><h4 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h4><p>SPI，Service Provider Interface，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。</p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader</p><p> Dubbo 并未使用Java SPI，而是重新实现了一套功能更强的SPI机制。Dubbo SPI的相关逻辑被封装在了ExtensionLoader类中，通过ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI所需的配置文件，需放置在META-INF/dubbo路径下</p><p>与Java SPI实现类配置不同，Dubbo SPI是通过键值对的方式进行配置。这样我们可以按需加载指定的实现类。另外在测试Dubbo SPI时，需要在Robot接口上标注@SPI注解 </p><h4 id="monitor原理"><a href="#monitor原理" class="headerlink" title="monitor原理"></a>monitor原理</h4><ul><li>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。</li></ul><ol><li>MonitorFilter 向 DubboMonitor 发送数据</li><li>DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference</li><li>SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大写为 100000）</li><li>SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以死循环的形式来写）</li><li>SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</li></ol><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>默认：Random LoadBalance:</p><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><h4 id="集群容错机制"><a href="#集群容错机制" class="headerlink" title="集群容错机制"></a>集群容错机制</h4><p>默认：Failover Cluster</p><ul><li>Failover </li></ul><p>当出现失败时， 会重试其他服务器。 用户可以通过retries=”2n设置重试次数。 这是<br>Dubbo的默认容错机制， 会对请求做负载均衡。 通常使用在读操作或幕等的写操作上，<br>但重试会导致接口的延退增大， 在下游机器负载已经达到极限时， 重试容易加重下游<br>服务的负载</p><ul><li>Failfast</li></ul><p> 快速失败， 当请求失败后， 快速返回异常结果， 不做任何重试。 该容错机制会对请求<br>做负载均衡， 通常使用在非幕等接口的调用上。 该机制受网络抖动的影响较大</p><ul><li>Failsafe</li></ul><p> 当出现异常时， 直接忽略异常。 会对请求做负载均衡。 通常使用在“佛系” 调用场景，<br>即不关心调用是否成功， 并且不想抛异常影响外层调用， 如某些不重要的日志同步， 即使出现异常也无所谓</p><ul><li>Fallback</li></ul><p> 请求失败后， 会自动记录在失败队列中， 并由一个定时线程池定时重试， 适用于一些<br>异步或最终一致性的请求。 请求会做负载均衡</p><ul><li>Forking</li></ul><p> 同时调用多个相同的服务， 只要其中一个返回， 则立即返回结果。 用户可以配置forks=“最大并行调用数” 参数来确定最大并行调用的服务数量。 通常使用在对接口<br>实时性要求极高的调用上， 但也会浪费更多的资源</p><ul><li>Broadcast </li></ul><p>广播调用所有可用的服务， 任意一个节点报错则报错。 由于是广播， 因此请求不需要<br>做负载均衡。 通常用于服务状态更新后的广播</p><ul><li>Mock</li></ul><p> 提供调用失败时， 返回伪造的响应结果。 或直接强制返回伪造的结果， 不会发起远程<br>调用</p><ul><li>Available </li></ul><p>最简单的方式， 请求不会做负载均衡， 遍历所有服务列表， 找到第一个可用的节点，<br>直接请求并返回结果。 如果没有可用的节点， 则直接抛出异常</p><ul><li>Mergeable </li></ul><p>Mergeable可以自动把多个节点请求得到的结果进行合并</p><h4 id="调用超时设置"><a href="#调用超时设置" class="headerlink" title="调用超时设置"></a>调用超时设置</h4><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><ul><li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li><li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>Dubbo注册中心集群挂掉之后，消费者和生产者之间可以继续通信；因为在Dubbo启动时，消费者会从注册中心Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地，每次调用时，按照本地缓存的地址调用就可以。</p><p>默认使用 Netty 作为通讯框架。</p><p>支持的通信协议：</p><ul><li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</li><li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li><li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li><li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li><li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li><li>Memcache：基于 Memcache实现的 RPC 协议。</li><li>Redis：基于 Redis 实现的RPC协议。</li></ul><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>为保证在远程调用过程中对象的完整性和可传递性，服务消费者和服务提供者之间传递数据的时候需要进行序列化和反序列化，默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><p>序列化：把对象转换成有序的二进制字节流，以便在网络上传输或者保存在本地文件中</p><p>反序列化：把序列化后的对象的二进制字节流通过反序列化重建对象。</p><h4 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h4><ul><li>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</li><li>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</li></ul><h3 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h3><ul><li><p>工厂模式</p></li><li><p>装饰器模式</p></li><li><p>观察者模式</p></li><li><p>动态代理模式</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="版本兼容性问题"><a href="#版本兼容性问题" class="headerlink" title="版本兼容性问题"></a>版本兼容性问题</h4><p>可以用版本号（version）解决兼容性问题，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用</p><h4 id="与SpringCloud关系"><a href="#与SpringCloud关系" class="headerlink" title="与SpringCloud关系"></a>与SpringCloud关系</h4><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p><h4 id="与SpringCloud区别"><a href="#与SpringCloud区别" class="headerlink" title="与SpringCloud区别"></a>与SpringCloud区别</h4><ul><li><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p></li><li><p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p></li></ul><h4 id="与Dubbox的区别"><a href="#与Dubbox的区别" class="headerlink" title="与Dubbox的区别"></a>与Dubbox的区别</h4><ul><li>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</li></ul><blockquote><p>引用<br><a href="https://juejin.cn/post/6844904127076499463">https://juejin.cn/post/6844904127076499463</a><br><a href="https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA">https://mp.weixin.qq.com/s/FPbu8rFOHyTGROIV8XJeTA</a></p></blockquote>]]></content>
    
    
    <summary type="html">Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架Dubbo就出现了</summary>
    
    
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/categories/Dubbo/"/>
    
    
    <category term="Spring" scheme="https://gaoxing27.gitee.io/tags/Spring/"/>
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>redis-线程模型</title>
    <link href="https://gaoxing27.gitee.io/2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gaoxing27.gitee.io/2021/05/27/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-05-27T09:27:14.000Z</published>
    <updated>2021-06-30T10:41:43.697Z</updated>
    
    <content type="html"><![CDATA[<p> redis是单线程模型，所谓单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块该使用多线程仍会使用了多个线程。redis是基于内存的，那么<code>CPU</code>不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。</p><p><code>Redis</code>基于<code>Reactor</code>模式开发了自己的网络事件处理器，称之为文件事件处理器(<code>File Event Hanlder</code>)。文件事件处理器由<code>Socket</code>、<code>IO</code>多路复用程序、文件事件分派器(<code>dispather</code>)，事件处理器(<code>handler</code>)四部分组成。文件事件处理器的模型如下所示：</p><p><img src="/images/redis/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="redis线程模型图"></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p><code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。<code>IO</code>多路复用程序会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，文件事件分派器接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的事件处理器进行处理。</p><h3 id="事件种类"><a href="#事件种类" class="headerlink" title="事件种类"></a>事件种类</h3><ul><li><p>AE_READABLE</p><p>当客户端连接服务器端时，服务器端会将连接应答处理器与<code>socket</code>的<code>AE_READABLE</code>事件关联起来；</p><p>当客户端向服务端发送命令的时候，服务器端将命令请求处理器与<code>AE_READABLE</code>事件关联起来；</p></li><li><p>AE_WRITABLE</p><p>当服务端有数据需要回传给客户端时，服务端将命令回复处理器与<code>socket</code>的<code>AE_WRITABLE</code>事件关联起来。</p></li></ul><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul><li><strong>连接应答处理器</strong>：用于处理客户端的连接请求；</li><li><strong>命令请求处理器</strong>：用于执行客户端传递过来的命令；</li><li><strong>命令回复处理器</strong>：用于返回客户端命令的执行结果；</li></ul><h3 id="客户端与服务端交互"><a href="#客户端与服务端交互" class="headerlink" title="客户端与服务端交互"></a>客户端与服务端交互</h3><p><img src="/images/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" alt="redis客户端与服务端交互流程"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>I/O多路复用本来就是用来解决对多个I/O监听时，一个I/O阻塞影响其他I/O的问题</p><blockquote><p>引用<br><a href="https://juejin.cn/post/6844903849489235982">https://juejin.cn/post/6844903849489235982</a></p></blockquote>]]></content>
    
    
    <summary type="html">redis是单线程模型，更严谨一点，Redis的单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块该使用多线程，仍会使用了多个线程。redis是基于内存的，那么`CPU`不是`Redis`的瓶颈。`Redis`的瓶颈最有可能是机器内存或者网络带宽。</summary>
    
    
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/categories/redis/"/>
    
    
    <category term="IO" scheme="https://gaoxing27.gitee.io/tags/IO/"/>
    
    <category term="redis" scheme="https://gaoxing27.gitee.io/tags/redis/"/>
    
    <category term="线程模型" scheme="https://gaoxing27.gitee.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
