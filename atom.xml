<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卑以自牧，含章可贞</title>
  
  <subtitle>五朝</subtitle>
  <link href="https://gaoxing27.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gaoxing27.gitee.io/"/>
  <updated>2022-04-01T07:13:26.290Z</updated>
  <id>https://gaoxing27.gitee.io/</id>
  
  <author>
    <name>夜听冰河</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何高效的使用Intellij IDEA</title>
    <link href="https://gaoxing27.gitee.io/2022/04/01/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Intellij-IDEA/"/>
    <id>https://gaoxing27.gitee.io/2022/04/01/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Intellij-IDEA/</id>
    <published>2022-04-01T06:21:00.000Z</published>
    <updated>2022-04-01T07:13:26.290Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/edfe03f5a28d32fa01b8e8bd16980a22.jpeg" alt="866D62717C224FBBAD0CBA397424AAEE.jpeg"></p><p>安装好Intellij idea之后，进行如下的初始化操作，工作效率提升十倍。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><strong>1. Codota 代码智能提示插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/279ef426843f57d175feedaa49513985.png" alt="A8232D538C014A45B5139686CD7DD91A.png"></p><p>只要打出首字母就能联想出一整条语句，这也太智能了，还显示了每条语句使用频率。</p><p>原因是它学习了我的项目代码，总结出了我的代码偏好。</p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/4aefedaee941623bec004a276911dff0.png" alt="830076904E7543158D370D4AED102AC5.png"></p><p><strong>如果让它再加上机器学习，人工智能写代码的时代还会远吗？</strong></p><p><strong>2. Key Promoter X 快捷键提示插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/09a0673cf40ac094b5ae2320cb6c7242.png" alt="49B953B0428E401595C64DAA7308FC38.png"></p><p>每次都会在右下角弹窗提示，帮助我们快速熟悉快捷键。</p><p><strong>3. CodeGlance 显示代码缩略图插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/5a1035d591aa1de91c649304b6edf6a4.jpeg" alt="64BBF408DD8742CEA7DE4D96E75F5B6E.jpeg"></p><p>当代码很多的时候，方便查看，很有用。</p><p><strong>4. Lombok 简化臃肿代码插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/97800a477a768239f7b8c8d4261736ca.png" alt="9E2BD452865346F6BA1BA6662327B6B9.png"></p><p>实体类中的get/set/构造/toString/hashCode等方法，都不需要我们再手动写了</p><p><strong>5. Alibaba Java Coding Guidelines 阿里巴巴代码规范检查插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/8833b7d187ee5923c2834b87dfa7f321.jpeg" alt="4738AB4701D849B69B36125876AC1DC2.jpeg"></p><p>会按照阿里Java开发手册上规范帮我们检查代码，然后对代码做不同颜色展示，鼠标放上去，会看到提示内容，帮助我们写出更规范的代码。</p><p><strong>6. CamelCase 驼峰命名和下划线命名转换</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/cd00189aae86a8cdce86590f05a5e67a.png" alt="73623DF8E1264C33BFD257E9254E046D.png"></p><p>这几种风格的命名方式，用快捷键 ⇧ + ⌥ + U / Shift + Alt +<br>U可以进行快速转换，当我们需要修改大量变量名称的时候很方便。</p><p><strong>7. MybatisX 高效操作Mybatis插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/b364732300418faaa9f67127050fcc19.png" alt="65757B8A07564A02B0724953B1345C92.png"></p><p><strong>8. SonarLint 代码质量检查插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/e8dd8744d4639cd0885f353a4df8ac73.jpeg" alt="0DC960EA0883476AAA8B795EA4BF0F71.jpeg"></p><p>提示我不要用System.out输出，要用logger输出，诸如此类，帮助我们提升代码质量。</p><p><strong>9. Save Actions 格式化代码插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/6a2fc798030265c81f2b9b5f840f92be.png" alt="0145B14A962144EEACC87024C6411E24.png"></p><p>可以帮忙我们优化包导入，自动给没有修改的变量添加final修饰符，调用方法的时候自动添加this关键字等，使我们的代码更规范统一。</p><p><strong>10. CheckStyle 代码风格检查插件</strong></p><p>功能跟Alibaba Java Coding Guidelines类似</p><p><strong>11. Grep Console 自定义控制台输出格式插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/702fd57e3ea0f36888e701432fae8044.png" alt="8638921ECCD8478B9B0094112771B3BA.png"></p><p><strong>12. MetricsReloaded 代码复杂度检查插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/a2f30b53d5a91b93e30f26106a470a6a.png" alt="C5FB06341399494E9B4A658D951EBC32.png"></p><p><strong>13. Statistic 代码统计插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/44cb190e1b424e4eca3f6d4c2d81dafe.png" alt="8ED70BF4A9274B7A863C38459A52D911.png"></p><p><strong>14. Translation 翻译插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/3944d084895031afde6065840aae89e6.png" alt="25DBA96B16CE41DEB1ECAB4BA5D4657D.png"></p><p><strong>15. Rainbow Brackets 彩虹括号插件</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/bb8b7f9448ae2242ef376b28d63ed071.png" alt="4A86A52AE389469AA5F4672F736DDA07.png"></p><p>成对儿的括号显示相同的颜色，有了这个插件，我的近视都好了。</p><h2 id="自定义创建live-template，快速写代码"><a href="#自定义创建live-template，快速写代码" class="headerlink" title="自定义创建live template，快速写代码"></a>自定义创建live template，快速写代码</h2><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/94abe361f11897a66f50082e6d2c71f9.jpeg" alt="1705F48EA30E403EA10943967CE74954.jpeg"></p><p>只要输入<strong>apr</strong> ，就能自动提示，并且生成<strong>Autowired</strong><br>语句了。可以根据自己的代码习惯，自定义一些代码模板，帮助我们快速写代码。</p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/757305e94c89fe4ad77e7b58169ea737.jpeg" alt="B9470263D6F84FF786568C526844D661.jpeg"></p><h2 id="修改全局配置，提升工作效率"><a href="#修改全局配置，提升工作效率" class="headerlink" title="修改全局配置，提升工作效率"></a>修改全局配置，提升工作效率</h2><p><strong>1. 优化导包配置</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/39cfbe85f85590720fdd036652aca247.png" alt="57EFA4DEC04943BCB07C7F93972326FA.png"></p><p><strong>2. 取消tab页单行显示</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/e9b763d41ce3fa6fc55fc407b451b94a.png" alt="3BD742BCC0B24147A581AA1FB10D2F72.png"></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/eae1c5027f9d86a4943dbb1a818714d7.png" alt="FDB7789C604743389ED3CF3345C812FE.png"></p><p>多行显示更多的文件，方便查看。</p><p><strong>3. 双斜杠注释改成紧跟代码头</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/403eb084fc01a51d710ad4f29625684d.png" alt="4AACB53200EC4CE28AF72C16C00110F4.png"></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/e3cfec5ae6dea335828cb5d65ee3b4e0.png" alt="1623476E548B4BE1A576FFFC19D491EE.png"></p><p><strong>4. 选中复制整行</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/fe608693a030e6bfc46b97c6f3929f9d.png" alt="F575DB6240E9487BA274344BF42FCFBF.png"></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/de26b44b2702d1e952a511e558a70a49.png" alt="1DFD9123468046018D16272E8871E3FF.png"></p><p>原本只会复制你选中的代码，改完配置后，就能复制整行，无论你是否完全选中。</p><p><strong>5. 取消匹配大小写</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/849df4ae0e35749a60a9b3b994260a8c.png" alt="88D2EB111175415586BE893495AE553D.png"></p><p>取消勾选后，输入小写 <strong>s</strong> ，也能提示出 <strong>String</strong></p><p><strong>6. 优化版本控制的目录颜色展示</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/7c75e814ba0fbc62cefe1962e14cba5c.png" alt="A35DE313FE594419B0CE043203CE63B4.png"></p><p><strong>7. 创建文件时，自动生成作者和时间信息</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/af7f201ca493e4d6c10823554881bd84.png" alt="8965B0589B2D4924A200E18C7EF7F607.png"></p><p><strong>8 . 显示行号和方法分割线</strong></p><p><img src="/images/%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8idea/390a00a03b5d05ad53881ac3de3c7ccd.png" alt="68FF466CF7854F499E2712AA2C399BB4.png"></p><blockquote><p>来源于网络</p><p>—好的东西，只有分享给懂它的人，才能体现它的价值。</p></blockquote>]]></content>
    
    
    <summary type="html">工欲善其事，必先利其器。</summary>
    
    
    
    <category term="编辑工具" scheme="https://gaoxing27.gitee.io/categories/%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="idea" scheme="https://gaoxing27.gitee.io/tags/idea/"/>
    
    <category term="编程工具" scheme="https://gaoxing27.gitee.io/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>人活着究竟是为了什么</title>
    <link href="https://gaoxing27.gitee.io/2022/03/25/%E4%BA%BA%E6%B4%BB%E7%9D%80%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://gaoxing27.gitee.io/2022/03/25/%E4%BA%BA%E6%B4%BB%E7%9D%80%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%BA%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-03-25T05:26:22.000Z</published>
    <updated>2022-03-25T05:52:41.768Z</updated>
    
    <content type="html"><![CDATA[<p>1、什么是成功。</p><p>当人到中年的时候，身体健康，略有积蓄，已婚，配偶体贴，孩子听话，有一份比较喜欢的工作，不必成名，也不必发财，不必老要看人眼色行事，做想做的那个自己，这就是成功。</p><blockquote><p>每个人在不同的时间对成功的理解都不相同，我在读书上学的时候，我觉得好好学习，上一个好的学校，找一个好一点的工作，就是成功；后来上了大学我觉得只要工作了，可以自己自食其力，不必再依靠父母，就是成功；再后来工作了，刚开始工资很低，我觉得工资要是能再高一些，可以买车、买房、让父母少一些操劳，就是成功；再再后来，我结婚了，有了孩子，我觉得把孩子教育好了，我走过的弯路，他不要再走，他可以在他想做一些事的时候能够去做，就是成功。</p><p>回首过去，我发现，每一个阶段因为诉求的不同，对成功的理解也不同，在脑海深处，我也在反问自己：我为什么而活？我究竟在追求什么？</p><p>假如我此刻死了，或者突然从这个世界消失了，最先发现的大概是我的妻子，因为本应该按时下班回家吃饭，没有回家，没有电话，她一定会打我的手机，越打不通，越着急，然后是我公司的同事，还有个问题没有处理，怎么找不到人了，也会打我的电话，实在打不通就找其他人来解决这个问题了，然后是我的父母，一个月了也没往家打一个电话，他们会想自己的儿子，他们会打我的电话，看是不是最近太忙了。</p><p>一周以后，还是找不到人，我的妻子和父母报了警，每天期盼着自己的丈夫和儿子能回来，公司也因为一直找不到人，找了另外一个人顶替我的岗位。</p><p>再过很久很久以后，我的妻子也许会另嫁，也许不会，我的父母仍然会期盼着儿子的消息，公司早就忘记了还有我这么一个人了。</p><p>想到这里，会明白：成功、快乐、价值、幸福的终极是血脉相连、荣辱与共的家人。好好活着，尽自己的努力，照顾好家人，就够了。</p></blockquote><p>2、什么是快乐。</p><p>因癌辞世的复旦大学教师于娟，在生前日记写道：在生死临界点的时候，你会发现，任何的加班（长期熬夜等于慢性自杀）， 给自己太多的压力，买房买车的需求，这些都是浮云。如果有时间，好好陪陪你的孩子，把买车的钱给父母亲买双鞋子，不要拼命去换什么大房子，换什么豪车，和相爱的人在一起，蜗居也温暖，自行车也快乐！</p><p>3、你的价值在哪。</p><p>假如你病倒了或者猝死了，你服务的单位会第一时间找到人替代你，一切如常运作，你没想象得那么重要；而你的父母、家人、爱人孩子的天会塌下来，你对于他们才是最重要的。所以再别秉持什么自己有病不去看；适度工作，多陪家人，爱惜自己，过正常的日子。</p><p>4、什么是幸福。</p><p>家里没病人，牢里没亲人，外头没仇人，圈里没小人，身边没坏人；看似好像没情人，办事有熟人，谈笑有哲人，聚会有高人，喝茶有贤人，闲聊有达人，发条微信有一大帮转发的人。生命中，有喜欢做的事，有健康的身体，有爱你的人，有一个乖巧阳光的孩子，有几个一段日子不见就想的朋友，这就是幸福！</p><blockquote><p>作者：佚名，来源网络</p></blockquote>]]></content>
    
    
    <summary type="html">每个人在不同的时间对成功的理解都不相同，我在读书上学的时候，我觉得好好学习，上一个好的学校，找一个好一点的工作，就是成功；后来上了大学我觉得只要工作了，可以自己自食其力，不必再依靠父母，就是成功；再后来工作了，刚开始工资很低，我觉得工资要是能再高一些，可以买车、买房、让父母少一些操劳，就是成功；再再后来，我结婚了，有了孩子，我觉得把孩子教育好了，我走过的弯路，他不要再走，他可以在他想做一些事的时候能够去做，就是成功。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Apache架构师总结的30条架构原则</title>
    <link href="https://gaoxing27.gitee.io/2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/"/>
    <id>https://gaoxing27.gitee.io/2022/03/25/Apache%E6%9E%B6%E6%9E%84%E5%B8%88%E6%80%BB%E7%BB%93%E7%9A%8430%E6%9D%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-25T03:52:33.000Z</published>
    <updated>2022-03-25T05:24:06.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文作者叫 Srinath，是一位科学家，软件架构师，也是一名在分布式系统上工作的程序员。他是 Apache Axis2 项目的联合创始人，也是 Apache Software 基金会的成员。他是 WSO2 流处理器（wso2.com/analytics）的联席架构师。Srinath 撰写了两本关于 MapReduce 和许多技术文章的书。他获得了博士学位。来自美国印第安纳大学。  </p></blockquote><p>Srinath 通过不懈的努力最终总结出了 30 条架构原则，他主张架构师的角色应该由开发团队本身去扮演，而不是专门有个架构师团队或部门。而不是专门有个架构师团队或部门。Srinath 认为架构师应该扮演的角色是一个引导者，讨论发起者，花草修建者，而不是定义者和构建者。Srinath 为了解决团队内部的架构纷争和抉择，制定了以下 30 条原则，这些原则被成员们广泛认可，也成为了新手架构师的学习途径。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>原则 1：KISS(Keep it simple,sutpid) ：保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。  </p><blockquote><p>点评：简单即是复杂！拿你的代码来说，你想要写的简单且容易理解的话，你就需要花更多的时间去思考。  </p></blockquote><p>原则 2：YAGNI(You aren’t gonna need it)：不要去搞一些不需要的东西，需要的时候再搞吧。</p><blockquote><p>点评 : 这一点我被 diss 过好几次，之前的时候，我总是臆想觉得某个功能以后可能会用到，然后就顺手把它实现了，实际到了后面并没用上，反而造成了代码冗余。</p></blockquote><p>原则 3： 爬，走，跑。换句话说就是先保证跑通，然后再优化变得更好，然后继续优化让其变得伟大。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑（最大两周），然后去迭代。</p><p>原则 4：创建稳定、高质量的产品的唯一方法就是<strong>自动化测试</strong>。所有的都可以自动化，当你设计时，不妨想想这一点。</p><blockquote><p>点评：单侧还是很有必要的，但是没有一个恒定的标准说你应该怎么去做。</p></blockquote><p>原则 5： 时刻要想投入产出比（ROI）。就是划得来不。</p><p>原则 6： 了解你的用户，然后基于此来平衡你需要做哪些事情。不要花了几个月时间做了一个 devops 用户界面，最后你发现那些人只喜欢命令行。此原则是原则 5 的一个具体表现。</p><blockquote><p>点评:是否有站在用户的角度思考问题呢？是否是为了用新技术而用新技术？</p></blockquote><p>原则 7：设计和测试一个功能，尽可能的独立。当你做设计时，应该想想这一条。从长远来看这能给你解决很多问题，否则你的功能只能等待系统其他所有的功能都就绪了才能测试，这显然很不好。有了这个原则， 你的版本将会更加的顺畅。</p><p>原则 8： 不要搞花哨的。我们都喜欢高端炫酷的设计。最后我们搞了很多功能和解决方案到我们的架构中，然后这些东西根本不会被用到。<br>点评:简单点！说话的方式简单点！</p><h4 id="功能选择"><a href="#功能选择" class="headerlink" title="功能选择"></a>功能选择</h4><p>原则 9： 不可能预测到用户将会如何使用我们的产品。所以要拥抱 MVP（Minimal Viable Product），最小可运行版本。这个观点主要思想就是你挑几个很少的使用场景，然后把它搞出来，然后发布上线让用户使用，然后基于体验和用户反馈再决定下一步要做什么。</p><p>原则 10： 尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。</p><p>原则 11： 等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。</p><p>原则 12：<strong>有时候你要有勇气和客户说不</strong>。这时候你需要找到一个更好的解决方案来去解决。记住亨利福特曾经说过的 ：”如果我问人们他们需要什么，他们会说我需要一匹速度更快的马”。记住：你是那个专家，你要去引导和领导。要去做正确的事情，而不是流行的事情。最终用户会感谢你为他们提供了汽车。</p><h4 id="服务端设计和并发"><a href="#服务端设计和并发" class="headerlink" title="服务端设计和并发"></a>服务端设计和并发</h4><p>原则 13：要知道一个 server 是如何运行的，从硬件到操作系统，直到编程语言。优化 IO 调用的数量是你通往最好架构的首选之路。</p><p>原则 14： 要了解 Amdhal 同步定律。在线程之间共享可变数据会让你的程序变慢。只在必要的时候才去使用并发的数据结构，只在必须使用同步（synchronization）的时候才去使用同步。如果要用锁，也要确保尽可能少的时间去 hold 住锁。如果要在加锁后做一些事情，要确保自己在锁内会做哪些事情。</p><p>原则 15：如果你的设计是一个无阻塞且事件驱动的架构，那么千万不要阻塞线程或者在这些线程中做一些 IO 操作，如果你做了，你的系统会慢的像骡子一样。</p><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>原则 16：无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东东出来，这是起码的。</p><p>原则 17：保证消息只被传递一次，不管失败，这很难，除非你要在客户端和服务端都做控制。试着让你的系统更轻便（使用原则 18）。你要知道大部分的承诺 exactly-once-delivery 的系统都是做了精简的。</p><p>原则 18：实现一个操作尽可能的幂等。这样的话就比较好恢复，而且你还处于至少一次传递（at least once delivery）的状态。</p><p>原则 19： 知道 CAP 理论。可扩展的事务（分布式事务）是很难的。如果可能的的话，尽可能的使用补偿机制。RDBMS 事务是无法扩展的。</p><p>原则 20： 分布式一致性无法扩展，也无法进行组通信，也无法进行集群范围内的可靠通信。理想情况下最大的节点限制为 8 个节点。</p><p>原则 21： 在分布式系统中，你永远无法避免延迟和失败。</p><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><p>原则 22： 要了解你的用户和清楚他们的目标。他们是新手、专家还是偶然的用户？他们了解计算机科学的程度。极客喜欢扩展点，开发者喜欢示例和脚本，而普通人则喜欢 UI。</p><p>原则 23： 最好的产品是不需要产品手册的。</p><blockquote><p>点评：这个是说产品易用。很多人觉得敏捷开发下不需要文档，实际上，一个系统即是在敏捷开发的情况下，有些必要的文档比如重大更新记录、相关硬件设施等等还是需要的。</p></blockquote><p>原则 24： 当你无法在两个选择中做决定的时候，请不要直接把这个问题通过提供配置选项的方式传递给用户。这样只能让用户更加的发懵。如果连你这个专家都无法选择的情况下，交给一个比你了解的还少的人这样合适吗？最好的做法的是每次都找到一个可行的选项；次好的做法是自动的给出选项，第三好的做法是增加一个配置参数，然后设置一个合理的默认值。</p><p>原则 25： 总是要为配置设置一个合理的默认值。</p><p>原则 26：设计不良的配置会造成一些困扰。应该总是为配置提供一些示例值。</p><p>原则 27： 配置值必须是用户能够理解和直接填写的。比如：不能让用户填写最大缓存条目的数量，而是应该让用户填写可被用于缓存的最大内存。</p><p>原则 28： 如果输入了未知的配置要抛出错误。永远不要悄悄的忽略。悄悄的忽略配置错误往往是找 bug 花了数小时的罪魁祸首。</p><h4 id="艰难的问题"><a href="#艰难的问题" class="headerlink" title="艰难的问题"></a>艰难的问题</h4><p>原则 29： 梦想着新的编程语言就会变得简单和明了，但往往要想真正掌握会很难。不要轻易的去换编程语言。</p><p>原则 30： 复杂的拖拉拽的界面是艰难的，不要去尝试这样的效果，除非你准备好了 10 人年的团队。</p><p>最后，说一个我的感受。在一个理想的世界里，一个平台应该是有多个正交组件组成-每个组件都负责一个方面（比如，security，messaging，registry，mdidation，analytics）。好像一个系统构建成这样才是完美的。</p><p>但不幸的是，现实中我们很难达到这样的状态。因为在项目初始状态时，很多事情是不确定的，你无法做到这样的独立性，现在我更倾向于在开始的时候适当的重复是必要的，当你尝试铲除他们的时候，你会发现引入了新的复杂性，分布本身就意味着复杂。有时候治愈的过程要比疾病本身更加的糟糕。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>作为一个架构师，应该像园丁一般，更多的是修剪花草，除草而不是去定义和构建，你应该策划而不是指挥，你应该去修剪而不是去定义，应该是讨论而不是贴标签。</p><p>虽然在短期内可能会觉得也没什么，但从长远看，指导团队找到自己的方式会带来好处。如果你稍不留神，就很容易让架构成为一个空洞的词汇。比如设计者会说他的架构是错误的，但不知道为什么是错误的。一个避免这种情况的好办法就是有一个原则列表，这个原则列表是被广泛接受的，这个列表是人们讨论问题的锚点，也是新手架构师学习的路径。</p>]]></content>
    
    
    <summary type="html">Srinath 通过不懈的努力最终总结出了 30 条架构原则，他主张架构师的角色应该由开发团队本身去扮演，而不是专门有个架构师团队或部门。而不是专门有个架构师团队或部门。Srinath 认为架构师应该扮演的角色是一个引导者，讨论发起者，花草修建者，而不是定义者和构建者。Srinath 为了解决团队内部的架构纷争和抉择，制定了以下 30 条原则，这些原则被成员们广泛认可，也成为了新手架构师的学习途径。</summary>
    
    
    
    <category term="架构设计" scheme="https://gaoxing27.gitee.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构设计" scheme="https://gaoxing27.gitee.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>好好的写代码吧</title>
    <link href="https://gaoxing27.gitee.io/2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/"/>
    <id>https://gaoxing27.gitee.io/2022/02/28/%E5%A5%BD%E5%A5%BD%E7%9A%84%E5%86%99%E4%BB%A3%E7%A0%81%E5%90%A7/</id>
    <published>2022-02-28T03:59:13.000Z</published>
    <updated>2022-02-28T03:59:52.060Z</updated>
    
    <content type="html"><![CDATA[<p>好好的写软件、写代码，不给别人挖坑，这应该是每个程序员对自己最基本的要求。当然我也踩过别人的坑，曾经由于自己的无知，也给别人挖过坑。不管因为什么，烂的代码一旦上线，你就得维护它，这是件很痛苦的事情。就好像你撒了一个谎，为了圆这个谎，你不得不再撒更多的谎，可谎言终究是谎言，终究会被扯破的一天。当某一天实在维护不动了，你走了，来了一个新的程序员来维护他，你失去了一个成为优秀程序员的机会，同时也浪费了更多人的时间和精力。<br>我们的时间应该去写好的代码、做好的事情，然后享受生活，而不是和这些烂代码搏斗。如果不重视这些事情，会制造很多麻烦，会让质量下降，会让一个本来可以快速推进的事情变得缓慢，会让你不得不去做一些无聊的事情、解决一些无聊的问题。也会挫伤想写好的代码的人的积极性。所以，如果你不好好写代码，你乱管理事情，我会认为你在给我制造麻烦，浪费我的时间，那么我就会和你有一些争论。<br>无论在哪个位置，都应该有一些自己的追求，至少不要成为别人的麻烦，而是努力成为一个解决麻烦的人。如果你的心和大脑在解决麻烦的路上，那么你犯的错误，我称之为经验；如果你是一个麻烦制造者，并且浑然不觉，那么我想我会提醒你；当然，我并不想教你做事，我只是想和你一起成为麻烦、问题的终结者，然后下班。</p>]]></content>
    
    
    <summary type="html">好好的写软件、写代码，不给别人挖坑，这应该是每个程序员对自己最基本的要求。当然我也踩过别人的坑，曾经由于自己的无知，也给别人挖过坑。不管因为什么，烂的代码一旦上线，你就得维护它，这是件很痛苦的事情。就好像你撒了一个谎，为了圆这个谎，你不得不再撒更多的谎，可谎言终究是谎言，终究会被扯破的一天。当某一天实在维护不动了，你走了，来了一个新的程序员来维护他，你失去了一个成为优秀程序员的机会，同时也浪费了更多人的时间和精力。</summary>
    
    
    
    <category term="工作" scheme="https://gaoxing27.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="工作" scheme="https://gaoxing27.gitee.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>好文摘录</title>
    <link href="https://gaoxing27.gitee.io/2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    <id>https://gaoxing27.gitee.io/2022/02/15/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/</id>
    <published>2022-02-15T03:52:04.000Z</published>
    <updated>2022-04-07T03:28:11.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记住：不要愤怒，愤怒会降低你的智慧，也不要恨自己的敌人，仇恨会使你丧失判断，忠义和奸恶都不是从表面看出来的，自古以来就是大奸似忠，大伪似真，并非我曹操皮厚，而是我把这世上，那些庸俗不堪的纲常伦理早已不放在心上了。"><a href="#记住：不要愤怒，愤怒会降低你的智慧，也不要恨自己的敌人，仇恨会使你丧失判断，忠义和奸恶都不是从表面看出来的，自古以来就是大奸似忠，大伪似真，并非我曹操皮厚，而是我把这世上，那些庸俗不堪的纲常伦理早已不放在心上了。" class="headerlink" title="记住：不要愤怒，愤怒会降低你的智慧，也不要恨自己的敌人，仇恨会使你丧失判断，忠义和奸恶都不是从表面看出来的，自古以来就是大奸似忠，大伪似真，并非我曹操皮厚，而是我把这世上，那些庸俗不堪的纲常伦理早已不放在心上了。"></a>记住：不要愤怒，愤怒会降低你的智慧，也不要恨自己的敌人，仇恨会使你丧失判断，忠义和奸恶都不是从表面看出来的，自古以来就是大奸似忠，大伪似真，并非我曹操皮厚，而是我把这世上，那些庸俗不堪的纲常伦理早已不放在心上了。</h2><p>远方知我意<br>微凉又深情<br>爱意随风起<br>风起意难平</p><hr><p>如果你的人生或事业正陷入困境，不外乎三个原因<br>不明己，不知道自己是谁，常常陷入欲望与情绪的轮回之中<br>不明人，不明白别人言语背后的动机<br>不明事，无法发现事情的真相</p><hr><p>自我介绍<br>我是谁，我从哪里来<br>我为什么出现在这里<br>我能带大家创造什么价值<br>我希望得到大家什么样的支持</p><hr><p>不管出了什么样的事<br>要先学会坐下<br>要成大事<br>首先就得沉得住气<br>尽管你没有什么办法<br>也要装成成竹在胸的样子才行<br>大丈夫遇事<br>需进退隐险<br>决断有章</p><hr><p>事事如舟挂短篷<br>或移西岸或移东<br>几回缺月还圆月<br>数阵南风又北风<br>岁久人无千日好<br>春深花有几时红<br>事非入耳君须忍<br>半作痴呆半作聋</p><hr><p>我与春风皆过客<br>你携秋水揽星河<br>愿有岁月可回首<br>且以深情共白头</p><hr><p>世事一场大梦<br>人生几度秋凉<br>不如意事常八九<br>可语与人无二三<br>直到相思了无益<br>未妨惆怅是轻狂<br>世事微尘里<br>吾宁爱与憎<br>浮云一别后<br>流水十年间</p><hr><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p><hr><p>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，则万事可成  <span id="more"></span></p><hr><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p><hr><p>如果此时的你正在经历痛苦<br>那么请记住<br>我们所遭遇的痛苦与磨难<br>其实只是过去行为的一个结果<br>我们没有理由去责怪他人<br>更没有必要自责<br>你若能能积极的心态面对它<br>那么正在经历的痛苦<br>不仅完结了一个旧的因果<br>而且还会成为一个新的善因<br>痛苦并不总是坏事<br>人生的得失起伏<br>都可以是让你觉悟的契机<br>关键是看你以怎样的心态去面对<br>—次第花开  </p><hr><p>初入红尘<br>不知人间疾苦<br>蓦然回首<br>已是苦中之人<br>这杯中酒三分<br>这酒中悲七分<br>关关难过关关过<br>夜夜难熬夜夜熬<br>愿这世间所有爱恨情仇皆溶于酒<br>且将这风尘作酒<br>一饮消愁</p><hr><p>世间万物都是空<br>功名利禄逝如风<br>天也空地也空<br>人生渺茫在其中<br>金也空银也空<br>死后何曾在手中<br>权也空名也空<br>转眼荒郊土一捧<br>情也空义也空<br>大难来时影无踪<br>生如百花逢春好<br>死如黄叶落秋风<br>回首仔细思量起<br>便是南柯一梦中<br>–看破想通，万事皆空  </p><hr><p>君子慎独<br>不欺暗室<br>卑以自牧<br>含章可贞<br>大丈夫立于天地之间<br>当仰天地浩然正气<br>行光明磊落之事<br>克己慎独守心明性  </p><hr><p>子成人父方解油盐非易事<br>女为人母才知酱醋味千般<br>幼年常感父身宽<br>双肩可撼千重山<br>而今转瞬成人父<br>才知年少见识偏<br>流光逝<br>步蹒跚<br>碎银几两汉子难<br>也曾心怀青云志<br>回首只盼老少安  </p><hr><p>自古人生最忌满<br>半贫半富半自安<br>半命半天半机遇<br>半取半舍半行善<br>半聋半哑半糊涂<br>半智半愚半圣贤<br>半人半我半自在<br>半醒半醉半神仙<br>半亲半爱半苦乐<br>半俗半禅半随缘<br>人生一半在于我<br>另外一半听自然  </p><hr><p>对于无能为力的事，当断<br>对于生命中无缘的人，当舍<br>对于心中的烦与杂念，当离<br>目光所及，皆是回忆；<br>心之所想，皆是过往；<br>只有放下执念，心才能回归安宁。</p><hr><p>鱼那么信任水，水却把它煮了<br>树叶那么信任风，风却把它吹落了<br>我那么信任你，你却把我伤害了<br>后来我才发现<br>煮鱼的不是水，而是火<br>吹落树叶的不是风，而是秋天，<br>伤害我的也不是你，而是我的自作多情；  </p><hr><p>聋子说炮不响<br>瞎子说灯不亮<br>瘸子说炮挺响，灯也亮<br>只是这看起来平平坦坦的路走起来有点摇摇晃晃<br>人呐，<br>如果看不到自己的问题和不足，总会认为错的是别人。</p><hr><p>人间非净土<br>各有各的苦<br>同是红尘悲伤客<br>莫笑谁是可怜人<br>杯中倒满无情酒<br>眼中再无意中人</p><hr><p>几时归去<br>做个闲人<br>忙时勤努力<br>闲时赏风月<br>逢人不说人间事<br>便是人间无事人<br>若无闲事挂心头<br>便是人间好时节  </p><hr><p>你我暮年<br>闲坐庭院<br>云卷云舒听雨声<br>星密星稀赏月影<br>花开花落忆江南<br>你话往时我话往事<br>愿有岁月可回首<br>且以深情共白头  </p><hr><p>时光总在静中定<br>流水却穿五孔桥<br>年少应虑道中事<br>莫等红尘催白头  </p><hr><p>半山烟雨半生忧<br>一念心轻万事休<br>山后本是清静地<br>怎奈俗人一身愁  </p><hr><p>我本一身傲骨<br>奈何世事无常<br>悲从心中起<br>百般不如人<br>本以为傲从骨中生<br>万难不屈膝<br>可是傲骨又值几分钱<br>最可叹放下了尊严<br>却换不回柴米油盐  </p><hr><p>三十而立<br>人生将半<br>也曾克己奋发<br>胸怀激荡<br>幻想红衣白马<br>气吐眉扬<br>然终是柴米挫了锐气<br>染了风霜  </p><hr><p>半生风雨半生寒<br>一杯浊酒敬流年<br>回首过往半生路<br>七分酸楚三人甜<br>日出东方催人醒<br>不及晚霞懂我情<br>辞别再无相见日<br>终是一人度春秋  </p><hr><p>世事茫茫，光阴有限，算来何必奔忙。<br>人生碌碌，竟短论长，却不道荣枯有数，得失难量。<br>看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。<br>荣华花上露，富贵草上霜。<br>机关参透，万虑皆忘。<br>夸什么龙楼凤阁，说什么利锁名缰。<br>闲来静处，且将诗酒猖狂。</p><hr><p>法不轻传，<br>道不贱卖，<br>师不顺路，<br>医不叩门，<br>千金不传无义子，<br>万财不渡忘恩人，<br>医逢信者但可救，<br>道遇无明枉费心，<br>甘露不润无根草，<br>妙法只渡有缘人。</p><hr><p>不与君子争名，<br>不与小人夺利，<br>不与天地比巧，<br>将军有剑不斩苍蝇，<br>文臣执笔不负苍生。</p><hr><p>终日奔波只为饥<br>方才一饱便思衣<br>衣食两般皆具足<br>又思娇柔美貌妻<br>娶得美妻生下子<br>恨无田地少根基<br>门前买下田千顷<br>又思出门少马骑<br>槽头拴了骡和马<br>又思无官被人欺<br>一品当朝为宰相<br>还想山河夺帝基<br>心满意足为天子<br>又想长生不老期<br>一旦求得长生药<br>再跟上帝论高低</p><hr>]]></content>
    
    
    <summary type="html">记住：不要愤怒，愤怒会降低你的智慧，也不要恨自己的敌人，仇恨会使你丧失判断，忠义和奸恶都不是从表面看出来的，自古以来就是大奸似忠，大伪似真，并非我曹操皮厚，而是我把这世上，那些庸俗不堪的纲常伦理早已不放在心上了。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>夜听冰河</title>
    <link href="https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/"/>
    <id>https://gaoxing27.gitee.io/2022/01/23/%E5%A4%9C%E5%90%AC%E5%86%B0%E6%B2%B3/</id>
    <published>2022-01-23T09:10:58.000Z</published>
    <updated>2022-02-28T02:57:22.775Z</updated>
    
    <content type="html"><![CDATA[<p>给自已取了一个新的网名，“夜听冰河”。<br>取自：《十一月四日风雨大作》作者：陆游 作于公元1192年<br>僵卧孤村不自哀，尚思为国戍轮台。<br>夜阑卧听风吹雨，铁马冰河入梦来。<br>夜深了，年近古稀（陆游生于公元1125年，此诗作于1192年，当时作者67岁）的一老翁直挺挺的躺在孤寂荒凉的小乡村里，一边听着外面的风吹着雨，雨又打着风，一边又在想如今虽身处荒野，但这又算得了什么，哪里有值得感到悲哀的，只要我还能再为国家戍守边疆，再出一份力，听着听着，想着想着，竟迷迷糊糊睡着了，仿佛真的回到了边关，骑着披甲的战马，跨过冰封的河流。。。<br>如实说，这首诗读高中时学习过，也理解诗要表达的感情，但是偶然间，脑子里不自主的闪现出，“夜阑卧听风吹雨，铁马冰河入梦来。”，就再次去品味这首诗，竟别有另一番感触。只能说好的诗人，一定是一个感情充沛，精神世界丰富的人；好的诗，一定是最简单的文字里承载着最真挚的感情。无疑，陆游是一个伟大的诗人，他的这首十一月四日风雨大作也是一首不朽的诗。从放翁先生的诗中，感受到了真挚爱国报国之情，也看到一年近七十的老翁，人生失意，壮志未酬，不是追悔，不是抱怨，亦不是叹时光匆匆，却是年老之躯，少年雄心，做梦都在想着能披甲再战，一颗不屈之心，一副铮铮之骨跃然纸上。也许正是先生这不屈之心，铮铮之骨早已烙入我心，才会在某一刻闪现在我的脑海中。<br>诗解析完了，思考却没有停止，为什么后两句突然会跃现于我的脑海里？对于现代社会的人们，确切说是世俗社会的人们来说，一首写于829年前的诗，还有什么意义？<br>澄清一点我这里之所以说是世俗社会的，是因为当前社会世俗规则大行其道，有人可能不解了，什么又是世俗规则呢？简单说：搞钱第一，有钱就代表成功，没有挣到钱就代表失败，金钱第一，也是实力、地位的象征。而我所理解的现代社会，是物质与精神同等重要的社会，人们除了追求更高的物质生活，也漫游于丰富的精神海洋。因商场失败，跳楼自杀；因家产继承，兄弟反目；因一己贪欲，行贿受贿索贿如登大堂。凡此种种，数不胜数。<br>其实这一切的后果，都是可以避免的，但前提是你的精神世界是丰富的、充沛的，无论得意、失意，都能为你点燃一盏灯火，指引你前行。对于身负巨额债务的人来说，如果你听过“海到尽头天作岸，山登绝顶我为峰。如日东山能再起，大鹏展翅恨天低。”，哪还用以寻死求解脱；如果你明白“打虎亲兄弟，上阵父子兵”、“兄弟阋于墙，外御其侮”，家资丰厚或贫瘠，当兄谦弟恭，戮力同心，何愁家道不兴？身居显位，是实力所至，已得人前之贵，如果你懂得，“为天地立心，为生民立命，为往圣继绝学，为万世开太平。”，又何必以蝇蝇之利污洁白之羽，展天之翅。<br>很喜欢，沈复在《浮生六记》中的一段话，送给自己及所有精神世界还很贫瘠的人：世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。<br>多么的洒脱无碍，来去如风呀，只要过得幸福、轻松、自在，何必为多拿两个铜板而机关算尽？</p>]]></content>
    
    
    <summary type="html">世事茫茫，光阴有限，算来何必奔忙！人生碌碌，竞短论长，却不道荣枯有数，得失难量。看那秋风金谷，夜月乌江，阿房宫冷，铜雀台荒。荣华花上露，富贵草头霜。机关参透，万虑皆忘。夸什么龙楼凤阁，说什么利锁名缰。闲来静处，且将诗酒猖狂。唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳，约几个知心密友，到野外溪旁。或琴棋适性，或曲水流觞，或说些善因果报，或论些今古兴亡。看花枝堆锦绣，听鸟语弄笙簧。一任他人情反复，世态炎凉。优游闲岁月，潇洒度时光。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>node-基本原理及工作流程</title>
    <link href="https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://gaoxing27.gitee.io/2021/06/16/node-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-16T02:52:33.000Z</published>
    <updated>2021-06-27T14:16:13.808Z</updated>
    
    <content type="html"><![CDATA[<p>Node 是一个服务器端 JavaScript 解释器，可以方便地搭建出响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型，非常适合在分布式设备上运行数据密集型的实时应用。</p><p>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台，功能完善，它实现了诸如文件系统、模块、包、操作系统 API、网络通信等功能 。</p><h3 id="v8引擎"><a href="#v8引擎" class="headerlink" title="v8引擎"></a>v8引擎</h3><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎，负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；你可以下载该引擎并将其嵌入任何应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p><h3 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h3><p>Java，PHP等编程语言是面向对象编程，Node是事件驱动编程的思想。<br>事件驱动编程，即为需要处理的事件编写相应的事件处理程序，代码在事件发生时执行，当事件触发时被操作系统唤醒，这样能更加有效地使用cpu。<br>事件驱动模型如图：</p><p><img src="/images/node/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" alt="事件驱动模型"></p><p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p><ul><li><p>事件源：产生事件的地方(html元素)</p></li><li><p>事件：点击/鼠标操作/键盘操作等等</p></li><li><p>事件对象：当某个事件发生时，可能会产生一个事件对象，该事件对象会封装好该事件的信息，传递给事件处理程序</p></li><li><p>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。</p><p>我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">e</span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">     <span class="built_in">window</span>.alert(<span class="string">&quot;x=&quot;</span>+e.clientX+<span class="string">&quot;y=&quot;</span>+e.clientY); </span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span> <span class="attr">onmousedown</span>=<span class="string">&quot;test1(event)&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h3><p>通常应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，而CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务，所以I/O才是应用程序的瓶颈所在；在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。</p><p>《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：</p><p><img src="/images/node/node%E6%94%AF%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="node支行流程图"></p><p>Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。</p><p>Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br>在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/xiangzhihong8/article/details/53954600">https://blog.csdn.net/xiangzhihong8/article/details/53954600</a></p></blockquote>]]></content>
    
    
    <summary type="html">Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</summary>
    
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/categories/Node/"/>
    
    
    <category term="Node" scheme="https://gaoxing27.gitee.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>图解kafka</title>
    <link href="https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/"/>
    <id>https://gaoxing27.gitee.io/2021/06/15/%E5%9B%BE%E8%A7%A3kafka/</id>
    <published>2021-06-15T07:47:44.000Z</published>
    <updated>2021-07-08T13:25:02.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。</p><p><img src="/images/kafka/base.jpg" alt="kafka"></p><p>生产者消费者<br>生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7-kafka-%E6%B6%88%E8%B4%B9.jpg" alt="生产-kafka-消费"></p><p>一个服务可以同时为生产者和消费者。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85-kafka.png" alt="生产消费者-kafka"></p><h3 id="Topics-主题"><a href="#Topics-主题" class="headerlink" title="Topics 主题"></a>Topics 主题</h3><p>Topic 是生产者发送消息的目标地址，是消费者的监听目标。</p><p><img src="/images/kafka/kafka-topic.png" alt="kafka-topic"></p><p>一个服务可以监听、发送多个 Topics。</p><p><img src="/images/kafka/%E5%8D%95%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AATopics.png" alt="单个服务监听多个Topics"></p><p>Kafka 中有一个【consumer-group（消费者组）】的概念。</p><p>这是一组服务，扮演一个消费者。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84.png" alt="消费者组"></p><p>如果是消费者组接收消息，Kafka 会把一条消息路由到组中的某一个服务。</p><p><img src="/images/kafka/%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1.png" alt="路由消息到消费者组中的某一个服务"></p><p>这样有助于消息的负载均衡，也方便扩展消费者。</p><p>Topic 扮演一个消息的队列。</p><p>首先，一条消息发送了。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E5%88%B0topic.png" alt="生产消息到topic"></p><p>然后，这条消息被记录和存储在这个队列中，不允许被修改。</p><p><img src="/images/kafka/topic%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9.png" alt="topic中的消息不允许修改"></p><p>接下来，消息会被发送给此 Topic 的消费者。</p><p>但是，这条消息并不会被删除，会继续保留在队列中。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E5%B9%B6%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%88%A0%E9%99%A4%EF%BC%8C%E4%BC%9A%E7%BB%A7%E7%BB%AD%E4%BF%9D%E7%95%99%E5%9C%A8%E9%98%9F%E5%88%97.png" alt="消息并不会被删除，会继续保留在队列"></p><p>继续发送消息。</p><p><img src="/images/kafka/%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="继续发送消息"></p><p>像之前一样，这条消息会发送给消费者、不允许被改动、一直呆在队列中。</p><p>（消息在队列中能呆多久，可以修改 Kafka 的配置）</p><p><img src="/images/kafka/a.png" alt="a"></p><p><img src="/images/kafka/b.png" alt="b"></p><h3 id="Partitions-分区"><a href="#Partitions-分区" class="headerlink" title="Partitions 分区"></a>Partitions 分区</h3><p>上面 Topic 的描述中，把 Topic 看做了一个队列，实际上，一个 Topic 是由多个队列组成的，被称为【Partition（分区）】。</p><p>这样可以便于 Topic 的扩展。</p><p><img src="/images/kafka/topic-Partitions.png" alt="topic-Partitions"></p><p>生产者发送消息的时候，这条消息会被路由到此 Topic 中的某一个 Partition。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0Topic%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AAPartition.png" alt="生产者发送消息到Topic中的某一个Partition"></p><p>消费者监听的是所有分区。</p><p><img src="/images/kafka/%E6%B6%88%E8%B4%B9%E8%80%85%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA.png" alt="消费者监听的是所有分区"></p><p>生产者发送消息时，默认是面向 Topic 的，由 Topic 决定放在哪个 Partition，默认使用轮询策略。</p><p><img src="/images/kafka/%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%94%B1Topic%E5%86%B3%E5%AE%9A%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AAPartition.png" alt="产者发送消息由Topic决定放在哪个Partition"></p><p>也可以配置 Topic，让同类型的消息都在同一个 Partition。</p><p>例如，处理用户消息，可以让某一个用户所有消息都在一个 Partition。</p><p>例如，用户1发送了3条消息：A、B、C，默认情况下，这3条消息是在不同的 Partition 中（如 P1、P2、P3）。</p><p>在配置之后，可以确保用户1的所有消息都发到同一个分区中（如 P1）。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="消息有序性"></p><p>这个功能有什么用呢？</p><p>这是为了提供消息的【有序性】。</p><p>消息在不同的 Partition 是不能保证有序的，只有一个 Partition 内的消息是有序的。</p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A72.png" alt="消息有序性2"></p><p><img src="/images/kafka/%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A73.png" alt="消息有序性3"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Kafka 是集群架构的，ZooKeeper是重要组件。</p><p><img src="/images/kafka/kafka-zookeeper.png" alt="kafka-zookeeper"></p><p>ZooKeeper 管理者所有的 Topic 和 Partition。</p><p>Topic 和 Partition 存储在 Node 物理节点中，ZooKeeper负责维护这些 Node。</p><p><img src="/images/kafka/kafka-zookeeper-znode.png" alt="kafka-zookeeper-znode"></p><p>例如，有2个 Topic，各自有2个 Partition。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B.png" alt="示例.png"></p><p>这是逻辑上的形式，但在 Kafka 集群中的实际存储可能是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B2.png" alt="示例2"></p><p>Topic A 的 Partition #1 有3份，分布在各个 Node 上。</p><p>这样可以增加 Kafka 的可靠性和系统弹性。</p><p>3个 Partition #1 中，ZooKeeper 会指定一个 Leader，负责接收生产者发来的消息。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B3.png" alt="示例3"></p><p>其他2个 Partition #1 会作为 Follower，Leader 接收到的消息会复制给 Follower。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B4.png" alt="示例4"></p><p>这样，每个 Partition 都含有了全量消息数据。</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B5.png" alt="示例5"></p><p>即使某个 Node 节点出现了故障，也不用担心消息的损坏。</p><p>Topic A 和 Topic B 的所有 Partition 分布可能就是这样的：</p><p><img src="/images/kafka/%E7%A4%BA%E4%BE%8B6.png" alt="示例6"></p><blockquote><p>原文<br>-<a href="https://blog.csdn.net/duysh/article/details/116355977">https://blog.csdn.net/duysh/article/details/116355977</a></p></blockquote>]]></content>
    
    
    <summary type="html">kafka 是一套流处理系统，可以让后端服务轻松的相互沟通，是微服务架构中常用的组件。生产者服务 Producer 向 Kafka 发送消息，消费者服务 Consumer 监听 Kafka 接收消息。一个服务可以同时为生产者和消费者。Topic 是生产者发送消息的目标地址，是消费者的监听目标。</summary>
    
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/categories/kafka/"/>
    
    
    <category term="kafka" scheme="https://gaoxing27.gitee.io/tags/kafka/"/>
    
    <category term="消息队列" scheme="https://gaoxing27.gitee.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="中间件" scheme="https://gaoxing27.gitee.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>简单生活，努力工作，爱自己爱家人</title>
    <link href="https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/"/>
    <id>https://gaoxing27.gitee.io/2021/06/01/%E7%AE%80%E5%8D%95%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%8A%AA%E5%8A%9B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E7%88%B1%E8%87%AA%E5%B7%B1%E7%88%B1%E5%AE%B6%E4%BA%BA/</id>
    <published>2021-06-01T10:32:48.000Z</published>
    <updated>2022-03-11T02:05:50.190Z</updated>
    
    <content type="html"><![CDATA[<p>静心平想，其实我是一个很幸运的人，我挺知足。</p><p>上学时代，激情满怀，却资质平庸，成绩上并无亮点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。我不想一下就耗尽自己的力气，同时也没有来得及去享受加油和呐喊助威。我希望我拼得不是速度，而是耐力。也许我跑的不是最快，不是第一，但是每坚实的跑出一步，都是我对的人生发于心的热爱，我会记住沿途的每一张笑脸和每一个从身边的奔跑过的人。</p><p>最近躺平、内卷，这两个词挺热的，了解完躺平、内卷，我简直下巴要掉到地上了，虽然现在生活好了，同时压力更大了，竞争更激烈，但是通过这种方式来对表达自己的反抗，太愚蠢了。也许目标看似遥不可及，如果躺下了，真就不可及了。</p><p>聪明的人善于计算，以现在的能力再怎么努力，也买不起房子、谈不起恋爱、结不起婚、生得起养不起孩子、上不起医院看不起病……，我感觉这些计算都是错的，这让我想起一个成语故事：刻舟求剑；社会在发展，经济在发展，人也在发展，发展就是变化，既然一切都是在变化中，为什么要用现在来计算未来，这哪是聪明，简直愚蠢；人类已经登上了月球，以后也许还会上火星，以后的以后还有更多的未知和惊喜</p><p>停止焦虑对你的束缚吧，世界上没有一种精密的模型可以计算未来，计算人的潜力，计算人的决心。<br>坐中静，破焦虑之贼<br>舍中得，破欲望之贼<br>事上练，破犹豫之贼<br>三贼皆破，万事可成<br>拾起这好时光，决心让自己变简单，让生活变简单，努力爱自己、家人和工作。</p>]]></content>
    
    
    <summary type="html">静心平想，其实我是一个很幸运的人，应该知足。上学时代，激情满怀，却资质平庸，成绩上并无高点，但也不是最差，可能这就要感谢一下自己的执着和坚持，所以还是挺幸运的。不要攻击我因为不是最差就沾沾自喜。不是的，我并非沾沾自喜，而是满足。有很些东西是需要天赋和机遇的，我不得不承认，我这两点都没有，是初心不变让我能有所得。我也是在毕业后才慢慢明白，如果非要把人生当作一场比赛，我希望我的比赛是一场马拉松，而不是百米赛跑。</summary>
    
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/categories/life/"/>
    
    
    <category term="生活" scheme="https://gaoxing27.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-spring-原理</title>
    <link href="https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://gaoxing27.gitee.io/2021/05/28/dubbo-spring-%E9%9B%86%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-28T09:35:13.000Z</published>
    <updated>2021-06-30T10:59:27.129Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：</p><ul><li>添加dubbo-spring-boot-starter依赖</li><li>定义@org.apache.dubbo.config.annotation.Service注解</li></ul><p>声明@DubboComponentScan，用于扫描@Service注解，Dubbo中的@Service注解和Spring中提供的@Service注解功能类似，用于实现Dubbo服务的暴露，与它相对应的时@Reference，它的作用类似于Spring中的@Autowired注解。而@DubboComponentScan和Spring中的@ComponentScan作用类似，用于扫描@Service、@Reference等注解。</p><h3 id="DubboComponentScan注解解析"><a href="#DubboComponentScan注解解析" class="headerlink" title="@DubboComponentScan注解解析"></a>@DubboComponentScan注解解析</h3><p><strong>DubboComponentScan</strong>注解的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(DubboComponentScanRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DubboComponentScan &#123;</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解主要通过@Import导入一个DubboComponentScanRegistrar类。DubboComponentScanRegistrar实现了ImportBeanDefinitionRegistrar接口，并且重写了registerBeanDefinitions方法。在registerBeanDefinitions方法中主要做了以下几件事：</p><ul><li>获取扫描包的路径，默认扫描当前配置类所在的包</li><li>注册@Service注解的解析类</li><li>注册@Reference注解的解析类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refisterBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportBeanDefinitionRegistrar是Spring提供的一种动态注入Bean的机制，和ImportSelector接口的功能类似，在refisterBeanDefinitions方法中，主要会实例化一些BeanDefinition并且注入到Spring IoC容器中；继续看registerServiceAnnotationBeanPostProcessor()方法，逻辑比较简单，就是把SerficeAnnotationBeanPostProcessor注册到容器；registerReferenceAnnotationBeanPostProcessor()方法是把ReferenceAnnotationBeanPostProcessor注册到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构建BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class);</span><br><span class="line">        builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">        builder.setRole(<span class="number">2</span>);</span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 把BeanDefinition注册到IoC容器中</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Service解析"><a href="#Service解析" class="headerlink" title="@Service解析"></a>@Service解析</h3><p>ServiceAnnotationBeanPostProcessor用于解析@Service注解，ReferenceAnnotationBeanPostProcessor用于解析@Reference注解</p><h3 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h3><p>ServiceAnnotationBeanPostProcessor类的定义如下，它的核心逻辑就是解析@Service注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor实现了4个接口，EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware这三个接口比较好理解，重点看一下BeanDefinitionRegistryPostProcessor；BeanDefinitionRegistryPostProcessor接口继承自BeanFactoryPostProcessor，是一种比较特殊的BeanFactoryPostProcessor；BeanDefinitionRegistryPostProcessor中的postProcessBeanDefinitionRegistry方法可以让我们实现自定义的注册Bean定义的逻辑。该方法主要做了以下几件事：</p><ul><li>调用registerBeans注册DubboBootstrapApplicationListener类</li><li>通过resolvePackagesToScan对packagesToScan参数进行去空格处理，并把配置文件中配置的扫描参数也一起处理。</li><li>调用registerServiceBeans完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AnnotatedBeanDefinitionRegistryUtils.registerBeans(registry, <span class="keyword">new</span> Class[]&#123;DubboBootstrapApplicationListener.class&#125;);</span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = <span class="keyword">this</span>.resolvePackagesToScan(<span class="keyword">this</span>.packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">&quot;packagesToScan is empty , ServiceBean registry will be ignored!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postProcessBeanDefinitionRegistry()方法的核心逻辑都在registerServiceBeans这个方法中，这个方法会查找需要扫描的指定包里面有@Service注解的类并将其注册成Bean。</p><ul><li>定义DubboClassPathBeanDefinitionScanner扫描对象，扫描指定路径下的类，将符合条件的类装配到IoC容器中。</li><li>BeanNameGenerator是Beans体系中比较重要的一个组件，会通过一定的算法计算出需要装配的Bean的name。</li><li>addIncludeFilter设置Scan的过滤条件，只扫描@Service注解修饰的类。</li><li>遍历指定的包，通过findServiceBeanDefinitionHolders查找@Service注解修饰的类。</li><li>通过registerServiceBean完成Bean的注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagesToScan The base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DubboClassPathBeanDefinitionScanner scanner =</span><br><span class="line">                <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"></span><br><span class="line">        BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line"></span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers @Service Bean first</span></span><br><span class="line">            scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finds all BeanDefinitionHolders of @Service whether @ComponentScan scans or not.</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =</span><br><span class="line">                    findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                    registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(beanDefinitionHolders.size() + <span class="string">&quot; annotated Dubbo&#x27;s @Service Components &#123; &quot;</span> +</span><br><span class="line">                            beanDefinitionHolders +</span><br><span class="line">                            <span class="string">&quot; &#125; were scanned under package[&quot;</span> + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span></span><br><span class="line">                            + packageToScan + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码主要作用就是通过扫描指定路径下添加了@Service注解的类，通过registerServiceBean来注册ServiceBean，整体来看，Dubbo的注解扫描进行服务发布的过程，实际上就是基于Spring的扩展。</p><p>继续分析registerServiceBean方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">     Service service = findAnnotation(beanClass, Service.class);</span><br><span class="line"></span><br><span class="line">     Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">     String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">     AbstractBeanDefinition serviceBeanDefinition =</span><br><span class="line">             buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ServiceBean Bean name</span></span><br><span class="line">     String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; <span class="comment">// check duplicated candidate bean</span></span><br><span class="line">         registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">&quot;The BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean has been registered with name : &quot;</span> + beanName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">             logger.warn(<span class="string">&quot;The Duplicated BeanDefinition[&quot;</span> + serviceBeanDefinition +</span><br><span class="line">                     <span class="string">&quot;] of ServiceBean[ bean name : &quot;</span> + beanName +</span><br><span class="line">                     <span class="string">&quot;] was be found , Did @DubboComponentScan scan to same package in many times?&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>resolveClass获取BeanDefinitionHolder中的Bean</li><li>findServiceAnnotation方法从beanClass类中找到@Service注解</li><li>getAnnotationAttributes方法获得注解中的属性，比如loadBalance、cluster等。</li><li>resolveServiceInterfaceClass方法用于获得beanClass对应的接口定义，其实在@Service(interfaceClass=xxxx.class)注解的声明中也可以声明interfaceClass，注解中声明的优先级最高，如果没有声明该属性，则会从父类中查找。</li><li>annotatedServiceBeanName代表Bean的名称。</li><li>buildServiceBeanDefinition用来构造org.apache.dubbo.config.spring.ServiceBean对象，每个Dubbo服务的发布最终都会出现一个ServiceBean。</li><li>调用registerBeanDefinition将ServiceBean注入Spring IoC容器中。</li></ul><p>从整个方法的分析来看，registerServiceBean方法主要是把一个ServiceBean注入到Spring IoC容器中，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不是像普通的Bean注入一样直接将HelloServiceImpl对象的实例注入容器，而是注入一个ServiceBean对象。对于HelloServiceImpl来说，它并不需要把自己注入Spring IoC容器中，而是需要把自己发布到网络上，提供给网络上的服务消费者来访问。那它是怎么发布到网络上的呢？</p><p>上面在postProcessBeanDefinitionRegistry方法中注册了DubboBootstrapApplicationListener事件监听Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrapApplicationListener</span> <span class="keyword">extends</span> <span class="title">OneTimeExecutionApplicationContextEventListener</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DubboBootstrap dubboBootstrap = DubboBootstrap.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrapApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationContextEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextRefreshedEvent((ContextRefreshedEvent)event);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onContextClosedEvent((ContextClosedEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的Bean都处理完成之后，Spring IoC会发布一个事件，事件类型为ComtextRefreshedEvent，当触发整个事件时，会调用onContextRefreshedEvent方法。在这个方法中，可以看到Dubbo服务启动的触发机制dubboBootstrap.start()。从这个方法中会进入org.apache.dubbo.config.ServiceConfig类中的export()方法，这个方法会启动一个网络监听，从而实现服务发布。</p><blockquote><p>引用</p><p><a href="https://blog.csdn.net/yangbaggio/article/details/105913431">https://blog.csdn.net/yangbaggio/article/details/105913431</a></p><p><a href="https://blog.csdn.net/DaySurprise/article/details/114897735">https://blog.csdn.net/DaySurprise/article/details/114897735</a></p><p><a href="https://www.cnblogs.com/jackion5/p/11219707.html">https://www.cnblogs.com/jackion5/p/11219707.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">使用Dubbo最方便的地方在于它可以和Spring非常方便的集成，实际上，Dubbo对于配置的优化，也是随着Spring一同发展的，从最早的XML形式到后来的注解方式以及自动装配，都是在不断地简化开发过程来提高开发效率。在Spring Boot集成Dubbo时，服务发布主要有以下几个步骤：添加dubbo-spring-boot-starter依赖;定义@org.apache.dubbo.config.annotation.Service注解</summary>
    
    
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/categories/Dubbo/"/>
    
    
    <category term="Spring" scheme="https://gaoxing27.gitee.io/tags/Spring/"/>
    
    <category term="Springboot" scheme="https://gaoxing27.gitee.io/tags/Springboot/"/>
    
    <category term="Dubbo" scheme="https://gaoxing27.gitee.io/tags/Dubbo/"/>
    
  </entry>
  
</feed>
